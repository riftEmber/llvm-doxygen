<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Transforms/IPO/IROutliner.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;19.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a72932e0778af28115095468f6286ff8.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_13abb262e9c52ddea8d07639819afd6c.html">IPO</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">IROutliner.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="IROutliner_8h_source.html">llvm/Transforms/IPO/IROutliner.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IRSimilarityIdentifier_8h_source.html">llvm/Analysis/IRSimilarityIdentifier.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OptimizationRemarkEmitter_8h_source.html">llvm/Analysis/OptimizationRemarkEmitter.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TargetTransformInfo_8h_source.html">llvm/Analysis/TargetTransformInfo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Attributes_8h_source.html">llvm/IR/Attributes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DIBuilder_8h_source.html">llvm/IR/DIBuilder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="llvm_2IR_2DebugInfo_8h_source.html">llvm/IR/DebugInfo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DebugInfoMetadata_8h_source.html">llvm/IR/DebugInfoMetadata.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominators_8h_source.html">llvm/IR/Dominators.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Mangler_8h_source.html">llvm/IR/Mangler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PassManager_8h_source.html">llvm/IR/PassManager.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="CommandLine_8h_source.html">llvm/Support/CommandLine.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IPO_8h_source.html">llvm/Transforms/IPO.h</a>&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="IROutliner_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOutlinableGroup.html">OutlinableGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structOutlinableGroup.html" title="The OutlinableGroup holds all the overarching information for outlining a set of regions that are str...">OutlinableGroup</a> holds all the overarching information for outlining a set of regions that are structurally similar to one another, such as the types of the overall function, the output blocks, the sets of stores needed and a list of the different regions.  <a href="structOutlinableGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html">llvm</a></td></tr>
<tr class="memdesc:namespacellvm"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an optimization pass for GlobalISel generic memory operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;iroutliner&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad0fabe111fc0db047a04c21481fa6aab" id="r_ad0fabe111fc0db047a04c21481fa6aab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0fabe111fc0db047a04c21481fa6aab">ArgLocWithBBCanon</a> = std::pair&lt;<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a>&gt;</td></tr>
<tr class="separator:ad0fabe111fc0db047a04c21481fa6aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69893e3a4e9fbee5b5aa9ac4b036dc5c" id="r_a69893e3a4e9fbee5b5aa9ac4b036dc5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69893e3a4e9fbee5b5aa9ac4b036dc5c">CanonList</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classunsigned.html">unsigned</a>, 2&gt;</td></tr>
<tr class="separator:a69893e3a4e9fbee5b5aa9ac4b036dc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0389cc3001a985e14dcff4067684ad70" id="r_a0389cc3001a985e14dcff4067684ad70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0389cc3001a985e14dcff4067684ad70">PHINodeData</a> = std::pair&lt;<a class="el" href="#ad0fabe111fc0db047a04c21481fa6aab">ArgLocWithBBCanon</a>, <a class="el" href="#a69893e3a4e9fbee5b5aa9ac4b036dc5c">CanonList</a>&gt;</td></tr>
<tr class="separator:a0389cc3001a985e14dcff4067684ad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3afc8c0c69b0c55edce3be13d5b7cc32" id="r_a3afc8c0c69b0c55edce3be13d5b7cc32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3afc8c0c69b0c55edce3be13d5b7cc32">moveBBContents</a> (<a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> &amp;SourceBB, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> &amp;TargetBB)</td></tr>
<tr class="memdesc:a3afc8c0c69b0c55edce3be13d5b7cc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the contents of <code>SourceBB</code> to before the last instruction of <code>TargetBB</code>.  <br /></td></tr>
<tr class="separator:a3afc8c0c69b0c55edce3be13d5b7cc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad786f21829d9e92d31cc0b80c53dbb" id="r_a8ad786f21829d9e92d31cc0b80c53dbb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ad786f21829d9e92d31cc0b80c53dbb">getSortedConstantKeys</a> (std::vector&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;SortedKeys, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;Map)</td></tr>
<tr class="memdesc:a8ad786f21829d9e92d31cc0b80c53dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to sort the keys of <code>Map</code>, which must be a mapping of constant values to basic blocks and return it in <code>SortedKeys</code>.  <br /></td></tr>
<tr class="separator:a8ad786f21829d9e92d31cc0b80c53dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5c4577c64728c435eca5f4f7e163ab" id="r_a8e5c4577c64728c435eca5f4f7e163ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e5c4577c64728c435eca5f4f7e163ab">replaceTargetsFromPHINode</a> (<a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *PHIBlock, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *<a class="el" href="MCSubtargetInfo_8cpp.html#a08e140d603b53c440c54cffc85131c8f">Find</a>, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *Replace, <a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;Included)</td></tr>
<tr class="memdesc:a8e5c4577c64728c435eca5f4f7e163ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the BranchInsts in the incoming blocks to <code>PHIBlock</code> that are found in <code>Included</code> to branch to BasicBlock <code>Replace</code> if they currently branch to the BasicBlock <code>Find</code>.  <br /></td></tr>
<tr class="separator:a8e5c4577c64728c435eca5f4f7e163ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77f2569521257316a0f374b9a2682c5" id="r_ac77f2569521257316a0f374b9a2682c5"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac77f2569521257316a0f374b9a2682c5">constantMatches</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classunsigned.html">unsigned</a> GVN, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classllvm_1_1Constant.html">Constant</a> * &gt; &amp;GVNToConstant)</td></tr>
<tr class="memdesc:ac77f2569521257316a0f374b9a2682c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find whether <code>V</code> matches the Constants previously found for the <code>GVN</code>.  <br /></td></tr>
<tr class="separator:ac77f2569521257316a0f374b9a2682c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d72084e637eaecbbadd192d547ef8e" id="r_ab0d72084e637eaecbbadd192d547ef8e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0d72084e637eaecbbadd192d547ef8e">findOutputMapping</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; OutputMappings, <a class="el" href="classllvm_1_1Value.html">Value</a> *Input)</td></tr>
<tr class="memdesc:ab0d72084e637eaecbbadd192d547ef8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the <code>OutputMappings</code> structure for value <code>Input</code>, if it exists it has been used as an output for outlining, and has been renamed, and we return the new value, otherwise, we return the same value.  <br /></td></tr>
<tr class="separator:ab0d72084e637eaecbbadd192d547ef8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a09c04ddc4ec6d039f1f11f01d019e" id="r_a52a09c04ddc4ec6d039f1f11f01d019e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52a09c04ddc4ec6d039f1f11f01d019e">collectRegionsConstants</a> (<a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classllvm_1_1Constant.html">Constant</a> * &gt; &amp;GVNToConstant, <a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;NotSame)</td></tr>
<tr class="memdesc:a52a09c04ddc4ec6d039f1f11f01d019e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find whether <code>Region</code> matches the global value numbering to Constant mapping found so far.  <br /></td></tr>
<tr class="separator:a52a09c04ddc4ec6d039f1f11f01d019e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5cfc936b6963f4e848982328d39e8e" id="r_aac5cfc936b6963f4e848982328d39e8e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1DISubprogram.html">DISubprogram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac5cfc936b6963f4e848982328d39e8e">getSubprogramOrNull</a> (<a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;Group)</td></tr>
<tr class="memdesc:aac5cfc936b6963f4e848982328d39e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the subprogram if it exists for one of the outlined regions.  <br /></td></tr>
<tr class="separator:aac5cfc936b6963f4e848982328d39e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4047976de351f78967fba27df7a6361f" id="r_a4047976de351f78967fba27df7a6361f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4047976de351f78967fba27df7a6361f">moveFunctionData</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;Old, <a class="el" href="classllvm_1_1Function.html">Function</a> &amp;New, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;NewEnds)</td></tr>
<tr class="memdesc:a4047976de351f78967fba27df7a6361f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move each BasicBlock in <code>Old</code> to <code>New</code>.  <br /></td></tr>
<tr class="separator:a4047976de351f78967fba27df7a6361f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda959f961048eba09125aba48d1142e" id="r_acda959f961048eba09125aba48d1142e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acda959f961048eba09125aba48d1142e">findConstants</a> (<a class="el" href="classllvm_1_1IRSimilarity_1_1IRSimilarityCandidate.html">IRSimilarityCandidate</a> &amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;NotSame, std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;Inputs)</td></tr>
<tr class="memdesc:acda959f961048eba09125aba48d1142e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the constants that will need to be lifted into arguments as they are not the same in each instance of the region.  <br /></td></tr>
<tr class="separator:acda959f961048eba09125aba48d1142e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9165dd298666d75ed2e5be7d5d8b50e5" id="r_a9165dd298666d75ed2e5be7d5d8b50e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9165dd298666d75ed2e5be7d5d8b50e5">mapInputsToGVNs</a> (<a class="el" href="classllvm_1_1IRSimilarity_1_1IRSimilarityCandidate.html">IRSimilarityCandidate</a> &amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;CurrentInputs, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;OutputMappings, std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;EndInputNumbers)</td></tr>
<tr class="memdesc:a9165dd298666d75ed2e5be7d5d8b50e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the GVN for the inputs that have been found by the CodeExtractor.  <br /></td></tr>
<tr class="separator:a9165dd298666d75ed2e5be7d5d8b50e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e9f16b4a1aaf539000b95bf5442155" id="r_a09e9f16b4a1aaf539000b95bf5442155"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09e9f16b4a1aaf539000b95bf5442155">remapExtractedInputs</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; ArgInputs, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;OutputMappings, <a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;RemappedArgInputs)</td></tr>
<tr class="memdesc:a09e9f16b4a1aaf539000b95bf5442155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the original value for the <code>ArgInput</code> values if any one of them was replaced during a previous extraction.  <br /></td></tr>
<tr class="separator:a09e9f16b4a1aaf539000b95bf5442155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d81e3f58b8db143bc85763d25dbc7a" id="r_a48d81e3f58b8db143bc85763d25dbc7a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48d81e3f58b8db143bc85763d25dbc7a">getCodeExtractorArguments</a> (<a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>, std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;InputGVNs, <a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;NotSame, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;OutputMappings, <a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;ArgInputs, <a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;Outputs)</td></tr>
<tr class="memdesc:a48d81e3f58b8db143bc85763d25dbc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the input GVNs and the output values for a region of Instructions.  <br /></td></tr>
<tr class="separator:a48d81e3f58b8db143bc85763d25dbc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9148948069532c9a5e1b59e3668b8cc3" id="r_a9148948069532c9a5e1b59e3668b8cc3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9148948069532c9a5e1b59e3668b8cc3">findExtractedInputToOverallInputMapping</a> (<a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>, std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;InputGVNs, <a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;ArgInputs)</td></tr>
<tr class="memdesc:a9148948069532c9a5e1b59e3668b8cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look over the inputs and map each input argument to an argument in the overall function for the OutlinableRegions.  <br /></td></tr>
<tr class="separator:a9148948069532c9a5e1b59e3668b8cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e785627d5ab55370b5fa402ad7193f" id="r_a84e785627d5ab55370b5fa402ad7193f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84e785627d5ab55370b5fa402ad7193f">outputHasNonPHI</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classunsigned.html">unsigned</a> PHILoc, <a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;PN, <a class="el" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *, 1 &gt; &amp;Exits, <a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;BlocksInRegion)</td></tr>
<tr class="memdesc:a84e785627d5ab55370b5fa402ad7193f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code>V</code> has any uses outside of the region other than <code>PN</code>.  <br /></td></tr>
<tr class="separator:a84e785627d5ab55370b5fa402ad7193f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882dcfc2455d525e78a8bbf46863ace2" id="r_a882dcfc2455d525e78a8bbf46863ace2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a882dcfc2455d525e78a8bbf46863ace2">analyzeExitPHIsForOutputUses</a> (<a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *CurrentExitFromRegion, <a class="el" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *, 1 &gt; &amp;PotentialExitsFromRegion, <a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;RegionBlocks, <a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;Outputs, <a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;OutputsReplacedByPHINode, <a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;OutputsWithNonPhiUses)</td></tr>
<tr class="memdesc:a882dcfc2455d525e78a8bbf46863ace2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether <code>CurrentExitFromRegion</code> contains any PhiNodes that should be considered outputs.  <br /></td></tr>
<tr class="separator:a882dcfc2455d525e78a8bbf46863ace2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652d50395284a0dec463c533709bc231" id="r_a652d50395284a0dec463c533709bc231"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1hash__code.html">hash_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a652d50395284a0dec463c533709bc231">encodePHINodeData</a> (<a class="el" href="#a0389cc3001a985e14dcff4067684ad70">PHINodeData</a> &amp;PND)</td></tr>
<tr class="memdesc:a652d50395284a0dec463c533709bc231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode <code>PND</code> as an integer for easy lookup based on the argument location, the parent BasicBlock canonical numbering, and the canonical numbering of the values stored in the PHINode.  <br /></td></tr>
<tr class="separator:a652d50395284a0dec463c533709bc231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7b2c4c8824cfb8d35c97f6923c3fe2" id="r_a1c7b2c4c8824cfb8d35c97f6923c3fe2"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c7b2c4c8824cfb8d35c97f6923c3fe2">getGVNForPHINode</a> (<a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>, <a class="el" href="classllvm_1_1PHINode.html">PHINode</a> *PN, <a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;<a class="el" href="ELF__riscv_8cpp.html#a1267deb72cf612df5cd950bf2eacb447">Blocks</a>, <a class="el" href="classunsigned.html">unsigned</a> AggArgIdx)</td></tr>
<tr class="memdesc:a1c7b2c4c8824cfb8d35c97f6923c3fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a special GVN for PHINodes that will be used outside of the region.  <br /></td></tr>
<tr class="separator:a1c7b2c4c8824cfb8d35c97f6923c3fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb66b98a828331ed6cb79ae82c0336f" id="r_a4eb66b98a828331ed6cb79ae82c0336f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eb66b98a828331ed6cb79ae82c0336f">findExtractedOutputToOverallOutputMapping</a> (<a class="el" href="classllvm_1_1Module.html">Module</a> &amp;M, <a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>, <a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;Outputs)</td></tr>
<tr class="memdesc:a4eb66b98a828331ed6cb79ae82c0336f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mapping of the output arguments for the <code>Region</code> to the output arguments of the overall outlined function.  <br /></td></tr>
<tr class="separator:a4eb66b98a828331ed6cb79ae82c0336f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2cad7ab18db9a3c940afc609c223dc" id="r_a7e2cad7ab18db9a3c940afc609c223dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1CallInst.html">CallInst</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e2cad7ab18db9a3c940afc609c223dc">replaceCalledFunction</a> (<a class="el" href="classllvm_1_1Module.html">Module</a> &amp;M, <a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>)</td></tr>
<tr class="memdesc:a7e2cad7ab18db9a3c940afc609c223dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the extracted function in the Region with a call to the overall function constructed from the deduplicated similar regions, replacing and remapping the values passed to the extracted function as arguments to the new arguments of the overall function.  <br /></td></tr>
<tr class="separator:a7e2cad7ab18db9a3c940afc609c223dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30ff2458bb283e423c1fc242a468579" id="r_af30ff2458bb283e423c1fc242a468579"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af30ff2458bb283e423c1fc242a468579">findOrCreatePHIBlock</a> (<a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;Group, <a class="el" href="classllvm_1_1Value.html">Value</a> *RetVal)</td></tr>
<tr class="memdesc:af30ff2458bb283e423c1fc242a468579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find or create a BasicBlock in the outlined function containing PhiBlocks for <code>RetVal</code>.  <br /></td></tr>
<tr class="separator:af30ff2458bb283e423c1fc242a468579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69884d9bf751011f8f9049542bbbd01" id="r_ad69884d9bf751011f8f9049542bbbd01"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad69884d9bf751011f8f9049542bbbd01">getPassedArgumentInAlreadyOutlinedFunction</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Argument.html">Argument</a> *<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>)</td></tr>
<tr class="memdesc:ad69884d9bf751011f8f9049542bbbd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the function call now representing the <code>Region</code>, find the passed value to that call that represents Argument <code>A</code> at the call location if the call has already been replaced with a call to the overall, aggregate function.  <br /></td></tr>
<tr class="separator:ad69884d9bf751011f8f9049542bbbd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202f8ebe30581a7e75bcedc9dee531af" id="r_a202f8ebe30581a7e75bcedc9dee531af"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a202f8ebe30581a7e75bcedc9dee531af">getPassedArgumentAndAdjustArgumentLocation</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Argument.html">Argument</a> *<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>)</td></tr>
<tr class="memdesc:a202f8ebe30581a7e75bcedc9dee531af"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the function call now representing the <code>Region</code>, find the passed value to that call that represents Argument <code>A</code> at the call location if the call has only been replaced by the call to the aggregate function.  <br /></td></tr>
<tr class="separator:a202f8ebe30581a7e75bcedc9dee531af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b0639ceb3f28de2e6a283098c525b2" id="r_a26b0639ceb3f28de2e6a283098c525b2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26b0639ceb3f28de2e6a283098c525b2">findCanonNumsForPHI</a> (<a class="el" href="classllvm_1_1PHINode.html">PHINode</a> *PN, <a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;OutputMappings, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &gt; &amp;CanonNums, <a class="el" href="classbool.html">bool</a> ReplacedWithOutlinedCall=<a class="el" href="BasicAliasAnalysis_8cpp.html#af6d5cafbdfc5313e65d990120021a3ec">true</a>)</td></tr>
<tr class="memdesc:a26b0639ceb3f28de2e6a283098c525b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the canonical numbering for the incoming Values into the PHINode <code>PN</code>.  <br /></td></tr>
<tr class="separator:a26b0639ceb3f28de2e6a283098c525b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556a77d9b9acf322358b2c4131986b13" id="r_a556a77d9b9acf322358b2c4131986b13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1PHINode.html">PHINode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a556a77d9b9acf322358b2c4131986b13">findOrCreatePHIInBlock</a> (<a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;PN, <a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *OverallPhiBlock, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;OutputMappings, <a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1PHINode.html">PHINode</a> * &gt; &amp;UsedPHIs)</td></tr>
<tr class="memdesc:a556a77d9b9acf322358b2c4131986b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find, or add PHINode <code>PN</code> to the combined PHINode Block <code>OverallPHIBlock</code> in order to condense the number of instructions added to the outlined function.  <br /></td></tr>
<tr class="separator:a556a77d9b9acf322358b2c4131986b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b5bd50d8e96b4c76ffc26508ce774d" id="r_a96b5bd50d8e96b4c76ffc26508ce774d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96b5bd50d8e96b4c76ffc26508ce774d">replaceArgumentUses</a> (<a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;OutputBBs, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;OutputMappings, <a class="el" href="classbool.html">bool</a> FirstFunction=false)</td></tr>
<tr class="separator:a96b5bd50d8e96b4c76ffc26508ce774d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace02ac07a3f704ffd345301bff92e5a8" id="r_ace02ac07a3f704ffd345301bff92e5a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace02ac07a3f704ffd345301bff92e5a8">replaceConstants</a> (<a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>)</td></tr>
<tr class="memdesc:ace02ac07a3f704ffd345301bff92e5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Within an extracted function, replace the constants that need to be lifted into arguments with the actual argument.  <br /></td></tr>
<tr class="separator:ace02ac07a3f704ffd345301bff92e5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af714eb55aced0ac27294c881d8be6ecb" id="r_af714eb55aced0ac27294c881d8be6ecb"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af714eb55aced0ac27294c881d8be6ecb">findDuplicateOutputBlock</a> (<a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;OutputBBs, std::vector&lt; <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &gt; &amp;OutputStoreBBs)</td></tr>
<tr class="memdesc:af714eb55aced0ac27294c881d8be6ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is possible that there is a basic block that already performs the same stores.  <br /></td></tr>
<tr class="separator:af714eb55aced0ac27294c881d8be6ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d54880afa1fb74833cc7c43ad33377" id="r_a57d54880afa1fb74833cc7c43ad33377"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57d54880afa1fb74833cc7c43ad33377">analyzeAndPruneOutputBlocks</a> (<a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;BlocksToPrune, <a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>)</td></tr>
<tr class="memdesc:a57d54880afa1fb74833cc7c43ad33377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove empty output blocks from the outlined region.  <br /></td></tr>
<tr class="separator:a57d54880afa1fb74833cc7c43ad33377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcb90c9c38b3381765a891d0a61c1ea" id="r_a4fcb90c9c38b3381765a891d0a61c1ea"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fcb90c9c38b3381765a891d0a61c1ea">alignOutputBlockWithAggFunc</a> (<a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;OG, <a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;OutputBBs, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;EndBBs, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;OutputMappings, std::vector&lt; <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &gt; &amp;OutputStoreBBs)</td></tr>
<tr class="memdesc:a4fcb90c9c38b3381765a891d0a61c1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the outlined section, move needed the StoreInsts for the output registers into their own block.  <br /></td></tr>
<tr class="separator:a4fcb90c9c38b3381765a891d0a61c1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8120984c169f2ea17e785e7c6887702a" id="r_a8120984c169f2ea17e785e7c6887702a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8120984c169f2ea17e785e7c6887702a">createAndInsertBasicBlocks</a> (<a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;OldMap, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;NewMap, <a class="el" href="classllvm_1_1Function.html">Function</a> *ParentFunc, <a class="el" href="classllvm_1_1Twine.html">Twine</a> BaseName)</td></tr>
<tr class="memdesc:a8120984c169f2ea17e785e7c6887702a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes in a mapping, <code>OldMap</code> of ConstantValues to BasicBlocks, sorts keys, before creating a basic block for each <code>NewMap</code>, and inserting into the new block.  <br /></td></tr>
<tr class="separator:a8120984c169f2ea17e785e7c6887702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86fef7fc5831c2514bff95bdf784d09" id="r_ae86fef7fc5831c2514bff95bdf784d09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae86fef7fc5831c2514bff95bdf784d09">createSwitchStatement</a> (<a class="el" href="classllvm_1_1Module.html">Module</a> &amp;M, <a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;OG, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;EndBBs, std::vector&lt; <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &gt; &amp;OutputStoreBBs)</td></tr>
<tr class="memdesc:ae86fef7fc5831c2514bff95bdf784d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the switch statement for outlined function to differentiate between all the output blocks.  <br /></td></tr>
<tr class="separator:ae86fef7fc5831c2514bff95bdf784d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e06ebf129ddfb3b33a64f1a456cfc24" id="r_a4e06ebf129ddfb3b33a64f1a456cfc24"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e06ebf129ddfb3b33a64f1a456cfc24">fillOverallFunction</a> (<a class="el" href="classllvm_1_1Module.html">Module</a> &amp;M, <a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;CurrentGroup, std::vector&lt; <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &gt; &amp;OutputStoreBBs, std::vector&lt; <a class="el" href="classllvm_1_1Function.html">Function</a> * &gt; &amp;FuncsToRemove, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;OutputMappings)</td></tr>
<tr class="memdesc:a4e06ebf129ddfb3b33a64f1a456cfc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the new function that will serve as the replacement function for all of the extracted regions of a certain structure from the first region in the list of regions.  <br /></td></tr>
<tr class="separator:a4e06ebf129ddfb3b33a64f1a456cfc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc949e06e148a6d2879eb45ca164146" id="r_a3bc949e06e148a6d2879eb45ca164146"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bc949e06e148a6d2879eb45ca164146">nextIRInstructionDataMatchesNextInst</a> (<a class="el" href="structllvm_1_1IRSimilarity_1_1IRInstructionData.html">IRInstructionData</a> &amp;ID)</td></tr>
<tr class="memdesc:a3bc949e06e148a6d2879eb45ca164146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the next instruction in the InstructionDataList matches the next instruction in the module.  <br /></td></tr>
<tr class="separator:a3bc949e06e148a6d2879eb45ca164146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b0641c5ffeeb3249b4ce9bb98c1a2d" id="r_ab4b0641c5ffeeb3249b4ce9bb98c1a2d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4b0641c5ffeeb3249b4ce9bb98c1a2d">findOutputValueInRegion</a> (<a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;<a class="el" href="classllvm_1_1Region.html">Region</a>, <a class="el" href="classunsigned.html">unsigned</a> OutputCanon)</td></tr>
<tr class="memdesc:ab4b0641c5ffeeb3249b4ce9bb98c1a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the <code>OutputCanon</code> number passed in find the value represented by this canonical number.  <br /></td></tr>
<tr class="separator:ab4b0641c5ffeeb3249b4ce9bb98c1a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b12ae89227758cb5684cc7cf25a7f43" id="r_a8b12ae89227758cb5684cc7cf25a7f43"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b12ae89227758cb5684cc7cf25a7f43">findCostForOutputBlocks</a> (<a class="el" href="classllvm_1_1Module.html">Module</a> &amp;M, <a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;CurrentGroup, <a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;<a class="el" href="namespacellvm.html#aa0d69e81725c10fa5407f0bf34462068">TTI</a>)</td></tr>
<tr class="memdesc:a8b12ae89227758cb5684cc7cf25a7f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the extra instructions needed to handle any output values for the region.  <br /></td></tr>
<tr class="separator:a8b12ae89227758cb5684cc7cf25a7f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a415af6f4421aa68820b3279b48acd928" id="r_a415af6f4421aa68820b3279b48acd928"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a415af6f4421aa68820b3279b48acd928">EnableLinkOnceODRIROutlining</a> (&quot;enable-linkonceodr-<a class="el" href="SafepointIRVerifier_8cpp.html#a3d3459f5796b9b9f0253f71d5620e958">ir</a>-outlining&quot;, cl::Hidden, <a class="el" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(&quot;Enable the <a class="el" href="Legalizer_8cpp.html#a05ab4853f7153e537774d02580e761ec">IR</a> outliner on linkonceodr functions&quot;), cl::init(false))</td></tr>
<tr class="separator:a415af6f4421aa68820b3279b48acd928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfbf70cabc04c37f6f46b2c312b2506" id="r_a2dfbf70cabc04c37f6f46b2c312b2506"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dfbf70cabc04c37f6f46b2c312b2506">NoCostModel</a> (&quot;ir-outlining-no-cost&quot;, cl::init(false), cl::ReallyHidden, <a class="el" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(&quot;Debug option to outline greedily, without restriction that &quot; &quot;calculated benefit outweighs cost&quot;))</td></tr>
<tr class="separator:a2dfbf70cabc04c37f6f46b2c312b2506"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;iroutliner&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00030">30</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad0fabe111fc0db047a04c21481fa6aab" name="ad0fabe111fc0db047a04c21481fa6aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fabe111fc0db047a04c21481fa6aab">&#9670;&#160;</a></span>ArgLocWithBBCanon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad0fabe111fc0db047a04c21481fa6aab">ArgLocWithBBCanon</a> = std::pair&lt;<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01143">1143</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

</div>
</div>
<a id="a69893e3a4e9fbee5b5aa9ac4b036dc5c" name="a69893e3a4e9fbee5b5aa9ac4b036dc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69893e3a4e9fbee5b5aa9ac4b036dc5c">&#9670;&#160;</a></span>CanonList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a69893e3a4e9fbee5b5aa9ac4b036dc5c">CanonList</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classunsigned.html">unsigned</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01145">1145</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

</div>
</div>
<a id="a0389cc3001a985e14dcff4067684ad70" name="a0389cc3001a985e14dcff4067684ad70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0389cc3001a985e14dcff4067684ad70">&#9670;&#160;</a></span>PHINodeData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0389cc3001a985e14dcff4067684ad70">PHINodeData</a> = std::pair&lt;<a class="el" href="#ad0fabe111fc0db047a04c21481fa6aab">ArgLocWithBBCanon</a>, <a class="el" href="#a69893e3a4e9fbee5b5aa9ac4b036dc5c">CanonList</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01148">1148</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4fcb90c9c38b3381765a891d0a61c1ea" name="a4fcb90c9c38b3381765a891d0a61c1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcb90c9c38b3381765a891d0a61c1ea">&#9670;&#160;</a></span>alignOutputBlockWithAggFunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void alignOutputBlockWithAggFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OG</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputBBs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>EndBBs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputMappings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputStoreBBs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the outlined section, move needed the StoreInsts for the output registers into their own block. </p>
<p>Then, determine if there is a duplicate output block already created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">OG</td><td>- The <a class="el" href="structOutlinableGroup.html" title="The OutlinableGroup holds all the overarching information for outlining a set of regions that are str...">OutlinableGroup</a> of regions to be outlined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Region</td><td>- The OutlinableRegion that is being analyzed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">OutputBBs</td><td>- the blocks that stores for this region will be placed in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndBBs</td><td>- the final blocks of the extracted function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputMappings</td><td>- OutputMappings the mapping of values that have been replaced by a new output value. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">OutputStoreBBs</td><td>- The existing output blocks. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l02072">2072</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="IROutliner_8cpp_source.html#l02025">analyzeAndPruneOutputBlocks()</a>, <a class="el" href="Instructions_8h_source.html#l02974">llvm::BranchInst::Create()</a>, <a class="el" href="Debug_8cpp_source.html#l00163">llvm::dbgs()</a>, <a class="el" href="DenseMap_8h_source.html#l00155">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::find()</a>, <a class="el" href="IROutliner_8cpp_source.html#l01970">findDuplicateOutputBlock()</a>, and <a class="el" href="Debug_8h_source.html#l00101">LLVM_DEBUG</a>.</p>

</div>
</div>
<a id="a57d54880afa1fb74833cc7c43ad33377" name="a57d54880afa1fb74833cc7c43ad33377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d54880afa1fb74833cc7c43ad33377">&#9670;&#160;</a></span>analyzeAndPruneOutputBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> analyzeAndPruneOutputBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>BlocksToPrune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove empty output blocks from the outlined region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BlocksToPrune</td><td>- Mapping of return values output blocks for the <code>Region</code>. </td></tr>
    <tr><td class="paramname">Region</td><td>- The OutlinableRegion we are analyzing. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l02025">2025</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="DenseMap_8h_source.html#l00345">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::erase()</a>, <a class="el" href="BasicBlock_8cpp_source.html#l00277">llvm::BasicBlock::eraseFromParent()</a>, <a class="el" href="BasicBlock_8h_source.html#l00459">llvm::BasicBlock::size()</a>, and <a class="el" href="ARMLowOverheadLoops_8cpp_source.html#l00534">ToRemove</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02072">alignOutputBlockWithAggFunc()</a>, and <a class="el" href="IROutliner_8cpp_source.html#l02246">fillOverallFunction()</a>.</p>

</div>
</div>
<a id="a882dcfc2455d525e78a8bbf46863ace2" name="a882dcfc2455d525e78a8bbf46863ace2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882dcfc2455d525e78a8bbf46863ace2">&#9670;&#160;</a></span>analyzeExitPHIsForOutputUses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void analyzeExitPHIsForOutputUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>CurrentExitFromRegion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *, 1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>PotentialExitsFromRegion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>RegionBlocks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputsReplacedByPHINode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputsWithNonPhiUses</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether <code>CurrentExitFromRegion</code> contains any PhiNodes that should be considered outputs. </p>
<p>A PHINodes is an output when more than one incoming value has been marked by the CodeExtractor as an output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CurrentExitFromRegion</td><td>[in] - The block to analyze. </td></tr>
    <tr><td class="paramname">PotentialExitsFromRegion</td><td>[in] - The potential exit blocks from the region. </td></tr>
    <tr><td class="paramname">RegionBlocks</td><td>[in] - The basic blocks in the region. </td></tr>
    <tr><td class="paramname">Outputs</td><td>[in, out] - The existing outputs for the region, we may add PHINodes to this as we find that they replace output values. </td></tr>
    <tr><td class="paramname">OutputsReplacedByPHINode</td><td>[out] - A set containing outputs that are totally replaced by a PHINode. </td></tr>
    <tr><td class="paramname">OutputsWithNonPhiUses</td><td>[out] - A set containing outputs that are used in PHINodes, but have other uses, and should still be considered outputs. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01095">1095</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="SmallVector_8h_source.html#l00281">llvm::SmallVectorTemplateCommon&lt; T, typename &gt;::begin()</a>, <a class="el" href="DenseSet_8h_source.html#l00185">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::contains()</a>, <a class="el" href="DenseSet_8h_source.html#l00101">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::erase()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="DenseSet_8h_source.html#l00206">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::insert()</a>, <a class="el" href="SetVector_8h_source.html#l00162">llvm::SetVector&lt; T, Vector, Set, N &gt;::insert()</a>, <a class="el" href="IROutliner_8cpp_source.html#l01038">outputHasNonPHI()</a>, <a class="el" href="BasicBlock_8h_source.html#l00507">llvm::BasicBlock::phis()</a>, <a class="el" href="SmallVector_8h_source.html#l00427">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>, and <a class="el" href="SmallVector_8h_source.html#l00092">llvm::SmallVectorBase&lt; Size_T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l01278">findExtractedOutputToOverallOutputMapping()</a>.</p>

</div>
</div>
<a id="a52a09c04ddc4ec6d039f1f11f01d019e" name="a52a09c04ddc4ec6d039f1f11f01d019e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a09c04ddc4ec6d039f1f11f01d019e">&#9670;&#160;</a></span>collectRegionsConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> collectRegionsConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classllvm_1_1Constant.html">Constant</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>GVNToConstant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>NotSame</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find whether <code>Region</code> matches the global value numbering to Constant mapping found so far. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Region</td><td>- The OutlinableRegion we are checking for constants </td></tr>
    <tr><td class="paramname">GVNToConstant</td><td>- The mapping of global value number to Constants. </td></tr>
    <tr><td class="paramname">NotSame</td><td>- The set of global value numbers that do not have the same constant in each region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all Constants are the same in every use of a Constant in <code>Region</code> and false if not </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00549">549</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="IROutliner_8cpp_source.html#l00463">constantMatches()</a>, <a class="el" href="DenseMap_8h_source.html#l00145">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::contains()</a>, <a class="el" href="DenseSet_8h_source.html#l00185">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::contains()</a>, <a class="el" href="DenseSet_8h_source.html#l00206">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::insert()</a>, and <a class="el" href="Casting_8h_source.html#l00548">llvm::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l00598">OutlinableGroup::findSameConstants()</a>.</p>

</div>
</div>
<a id="ac77f2569521257316a0f374b9a2682c5" name="ac77f2569521257316a0f374b9a2682c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77f2569521257316a0f374b9a2682c5">&#9670;&#160;</a></span>constantMatches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt; <a class="el" href="classbool.html">bool</a> &gt; constantMatches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>GVN</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classllvm_1_1Constant.html">Constant</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>GVNToConstant</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find whether <code>V</code> matches the Constants previously found for the <code>GVN</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>- The value to check for consistency. </td></tr>
    <tr><td class="paramname">GVN</td><td>- The global value number assigned to <code>V</code>. </td></tr>
    <tr><td class="paramname">GVNToConstant</td><td>- The mapping of global value number to Constants. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Value matches the Constant mapped to by V and false if it <code>V</code> is a Constant but does not match. </dd>
<dd>
std::nullopt if <code>V</code> is not a Constant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00463">463</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, and <a class="el" href="DenseMap_8h_source.html#l00220">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l00549">collectRegionsConstants()</a>.</p>

</div>
</div>
<a id="a8120984c169f2ea17e785e7c6887702a" name="a8120984c169f2ea17e785e7c6887702a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8120984c169f2ea17e785e7c6887702a">&#9670;&#160;</a></span>createAndInsertBasicBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void createAndInsertBasicBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OldMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>NewMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>ParentFunc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Twine.html">Twine</a></td>          <td class="paramname"><span class="paramname"><em>BaseName</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes in a mapping, <code>OldMap</code> of ConstantValues to BasicBlocks, sorts keys, before creating a basic block for each <code>NewMap</code>, and inserting into the new block. </p>
<p>Each BasicBlock is named with the scheme "&lt;basename&gt;_&lt;key_idx&gt;".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OldMap</td><td>[in] - The mapping to base the new mapping off of. </td></tr>
    <tr><td class="paramname">NewMap</td><td>[out] - The output mapping using the keys of <code>OldMap</code>. </td></tr>
    <tr><td class="paramname">ParentFunc</td><td>[in] - The function to put the new basic block in. </td></tr>
    <tr><td class="paramname">BaseName</td><td>[in] - The start of the BasicBlock names to be appended to by an index value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l02127">2127</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="BasicBlock_8h_source.html#l00202">llvm::BasicBlock::Create()</a>, <a class="el" href="Function_8cpp_source.html#l00358">llvm::Function::getContext()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00165">getSortedConstantKeys()</a>, and <a class="el" href="DenseMap_8h_source.html#l00220">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02153">createSwitchStatement()</a>, and <a class="el" href="IROutliner_8cpp_source.html#l02246">fillOverallFunction()</a>.</p>

</div>
</div>
<a id="ae86fef7fc5831c2514bff95bdf784d09" name="ae86fef7fc5831c2514bff95bdf784d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86fef7fc5831c2514bff95bdf784d09">&#9670;&#160;</a></span>createSwitchStatement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void createSwitchStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Module.html">Module</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OG</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>EndBBs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputStoreBBs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the switch statement for outlined function to differentiate between all the output blocks. </p>
<p>For the outlined section, determine if an outlined block already exists that matches the needed stores for the extracted section. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>- The module we are outlining from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OG</td><td>- The group of regions to be outlined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EndBBs</td><td>- The final blocks of the extracted function. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">OutputStoreBBs</td><td>- The existing output blocks. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l02153">2153</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8cpp_source.html#l03944">llvm::SwitchInst::addCase()</a>, <a class="el" href="Function_8h_source.html#l00864">llvm::Function::arg_size()</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Instructions_8h_source.html#l03236">llvm::SwitchInst::Create()</a>, <a class="el" href="IROutliner_8cpp_source.html#l02127">createAndInsertBasicBlocks()</a>, <a class="el" href="Debug_8cpp_source.html#l00163">llvm::dbgs()</a>, <a class="el" href="BasicBlock_8h_source.html#l00451">llvm::BasicBlock::end()</a>, <a class="el" href="DenseMap_8h_source.html#l00084">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::end()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00089">OutlinableGroup::EndBBs</a>, <a class="el" href="BasicBlock_8cpp_source.html#l00277">llvm::BasicBlock::eraseFromParent()</a>, <a class="el" href="DenseMap_8h_source.html#l00155">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::find()</a>, <a class="el" href="Function_8h_source.html#l00849">llvm::Function::getArg()</a>, <a class="el" href="Type_8cpp_source.html#l00254">llvm::Type::getInt32Ty()</a>, <a class="el" href="BasicBlock_8h_source.html#l00229">llvm::BasicBlock::getTerminator()</a>, <a class="el" href="Debug_8h_source.html#l00101">LLVM_DEBUG</a>, <a class="el" href="IROutliner_8cpp_source.html#l00156">moveBBContents()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00082">OutlinableGroup::OutlinedFunction</a>, <a class="el" href="IROutliner_8cpp_source.html#l00098">OutlinableGroup::OutputGVNCombinations</a>, <a class="el" href="BasicBlock_8h_source.html#l00459">llvm::BasicBlock::size()</a>, and <a class="el" href="Function_8h_source.html#l00821">llvm::Function::size()</a>.</p>

</div>
</div>
<a id="a652d50395284a0dec463c533709bc231" name="a652d50395284a0dec463c533709bc231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652d50395284a0dec463c533709bc231">&#9670;&#160;</a></span>encodePHINodeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1hash__code.html">hash_code</a> encodePHINodeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0389cc3001a985e14dcff4067684ad70">PHINodeData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>PND</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode <code>PND</code> as an integer for easy lookup based on the argument location, the parent BasicBlock canonical numbering, and the canonical numbering of the values stored in the PHINode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PND</td><td>- The data to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash code of <code>PND</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01156">1156</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="Hashing_8h_source.html#l00593">llvm::hash_combine()</a>, <a class="el" href="Hashing_8h_source.html#l00471">llvm::hash_combine_range()</a>, and <a class="el" href="APFixedPoint_8h_source.html#l00128">llvm::hash_value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l01176">getGVNForPHINode()</a>.</p>

</div>
</div>
<a id="a4e06ebf129ddfb3b33a64f1a456cfc24" name="a4e06ebf129ddfb3b33a64f1a456cfc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e06ebf129ddfb3b33a64f1a456cfc24">&#9670;&#160;</a></span>fillOverallFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fillOverallFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Module.html">Module</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>CurrentGroup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputStoreBBs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1Function.html">Function</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>FuncsToRemove</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputMappings</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the new function that will serve as the replacement function for all of the extracted regions of a certain structure from the first region in the list of regions. </p>
<p>Replace this first region's extracted function with the new overall function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>- The module we are outlining from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CurrentGroup</td><td>- The group of regions to be outlined. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">OutputStoreBBs</td><td>- The output blocks for each different set of stores needed for the different functions. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">FuncsToRemove</td><td>- Extracted functions to erase from module once outlining is complete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputMappings</td><td>- Extracted functions to erase from module once outlining is complete. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l02246">2246</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="Function_8cpp_source.html#l00629">llvm::Function::addFnAttr()</a>, <a class="el" href="IROutliner_8cpp_source.html#l02025">analyzeAndPruneOutputBlocks()</a>, <a class="el" href="IROutliner_8h_source.html#l00123">llvm::OutlinableRegion::Call</a>, <a class="el" href="Instructions_8h_source.html#l02974">llvm::BranchInst::Create()</a>, <a class="el" href="IROutliner_8cpp_source.html#l02127">createAndInsertBasicBlocks()</a>, <a class="el" href="Debug_8cpp_source.html#l00163">llvm::dbgs()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00089">OutlinableGroup::EndBBs</a>, <a class="el" href="IROutliner_8h_source.html#l00126">llvm::OutlinableRegion::ExtractedFunction</a>, <a class="el" href="Function_8h_source.html#l00350">llvm::Function::getAttributes()</a>, <a class="el" href="Attributes_8cpp_source.html#l01628">llvm::AttributeList::getFnAttrs()</a>, <a class="el" href="Debug_8h_source.html#l00101">LLVM_DEBUG</a>, <a class="el" href="IROutliner_8cpp_source.html#l00708">moveFunctionData()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00082">OutlinableGroup::OutlinedFunction</a>, <a class="el" href="IROutliner_8h_source.html#l00078">llvm::OutlinableRegion::OutputBlockNum</a>, <a class="el" href="IROutliner_8cpp_source.html#l00074">OutlinableGroup::Regions</a>, <a class="el" href="IROutliner_8cpp_source.html#l01803">replaceArgumentUses()</a>, <a class="el" href="IROutliner_8cpp_source.html#l01432">replaceCalledFunction()</a>, and <a class="el" href="IROutliner_8cpp_source.html#l01937">replaceConstants()</a>.</p>

</div>
</div>
<a id="a26b0639ceb3f28de2e6a283098c525b2" name="a26b0639ceb3f28de2e6a283098c525b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b0639ceb3f28de2e6a283098c525b2">&#9670;&#160;</a></span>findCanonNumsForPHI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void findCanonNumsForPHI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1PHINode.html">PHINode</a> *</td>          <td class="paramname"><span class="paramname"><em>PN</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputMappings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>CanonNums</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>ReplacedWithOutlinedCall</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="BasicAliasAnalysis_8cpp.html#af6d5cafbdfc5313e65d990120021a3ec">true</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the canonical numbering for the incoming Values into the PHINode <code>PN</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PN</td><td>[in] - The PHINode that we are finding the canonical numbers for. </td></tr>
    <tr><td class="paramname">Region</td><td>[in] - The OutlinableRegion containing <code>PN</code>. </td></tr>
    <tr><td class="paramname">OutputMappings</td><td>[in] - The mapping of output values from outlined region to their original values. </td></tr>
    <tr><td class="paramname">CanonNums</td><td>[out] - The canonical numbering for the incoming values to <code>PN</code> paired with their incoming block. </td></tr>
    <tr><td class="paramname">ReplacedWithOutlinedCall</td><td>- A flag to use the extracted function call of <code>Region</code> rather than the overall function's call. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01637">1637</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00530">findOutputMapping()</a>, <a class="el" href="Instructions_8h_source.html#l02597">llvm::PHINode::getIncomingBlock()</a>, <a class="el" href="Instructions_8h_source.html#l02577">llvm::PHINode::getIncomingValue()</a>, <a class="el" href="Instructions_8h_source.html#l02573">llvm::PHINode::getNumIncomingValues()</a>, <a class="el" href="IROutliner_8cpp_source.html#l01612">getPassedArgumentAndAdjustArgumentLocation()</a>, and <a class="el" href="IROutliner_8cpp_source.html#l01596">getPassedArgumentInAlreadyOutlinedFunction()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l01681">findOrCreatePHIInBlock()</a>.</p>

</div>
</div>
<a id="acda959f961048eba09125aba48d1142e" name="acda959f961048eba09125aba48d1142e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda959f961048eba09125aba48d1142e">&#9670;&#160;</a></span>findConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void findConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IRSimilarity_1_1IRSimilarityCandidate.html">IRSimilarityCandidate</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>NotSame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Inputs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the constants that will need to be lifted into arguments as they are not the same in each instance of the region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>- The IRSimilarityCandidate containing the region we are analyzing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NotSame</td><td>- The set of global value numbers that do not have a single Constant across all OutlinableRegions similar to <code>C</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Inputs</td><td>- The list containing the global value numbers of the arguments needed for the region of code. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00780">780</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="DenseSet_8h_source.html#l00185">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::contains()</a>, <a class="el" href="DenseSet_8h_source.html#l00206">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::insert()</a>, and <a class="el" href="Casting_8h_source.html#l00548">llvm::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l00865">getCodeExtractorArguments()</a>.</p>

</div>
</div>
<a id="a8b12ae89227758cb5684cc7cf25a7f43" name="a8b12ae89227758cb5684cc7cf25a7f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b12ae89227758cb5684cc7cf25a7f43">&#9670;&#160;</a></span>findCostForOutputBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> findCostForOutputBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Module.html">Module</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>CurrentGroup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>TTI</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the extra instructions needed to handle any output values for the region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>- The Module to outline from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CurrentGroup</td><td>- The collection of OutlinableRegions to analyze. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TTI</td><td>- The TargetTransformInfo used to collect information for new instruction costs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the additional cost to handle the outputs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l02559">2559</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstrTypes_8h_source.html#l00790">llvm::CmpInst::BAD_ICMP_PREDICATE</a>, <a class="el" href="IROutliner_8cpp_source.html#l00114">OutlinableGroup::BranchesToOutside</a>, <a class="el" href="DenseSet_8h_source.html#l00185">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::contains()</a>, <a class="el" href="Debug_8cpp_source.html#l00163">llvm::dbgs()</a>, <a class="el" href="IROutliner_8cpp_source.html#l02507">findOutputValueInRegion()</a>, <a class="el" href="IRSimilarityIdentifier_8h_source.html#l00898">llvm::IRSimilarity::IRSimilarityCandidate::getBasicBlocks()</a>, <a class="el" href="TargetTransformInfo_8cpp_source.html#l01006">llvm::TargetTransformInfo::getCFInstrCost()</a>, <a class="el" href="TargetTransformInfo_8cpp_source.html#l01015">llvm::TargetTransformInfo::getCmpSelInstrCost()</a>, <a class="el" href="Type_8cpp_source.html#l00254">llvm::Type::getInt32Ty()</a>, <a class="el" href="TargetTransformInfo_8cpp_source.html#l01059">llvm::TargetTransformInfo::getMemoryOpCost()</a>, <a class="el" href="DenseSet_8h_source.html#l00206">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::insert()</a>, <a class="el" href="Casting_8h_source.html#l00548">llvm::isa()</a>, <a class="el" href="Debug_8h_source.html#l00101">LLVM_DEBUG</a>, <a class="el" href="IROutliner_8cpp_source.html#l00098">OutlinableGroup::OutputGVNCombinations</a>, <a class="el" href="IROutliner_8cpp_source.html#l00074">OutlinableGroup::Regions</a>, and <a class="el" href="TargetTransformInfo_8h_source.html#l00262">llvm::TargetTransformInfo::TCK_CodeSize</a>.</p>

</div>
</div>
<a id="af714eb55aced0ac27294c881d8be6ecb" name="af714eb55aced0ac27294c881d8be6ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af714eb55aced0ac27294c881d8be6ecb">&#9670;&#160;</a></span>findDuplicateOutputBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; findDuplicateOutputBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputBBs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputStoreBBs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is possible that there is a basic block that already performs the same stores. </p>
<p>This returns a duplicate block, if it exists</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OutputBBs</td><td>[in] the blocks we are looking for a duplicate of. </td></tr>
    <tr><td class="paramname">OutputStoreBBs</td><td>[in] The existing output blocks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an optional value with the number output block if there is a match. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01970">1970</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="BasicBlock_8h_source.html#l00438">llvm::BasicBlock::begin()</a>, <a class="el" href="DenseMap_8h_source.html#l00084">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::end()</a>, <a class="el" href="DenseMap_8h_source.html#l00155">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::find()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="Casting_8h_source.html#l00548">llvm::isa()</a>, and <a class="el" href="BasicBlock_8h_source.html#l00459">llvm::BasicBlock::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02072">alignOutputBlockWithAggFunc()</a>.</p>

</div>
</div>
<a id="a9148948069532c9a5e1b59e3668b8cc3" name="a9148948069532c9a5e1b59e3668b8cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9148948069532c9a5e1b59e3668b8cc3">&#9670;&#160;</a></span>findExtractedInputToOverallInputMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void findExtractedInputToOverallInputMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InputGVNs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ArgInputs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look over the inputs and map each input argument to an argument in the overall function for the OutlinableRegions. </p>
<p>This creates a way to replace the arguments of the extracted function with the arguments of the new overall function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Region</td><td>- The region of code to be analyzed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InputGVNs</td><td>- The global value numbering of the input values collected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ArgInputs</td><td>- The values of the arguments to the extracted function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00936">936</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="IROutliner_8cpp_source.html#l00078">OutlinableGroup::ArgumentTypes</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="IROutliner_8cpp_source.html#l00110">OutlinableGroup::CanonicalNumberToAggArg</a>, <a class="el" href="SetVector_8h_source.html#l00264">llvm::SetVector&lt; T, Vector, Set, N &gt;::count()</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="DenseMap_8h_source.html#l00084">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::end()</a>, <a class="el" href="DenseMap_8h_source.html#l00155">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::find()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00102">OutlinableGroup::InputTypesSet</a>, <a class="el" href="DenseMap_8h_source.html#l00220">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::insert()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00106">OutlinableGroup::NumAggregateInputs</a>, and <a class="el" href="IROutliner_8cpp_source.html#l00135">OutlinableGroup::SwiftErrorArgument</a>.</p>

</div>
</div>
<a id="a4eb66b98a828331ed6cb79ae82c0336f" name="a4eb66b98a828331ed6cb79ae82c0336f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb66b98a828331ed6cb79ae82c0336f">&#9670;&#160;</a></span>findExtractedOutputToOverallOutputMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void findExtractedOutputToOverallOutputMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Module.html">Module</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Outputs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mapping of the output arguments for the <code>Region</code> to the output arguments of the overall outlined function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Region</td><td>- The region of code to be analyzed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Outputs</td><td>- The values found by the code extractor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01278">1278</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="IROutliner_8cpp_source.html#l01095">analyzeExitPHIsForOutputUses()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00078">OutlinableGroup::ArgumentTypes</a>, <a class="el" href="namespacellvm.html#a0e00fad9c34de40b1e31f3aa6f8e024cae1e4c8c9ccd9fc39c391da4bcd093fb2">llvm::Block</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="DenseSet_8h_source.html#l00185">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::contains()</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="classllvm_1_1PointerType.html#a8d7f800be5fd53dcfcdcbdc6fd9ccfe3">llvm::PointerType::get()</a>, <a class="el" href="IROutliner_8cpp_source.html#l01176">getGVNForPHINode()</a>, <a class="el" href="ilist__node_8h_source.html#l00032">llvm::ilist_detail::node_parent_access&lt; NodeTy, ParentTy &gt;::getParent()</a>, <a class="el" href="DenseSet_8h_source.html#l00206">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::insert()</a>, <a class="el" href="SmallPtrSet_8h_source.html#l00344">llvm::SmallPtrSetImpl&lt; PtrType &gt;::insert()</a>, <a class="el" href="Casting_8h_source.html#l00548">llvm::isa()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00106">OutlinableGroup::NumAggregateInputs</a>, <a class="el" href="STLExtras_8h_source.html#l01995">llvm::stable_sort()</a>, and <a class="el" href="MachineBasicBlock_8h_source.html#l01340">llvm::successors()</a>.</p>

</div>
</div>
<a id="af30ff2458bb283e423c1fc242a468579" name="af30ff2458bb283e423c1fc242a468579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30ff2458bb283e423c1fc242a468579">&#9670;&#160;</a></span>findOrCreatePHIBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * findOrCreatePHIBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>RetVal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find or create a BasicBlock in the outlined function containing PhiBlocks for <code>RetVal</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Group</td><td>- The <a class="el" href="structOutlinableGroup.html" title="The OutlinableGroup holds all the overarching information for outlining a set of regions that are str...">OutlinableGroup</a> containing the information about the overall outlined function. </td></tr>
    <tr><td class="paramname">RetVal</td><td>- The return value or exit option that we are currently evaluating. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found or newly created BasicBlock to contain the needed PHINodes to be used as outputs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01543">1543</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Casting_8h_source.html#l00565">llvm::cast()</a>, <a class="el" href="BasicBlock_8h_source.html#l00202">llvm::BasicBlock::Create()</a>, <a class="el" href="Instructions_8h_source.html#l02974">llvm::BranchInst::Create()</a>, <a class="el" href="ELF__riscv_8cpp_source.html#l00480">End</a>, <a class="el" href="IROutliner_8cpp_source.html#l00089">OutlinableGroup::EndBBs</a>, <a class="el" href="BasicBlock_8cpp_source.html#l00168">llvm::BasicBlock::getContext()</a>, <a class="el" href="BasicBlock_8h_source.html#l00209">llvm::BasicBlock::getParent()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00093">OutlinableGroup::PHIBlocks</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l01341">llvm::predecessors()</a>, and <a class="el" href="SmallVector_8h_source.html#l00427">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l01803">replaceArgumentUses()</a>.</p>

</div>
</div>
<a id="a556a77d9b9acf322358b2c4131986b13" name="a556a77d9b9acf322358b2c4131986b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556a77d9b9acf322358b2c4131986b13">&#9670;&#160;</a></span>findOrCreatePHIInBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1PHINode.html">PHINode</a> * findOrCreatePHIInBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>PN</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>OverallPhiBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputMappings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1PHINode.html">PHINode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>UsedPHIs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find, or add PHINode <code>PN</code> to the combined PHINode Block <code>OverallPHIBlock</code> in order to condense the number of instructions added to the outlined function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PN</td><td>[in] - The PHINode that we are finding the canonical numbers for. </td></tr>
    <tr><td class="paramname">Region</td><td>[in] - The OutlinableRegion containing <code>PN</code>. </td></tr>
    <tr><td class="paramname">OverallPhiBlock</td><td>[in] - The overall PHIBlock we are trying to find <code>PN</code> in. </td></tr>
    <tr><td class="paramname">OutputMappings</td><td>[in] - The mapping of output values from outlined region to their original values. </td></tr>
    <tr><td class="paramname">UsedPHIs</td><td>[in, out] - The PHINodes in the block that have already been matched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly found or created PHINode in <code>OverallPhiBlock</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01681">1681</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BasicBlock_8h_source.html#l00438">llvm::BasicBlock::begin()</a>, <a class="el" href="Casting_8h_source.html#l00565">llvm::cast()</a>, <a class="el" href="SmallVector_8h_source.html#l00624">llvm::SmallVectorImpl&lt; T &gt;::clear()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l01299">llvm::Instruction::clone()</a>, <a class="el" href="DenseSet_8h_source.html#l00185">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::contains()</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="IROutliner_8cpp_source.html#l01637">findCanonNumsForPHI()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00530">findOutputMapping()</a>, <a class="el" href="Function_8h_source.html#l00849">llvm::Function::getArg()</a>, <a class="el" href="Instructions_8h_source.html#l02597">llvm::PHINode::getIncomingBlock()</a>, <a class="el" href="Instructions_8h_source.html#l02577">llvm::PHINode::getIncomingValue()</a>, <a class="el" href="Instructions_8h_source.html#l02573">llvm::PHINode::getNumIncomingValues()</a>, <a class="el" href="DenseSet_8h_source.html#l00206">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::insert()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00097">llvm::Instruction::insertBefore()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00082">OutlinableGroup::OutlinedFunction</a>, <a class="el" href="BasicBlock_8h_source.html#l00507">llvm::BasicBlock::phis()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00074">OutlinableGroup::Regions</a>, <a class="el" href="IROutliner_8h_source.html#l00093">llvm::OutlinableRegion::RemappedArguments</a>, <a class="el" href="Instructions_8h_source.html#l02616">llvm::PHINode::setIncomingBlock()</a>, <a class="el" href="Instructions_8h_source.html#l02580">llvm::PHINode::setIncomingValue()</a>, and <a class="el" href="SmallVector_8h_source.html#l00092">llvm::SmallVectorBase&lt; Size_T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l01803">replaceArgumentUses()</a>.</p>

</div>
</div>
<a id="ab0d72084e637eaecbbadd192d547ef8e" name="ab0d72084e637eaecbbadd192d547ef8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d72084e637eaecbbadd192d547ef8e">&#9670;&#160;</a></span>findOutputMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * findOutputMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>OutputMappings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Input</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the <code>OutputMappings</code> structure for value <code>Input</code>, if it exists it has been used as an output for outlining, and has been renamed, and we return the new value, otherwise, we return the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OutputMappings</td><td>[in] - The mapping of values to their renamed value after being used as an output for an outlined region. </td></tr>
    <tr><td class="paramname">Input</td><td>[in] - The value to find the remapped value of, if it exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The remapped value if it has been renamed, and the same value if has not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00530">530</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="DenseMap_8h_source.html#l00084">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::end()</a>, and <a class="el" href="DenseMap_8h_source.html#l00155">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::find()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l01637">findCanonNumsForPHI()</a>, and <a class="el" href="IROutliner_8cpp_source.html#l01681">findOrCreatePHIInBlock()</a>.</p>

</div>
</div>
<a id="ab4b0641c5ffeeb3249b4ce9bb98c1a2d" name="ab4b0641c5ffeeb3249b4ce9bb98c1a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b0641c5ffeeb3249b4ce9bb98c1a2d">&#9670;&#160;</a></span>findOutputValueInRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * findOutputValueInRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>OutputCanon</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the <code>OutputCanon</code> number passed in find the value represented by this canonical number. </p>
<p>If it is from a PHINode, we pick the first incoming value and return that Value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Region</td><td>- The OutlinableRegion to get the Value from. </td></tr>
    <tr><td class="paramname">OutputCanon</td><td>- The canonical number to find the Value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Value represented by a canonical number <code>OutputCanon</code> in <code>Region</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l02507">2507</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00123">OutlinableGroup::PHINodeGVNToGVNs</a>, and <a class="el" href="IROutliner_8cpp_source.html#l00119">OutlinableGroup::PHINodeGVNTracker</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02559">findCostForOutputBlocks()</a>.</p>

</div>
</div>
<a id="a48d81e3f58b8db143bc85763d25dbc7a" name="a48d81e3f58b8db143bc85763d25dbc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d81e3f58b8db143bc85763d25dbc7a">&#9670;&#160;</a></span>getCodeExtractorArguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void getCodeExtractorArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InputGVNs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>NotSame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputMappings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ArgInputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Outputs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the input GVNs and the output values for a region of Instructions. </p>
<p>Using the code extractor, we collect the inputs to the extracted function.</p>
<p>The <code>Region</code> can be identified as needing to be ignored in this function. It should be checked whether it should be ignored after a call to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Region</td><td>- The region of code to be analyzed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">InputGVNs</td><td>- The global value numbers for the extracted arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NotSame</td><td>- The global value numbers in the region that do not have the same constant value in the regions structurally similar to <code>Region</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputMappings</td><td>- The mapping of values that have been replaced by a new output value after extraction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ArgInputs</td><td>- The values of the inputs to the extracted function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Outputs</td><td>- The set of values extracted by the CodeExtractor as outputs. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00865">865</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="IROutliner_8cpp_source.html#l00780">findConstants()</a>, <a class="el" href="SetVector_8h_source.html#l00084">llvm::SetVector&lt; T, Vector, Set, N &gt;::getArrayRef()</a>, <a class="el" href="RegionInfo_8h_source.html#l00364">llvm::RegionBase&lt; Tr &gt;::getParent()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00810">mapInputsToGVNs()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00835">remapExtractedInputs()</a>, <a class="el" href="SetVector_8h_source.html#l00098">llvm::SetVector&lt; T, Vector, Set, N &gt;::size()</a>, and <a class="el" href="STLExtras_8h_source.html#l01995">llvm::stable_sort()</a>.</p>

</div>
</div>
<a id="a1c7b2c4c8824cfb8d35c97f6923c3fe2" name="a1c7b2c4c8824cfb8d35c97f6923c3fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7b2c4c8824cfb8d35c97f6923c3fe2">&#9670;&#160;</a></span>getGVNForPHINode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; getGVNForPHINode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1PHINode.html">PHINode</a> *</td>          <td class="paramname"><span class="paramname"><em>PN</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Blocks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AggArgIdx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a special GVN for PHINodes that will be used outside of the region. </p>
<p>We create a hash code based on the Canonical number of the parent BasicBlock, the canonical numbering of the values stored in the PHINode and the aggregate argument location. This is used to find whether this PHINode type has been given a canonical numbering already. If not, we assign it a value and store it for later use. The value is returned to identify different output schemes for the set of regions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Region</td><td>- The region that <code>PN</code> is an output for. </td></tr>
    <tr><td class="paramname">PN</td><td>- The PHINode we are analyzing. </td></tr>
    <tr><td class="paramname">Blocks</td><td>- The blocks for the region we are analyzing. </td></tr>
    <tr><td class="paramname">AggArgIdx</td><td>- The argument <code>PN</code> will be stored into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An optional holding the assigned canonical number, or std::nullopt if there is some attribute of the PHINode blocking it from being used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01176">1176</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="ELF__riscv_8cpp_source.html#l00507">Blocks</a>, <a class="el" href="IROutliner_8cpp_source.html#l01156">encodePHINodeData()</a>, <a class="el" href="IRSimilarityIdentifier_8h_source.html#l00984">llvm::IRSimilarity::IRSimilarityCandidate::getCanonicalNum()</a>, <a class="el" href="IRSimilarityIdentifier_8h_source.html#l00958">llvm::IRSimilarity::IRSimilarityCandidate::getGVN()</a>, <a class="el" href="Instructions_8h_source.html#l02597">llvm::PHINode::getIncomingBlock()</a>, <a class="el" href="Instructions_8h_source.html#l02577">llvm::PHINode::getIncomingValue()</a>, <a class="el" href="Instructions_8h_source.html#l02573">llvm::PHINode::getNumIncomingValues()</a>, <a class="el" href="ilist__node_8h_source.html#l00032">llvm::ilist_detail::node_parent_access&lt; NodeTy, ParentTy &gt;::getParent()</a>, <a class="el" href="IRSimilarityIdentifier_8h_source.html#l00947">llvm::IRSimilarity::IRSimilarityCandidate::getStartBB()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00124">OutlinableGroup::GVNsToPHINodeGVN</a>, <a class="el" href="IROutliner_8cpp_source.html#l00123">OutlinableGroup::PHINodeGVNToGVNs</a>, <a class="el" href="IROutliner_8cpp_source.html#l00119">OutlinableGroup::PHINodeGVNTracker</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l01341">llvm::predecessors()</a>, and <a class="el" href="SmallVector_8h_source.html#l00427">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l01278">findExtractedOutputToOverallOutputMapping()</a>.</p>

</div>
</div>
<a id="a202f8ebe30581a7e75bcedc9dee531af" name="a202f8ebe30581a7e75bcedc9dee531af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202f8ebe30581a7e75bcedc9dee531af">&#9670;&#160;</a></span>getPassedArgumentAndAdjustArgumentLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * getPassedArgumentAndAdjustArgumentLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Argument.html">Argument</a> *</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the function call now representing the <code>Region</code>, find the passed value to that call that represents Argument <code>A</code> at the call location if the call has only been replaced by the call to the aggregate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- The Argument to get the passed value for. </td></tr>
    <tr><td class="paramname">Region</td><td>- The extracted Region corresponding to the outlined function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Value representing <code>A</code> at the call site. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01612">1612</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l01637">findCanonNumsForPHI()</a>.</p>

</div>
</div>
<a id="ad69884d9bf751011f8f9049542bbbd01" name="ad69884d9bf751011f8f9049542bbbd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69884d9bf751011f8f9049542bbbd01">&#9670;&#160;</a></span>getPassedArgumentInAlreadyOutlinedFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * getPassedArgumentInAlreadyOutlinedFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Argument.html">Argument</a> *</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the function call now representing the <code>Region</code>, find the passed value to that call that represents Argument <code>A</code> at the call location if the call has already been replaced with a call to the overall, aggregate function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- The Argument to get the passed value for. </td></tr>
    <tr><td class="paramname">Region</td><td>- The extracted Region corresponding to the outlined function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Value representing <code>A</code> at the call site. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01596">1596</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l01637">findCanonNumsForPHI()</a>.</p>

</div>
</div>
<a id="a8ad786f21829d9e92d31cc0b80c53dbb" name="a8ad786f21829d9e92d31cc0b80c53dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad786f21829d9e92d31cc0b80c53dbb">&#9670;&#160;</a></span>getSortedConstantKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void getSortedConstantKeys </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>SortedKeys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Map</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function to sort the keys of <code>Map</code>, which must be a mapping of constant values to basic blocks and return it in <code>SortedKeys</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SortedKeys</td><td>- The vector the keys will be return in and sorted. </td></tr>
    <tr><td class="paramname">Map</td><td>- The DenseMap containing keys to sort. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00165">165</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Casting_8h_source.html#l00565">llvm::cast()</a>, <a class="el" href="Constants_8h_source.html#l00256">llvm::ConstantInt::getLimitedValue()</a>, and <a class="el" href="STLExtras_8h_source.html#l01995">llvm::stable_sort()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02127">createAndInsertBasicBlocks()</a>.</p>

</div>
</div>
<a id="aac5cfc936b6963f4e848982328d39e8e" name="aac5cfc936b6963f4e848982328d39e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5cfc936b6963f4e848982328d39e8e">&#9670;&#160;</a></span>getSubprogramOrNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1DISubprogram.html">DISubprogram</a> * getSubprogramOrNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOutlinableGroup.html">OutlinableGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Group</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the subprogram if it exists for one of the outlined regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Group</td><td>- The set of regions to find a subprogram for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the subprogram if it exists, or nullptr. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00620">620</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="DebugInfoMetadata_8cpp_source.html#l01047">llvm::DILocalScope::getSubprogram()</a>, <a class="el" href="SampleProfWriter_8cpp_source.html#l00053">OS</a>, and <a class="el" href="IROutliner_8cpp_source.html#l00074">OutlinableGroup::Regions</a>.</p>

</div>
</div>
<a id="a9165dd298666d75ed2e5be7d5d8b50e5" name="a9165dd298666d75ed2e5be7d5d8b50e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9165dd298666d75ed2e5be7d5d8b50e5">&#9670;&#160;</a></span>mapInputsToGVNs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mapInputsToGVNs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IRSimilarity_1_1IRSimilarityCandidate.html">IRSimilarityCandidate</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>CurrentInputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputMappings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>EndInputNumbers</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the GVN for the inputs that have been found by the CodeExtractor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>- The IRSimilarityCandidate containing the region we are analyzing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CurrentInputs</td><td>- The set of inputs found by the CodeExtractor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputMappings</td><td>- The mapping of values that have been replaced by a new output value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EndInputNumbers</td><td>- The global value numbers for the extracted arguments. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00810">810</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="DenseMap_8h_source.html#l00145">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::contains()</a>, and <a class="el" href="DenseMap_8h_source.html#l00155">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::find()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l00865">getCodeExtractorArguments()</a>.</p>

</div>
</div>
<a id="a3afc8c0c69b0c55edce3be13d5b7cc32" name="a3afc8c0c69b0c55edce3be13d5b7cc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afc8c0c69b0c55edce3be13d5b7cc32">&#9670;&#160;</a></span>moveBBContents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void moveBBContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SourceBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>TargetBB</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move the contents of <code>SourceBB</code> to before the last instruction of <code>TargetBB</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceBB</td><td>- the BasicBlock to pull Instructions from. </td></tr>
    <tr><td class="paramname">TargetBB</td><td>- the BasicBlock to put Instruction into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00156">156</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="BasicBlock_8h_source.html#l00451">llvm::BasicBlock::end()</a>, and <a class="el" href="BasicBlock_8h_source.html#l00621">llvm::BasicBlock::splice()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02153">createSwitchStatement()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00375">llvm::OutlinableRegion::reattachCandidate()</a>, and <a class="el" href="LoopInterchange_8cpp_source.html#l01399">swapBBContents()</a>.</p>

</div>
</div>
<a id="a4047976de351f78967fba27df7a6361f" name="a4047976de351f78967fba27df7a6361f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4047976de351f78967fba27df7a6361f">&#9670;&#160;</a></span>moveFunctionData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void moveFunctionData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Old</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>New</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>NewEnds</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move each BasicBlock in <code>Old</code> to <code>New</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Old</td><td>- The function to move the basic blocks from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">New</td><td>- The function to move the basic blocks to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NewEnds</td><td>- The return blocks of the new overall function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00708">708</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00565">llvm::cast()</a>, <a class="el" href="namespacellvm_1_1dwarf__linker.html#a463a58e257d5f6fb2c39eb9a2474fc24ac2e06fc138163b7095fa483616a0a47a">llvm::dwarf_linker::DebugLoc</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="Casting_8h_source.html#l00759">llvm::dyn_cast_or_null()</a>, <a class="el" href="Metadata_8h_source.html#l01543">llvm::MDNode::get()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="DenseMap_8h_source.html#l00220">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::insert()</a>, <a class="el" href="Casting_8h_source.html#l00548">llvm::isa()</a>, <a class="el" href="STLExtras_8h_source.html#l00656">llvm::make_early_inc_range()</a>, and <a class="el" href="DebugInfo_8cpp_source.html#l00422">llvm::updateLoopMetadataDebugLocations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02246">fillOverallFunction()</a>.</p>

</div>
</div>
<a id="a3bc949e06e148a6d2879eb45ca164146" name="a3bc949e06e148a6d2879eb45ca164146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc949e06e148a6d2879eb45ca164146">&#9670;&#160;</a></span>nextIRInstructionDataMatchesNextInst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> nextIRInstructionDataMatchesNextInst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllvm_1_1IRSimilarity_1_1IRInstructionData.html">IRInstructionData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ID</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that the next instruction in the InstructionDataList matches the next instruction in the module. </p>
<p>If they do not, there could be the possibility that extra code has been inserted, and we must ignore it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ID</td><td>- The IRInstructionData to check the next instruction of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the InstructionDataList and actual instruction match. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l02340">2340</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Instruction_8cpp_source.html#l01164">llvm::Instruction::getNextNonDebugInstruction()</a>, and <a class="el" href="ilist__node_8h_source.html#l00032">llvm::ilist_detail::node_parent_access&lt; NodeTy, ParentTy &gt;::getParent()</a>.</p>

</div>
</div>
<a id="a84e785627d5ab55370b5fa402ad7193f" name="a84e785627d5ab55370b5fa402ad7193f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e785627d5ab55370b5fa402ad7193f">&#9670;&#160;</a></span>outputHasNonPHI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> outputHasNonPHI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>PHILoc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>PN</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *, 1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Exits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>BlocksInRegion</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code>V</code> has any uses outside of the region other than <code>PN</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>[in] - The value to check. </td></tr>
    <tr><td class="paramname">PHILoc</td><td>[in] - The location in the PHINode of <code>V</code>. </td></tr>
    <tr><td class="paramname">PN</td><td>[in] - The PHINode using <code>V</code>. </td></tr>
    <tr><td class="paramname">Exits</td><td>[in] - The potential blocks we exit to from the outlined region. </td></tr>
    <tr><td class="paramname">BlocksInRegion</td><td>[in] - The basic blocks contained in the region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>V</code> has any use soutside its region other than <code>PN</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01038">1038</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="STLExtras_8h_source.html#l01729">llvm::any_of()</a>, <a class="el" href="Instructions_8h_source.html#l02573">llvm::PHINode::getNumIncomingValues()</a>, and <a class="el" href="Sequence_8h_source.html#l00305">llvm::seq()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l01095">analyzeExitPHIsForOutputUses()</a>.</p>

</div>
</div>
<a id="a09e9f16b4a1aaf539000b95bf5442155" name="a09e9f16b4a1aaf539000b95bf5442155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e9f16b4a1aaf539000b95bf5442155">&#9670;&#160;</a></span>remapExtractedInputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void remapExtractedInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>ArgInputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputMappings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SetVector.html">SetVector</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>RemappedArgInputs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the original value for the <code>ArgInput</code> values if any one of them was replaced during a previous extraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ArgInputs</td><td>- The inputs to be extracted by the code extractor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OutputMappings</td><td>- The mapping of values that have been replaced by a new output value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RemappedArgInputs</td><td>- The remapped values according to <code>OutputMappings</code> that will be extracted. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00835">835</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="DenseMap_8h_source.html#l00145">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::contains()</a>, <a class="el" href="DenseMap_8h_source.html#l00155">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::find()</a>, and <a class="el" href="SetVector_8h_source.html#l00162">llvm::SetVector&lt; T, Vector, Set, N &gt;::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l00865">getCodeExtractorArguments()</a>.</p>

</div>
</div>
<a id="a96b5bd50d8e96b4c76ffc26508ce774d" name="a96b5bd50d8e96b4c76ffc26508ce774d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b5bd50d8e96b4c76ffc26508ce774d">&#9670;&#160;</a></span>replaceArgumentUses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void replaceArgumentUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputBBs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutputMappings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>FirstFunction</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Region</td><td>- The region of extracted code to be changed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">OutputBBs</td><td>- The BasicBlock for the output stores for this region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FirstFunction</td><td>- A flag to indicate whether we are using this function to define the overall outlined function for all the regions, or if we are operating on one of the following regions. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01803">1803</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Casting_8h_source.html#l00565">llvm::cast()</a>, <a class="el" href="RegionInfoImpl_8h_source.html#l00102">llvm::RegionBase&lt; Tr &gt;::contains()</a>, <a class="el" href="Debug_8cpp_source.html#l00163">llvm::dbgs()</a>, <a class="el" href="namespacellvm_1_1dwarf__linker.html#a463a58e257d5f6fb2c39eb9a2474fc24ac2e06fc138163b7095fa483616a0a47a">llvm::dwarf_linker::DebugLoc</a>, <a class="el" href="GenericDomTree_8h_source.html#l00617">llvm::DominatorTreeBase&lt; NodeT, IsPostDom &gt;::deleteEdge()</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="BasicBlock_8h_source.html#l00451">llvm::BasicBlock::end()</a>, <a class="el" href="DenseMap_8h_source.html#l00084">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::end()</a>, <a class="el" href="DenseMap_8h_source.html#l00155">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::find()</a>, <a class="el" href="IROutliner_8cpp_source.html#l01543">findOrCreatePHIBlock()</a>, <a class="el" href="IROutliner_8cpp_source.html#l01681">findOrCreatePHIInBlock()</a>, <a class="el" href="Function_8h_source.html#l00849">llvm::Function::getArg()</a>, <a class="el" href="GenericDomTree_8h_source.html#l00388">llvm::DominatorTreeBase&lt; NodeT, IsPostDom &gt;::getDescendants()</a>, <a class="el" href="Function_8h_source.html#l00800">llvm::Function::getEntryBlock()</a>, <a class="el" href="BasicBlock_8h_source.html#l00209">llvm::BasicBlock::getParent()</a>, <a class="el" href="ilist__node_8h_source.html#l00032">llvm::ilist_detail::node_parent_access&lt; NodeTy, ParentTy &gt;::getParent()</a>, <a class="el" href="Instructions_8h_source.html#l02881">llvm::ReturnInst::getReturnValue()</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="GenericDomTree_8h_source.html#l00599">llvm::DominatorTreeBase&lt; NodeT, IsPostDom &gt;::insertEdge()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00115">llvm::Instruction::insertInto()</a>, <a class="el" href="Casting_8h_source.html#l00548">llvm::isa()</a>, <a class="el" href="Debug_8h_source.html#l00101">LLVM_DEBUG</a>, <a class="el" href="IROutliner_8cpp_source.html#l00082">OutlinableGroup::OutlinedFunction</a>, <a class="el" href="IROutliner_8cpp_source.html#l00093">OutlinableGroup::PHIBlocks</a>, <a class="el" href="IROutliner_8cpp_source.html#l00074">OutlinableGroup::Regions</a>, <a class="el" href="Value_8cpp_source.html#l00534">llvm::Value::replaceAllUsesWith()</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00463">llvm::Instruction::setDebugLoc()</a>, <a class="el" href="User_8h_source.html#l00174">llvm::User::setOperand()</a>, <a class="el" href="SmallVector_8h_source.html#l00092">llvm::SmallVectorBase&lt; Size_T &gt;::size()</a>, and <a class="el" href="Value_8h_source.html#l00407">llvm::Value::user_back()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02246">fillOverallFunction()</a>.</p>

</div>
</div>
<a id="a7e2cad7ab18db9a3c940afc609c223dc" name="a7e2cad7ab18db9a3c940afc609c223dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2cad7ab18db9a3c940afc609c223dc">&#9670;&#160;</a></span>replaceCalledFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1CallInst.html">CallInst</a> * replaceCalledFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Module.html">Module</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the extracted function in the Region with a call to the overall function constructed from the deduplicated similar regions, replacing and remapping the values passed to the extracted function as arguments to the new arguments of the overall function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>- The module to outline from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Region</td><td>- The regions of extracted code to be replaced with a new function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a call instruction with the replaced function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01432">1432</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstrTypes_8h_source.html#l01594">llvm::CallBase::addParamAttr()</a>, <a class="el" href="InstrTypes_8h_source.html#l01408">llvm::CallBase::arg_size()</a>, <a class="el" href="Function_8h_source.html#l00864">llvm::Function::arg_size()</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="ObjCARCOpts_8cpp_source.html#l02372">Call</a>, <a class="el" href="RegionInfoImpl_8h_source.html#l00102">llvm::RegionBase&lt; Tr &gt;::contains()</a>, <a class="el" href="Instructions_8h_source.html#l01431">llvm::CallInst::Create()</a>, <a class="el" href="Debug_8cpp_source.html#l00163">llvm::dbgs()</a>, <a class="el" href="RegionInfo_8h_source.html#l00561">llvm::RegionBase&lt; Tr &gt;::end()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00092">llvm::Instruction::eraseFromParent()</a>, <a class="el" href="Constants_8cpp_source.html#l01800">llvm::ConstantPointerNull::get()</a>, <a class="el" href="Function_8h_source.html#l00849">llvm::Function::getArg()</a>, <a class="el" href="InstrTypes_8h_source.html#l01410">llvm::CallBase::getArgOperand()</a>, <a class="el" href="Function_8h_source.html#l00207">llvm::Function::getFunctionType()</a>, <a class="el" href="Type_8cpp_source.html#l00254">llvm::Type::getInt32Ty()</a>, <a class="el" href="ilist__node_8h_source.html#l00132">llvm::ilist_node_impl&lt; OptionsT &gt;::getIterator()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="Debug_8h_source.html#l00101">LLVM_DEBUG</a>, <a class="el" href="IROutliner_8cpp_source.html#l00082">OutlinableGroup::OutlinedFunction</a>, <a class="el" href="IROutliner_8cpp_source.html#l00098">OutlinableGroup::OutputGVNCombinations</a>, <a class="el" href="Value_8cpp_source.html#l00534">llvm::Value::replaceAllUsesWith()</a>, <a class="el" href="InstrTypes_8h_source.html#l01504">llvm::CallBase::setCalledFunction()</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00463">llvm::Instruction::setDebugLoc()</a>, and <a class="el" href="IROutliner_8cpp_source.html#l00135">OutlinableGroup::SwiftErrorArgument</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02246">fillOverallFunction()</a>.</p>

</div>
</div>
<a id="ace02ac07a3f704ffd345301bff92e5a8" name="ace02ac07a3f704ffd345301bff92e5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace02ac07a3f704ffd345301bff92e5a8">&#9670;&#160;</a></span>replaceConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void replaceConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllvm_1_1OutlinableRegion.html">OutlinableRegion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Region</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Within an extracted function, replace the constants that need to be lifted into arguments with the actual argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Region</td><td>[in] - The region of extracted code to be changed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l01937">1937</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Debug_8cpp_source.html#l00163">llvm::dbgs()</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="Function_8h_source.html#l00849">llvm::Function::getArg()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="Debug_8h_source.html#l00101">LLVM_DEBUG</a>, <a class="el" href="IROutliner_8cpp_source.html#l00082">OutlinableGroup::OutlinedFunction</a>, and <a class="el" href="Value_8cpp_source.html#l00542">llvm::Value::replaceUsesWithIf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02246">fillOverallFunction()</a>.</p>

</div>
</div>
<a id="a8e5c4577c64728c435eca5f4f7e163ab" name="a8e5c4577c64728c435eca5f4f7e163ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5c4577c64728c435eca5f4f7e163ab">&#9670;&#160;</a></span>replaceTargetsFromPHINode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void replaceTargetsFromPHINode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>PHIBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>Find</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>Replace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">DenseSet</a>&lt; <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Included</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite the BranchInsts in the incoming blocks to <code>PHIBlock</code> that are found in <code>Included</code> to branch to BasicBlock <code>Replace</code> if they currently branch to the BasicBlock <code>Find</code>. </p>
<p>This is used to fix up the incoming basic blocks when PHINodes are included in outlined regions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PHIBlock</td><td>- The BasicBlock containing the PHINodes that need to be checked. </td></tr>
    <tr><td class="paramname">Find</td><td>- The successor block to be replaced. </td></tr>
    <tr><td class="paramname">Replace</td><td>- The new succesor block to branch to. </td></tr>
    <tr><td class="paramname">Included</td><td>- The set of blocks about to be outlined. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="IROutliner_8cpp_source.html#l00220">220</a> of file <a class="el" href="IROutliner_8cpp_source.html">IROutliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="DenseSet_8h_source.html#l00185">llvm::detail::DenseSetImpl&lt; ValueT, MapTy, ValueInfoT &gt;::contains()</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="ELF__riscv_8cpp_source.html#l00480">End</a>, <a class="el" href="MCSubtargetInfo_8cpp_source.html#l00026">Find()</a>, <a class="el" href="Instructions_8h_source.html#l03001">llvm::BranchInst::getNumSuccessors()</a>, <a class="el" href="Instructions_8h_source.html#l03003">llvm::BranchInst::getSuccessor()</a>, <a class="el" href="BasicBlock_8h_source.html#l00507">llvm::BasicBlock::phis()</a>, and <a class="el" href="Instructions_8h_source.html#l03008">llvm::BranchInst::setSuccessor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l00375">llvm::OutlinableRegion::reattachCandidate()</a>, and <a class="el" href="IROutliner_8cpp_source.html#l00248">llvm::OutlinableRegion::splitCandidate()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a415af6f4421aa68820b3279b48acd928" name="a415af6f4421aa68820b3279b48acd928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415af6f4421aa68820b3279b48acd928">&#9670;&#160;</a></span>EnableLinkOnceODRIROutlining</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; EnableLinkOnceODRIROutlining(&quot;enable-linkonceodr-<a class="el" href="SafepointIRVerifier_8cpp.html#a3d3459f5796b9b9f0253f71d5620e958">ir</a>-outlining&quot;, cl::Hidden, <a class="el" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(&quot;Enable the <a class="el" href="Legalizer_8cpp.html#a05ab4853f7153e537774d02580e761ec">IR</a> outliner on linkonceodr functions&quot;), cl::init(false)) </td>
          <td>(</td>
          <td class="paramtype">&quot;enable-linkonceodr-<a class="el" href="SafepointIRVerifier_8cpp.html#a3d3459f5796b9b9f0253f71d5620e958">ir</a>-outlining&quot;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(&quot;Enable the <a class="el" href="Legalizer_8cpp.html#a05ab4853f7153e537774d02580e761ec">IR</a> outliner on linkonceodr functions&quot;)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(false)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l03016">llvm::IROutliner::run()</a>.</p>

</div>
</div>
<a id="a2dfbf70cabc04c37f6f46b2c312b2506" name="a2dfbf70cabc04c37f6f46b2c312b2506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfbf70cabc04c37f6f46b2c312b2506">&#9670;&#160;</a></span>NoCostModel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; NoCostModel(&quot;ir-outlining-no-cost&quot;, cl::init(false), cl::ReallyHidden, <a class="el" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(&quot;Debug option to outline greedily, without restriction that &quot; &quot;calculated benefit outweighs cost&quot;)) </td>
          <td>(</td>
          <td class="paramtype">&quot;ir-outlining-no-cost&quot;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(false)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::ReallyHidden</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(&quot;Debug option to outline greedily, without restriction that &quot; &quot;calculated benefit outweighs cost&quot;)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l03016">llvm::IROutliner::run()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Nov 1 2024 13:46:54 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
