<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: llvm::TargetInstrInfo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;19.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacellvm.html">llvm</a></li><li class="navelem"><a class="el" href="classllvm_1_1TargetInstrInfo.html">TargetInstrInfo</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classllvm_1_1TargetInstrInfo-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">llvm::TargetInstrInfo Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classllvm_1_1TargetInstrInfo.html" title="TargetInstrInfo - Interface to description of machine instruction set.">TargetInstrInfo</a> - Interface to description of machine instruction set.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="TargetInstrInfo_8h_source.html">llvm/CodeGen/TargetInstrInfo.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for llvm::TargetInstrInfo:</div>
<div class="dyncontent">
<div class="center"><img src="classllvm_1_1TargetInstrInfo__inherit__graph.png" border="0" usemap="#allvm_1_1TargetInstrInfo_inherit__map" alt="Inheritance graph"/></div>
<map name="allvm_1_1TargetInstrInfo_inherit__map" id="allvm_1_1TargetInstrInfo_inherit__map">
<area shape="rect" title="TargetInstrInfo &#45; Interface to description of machine instruction set." alt="" coords="5,79,143,105"/>
<area shape="rect" href="classllvm_1_1MCInstrInfo.html" title="Interface to description of machine instruction set." alt="" coords="13,5,135,31"/>
<area shape="poly" title=" " alt="" coords="77,46,77,79,71,79,71,46"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetInstrInfo_1_1MachineBranchPredicate.html">MachineBranchPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a predicate at the <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> level.  <a href="structllvm_1_1TargetInstrInfo_1_1MachineBranchPredicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetInstrInfo_1_1PipelinerLoopInfo.html">PipelinerLoopInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object returned by analyzeLoopForPipelining.  <a href="classllvm_1_1TargetInstrInfo_1_1PipelinerLoopInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPair.html">RegSubRegPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair composed of a register and a sub-register index.  <a href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair composed of a pair of a register and a sub-register index, and another sub-register index.  <a href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab0ea1fe6f61d0e861ed2be7632a270bb" id="r_ab0ea1fe6f61d0e861ed2be7632a270bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0ea1fe6f61d0e861ed2be7632a270bb">TargetInstrInfo</a> (<a class="el" href="classunsigned.html">unsigned</a> CFSetupOpcode=~0u, <a class="el" href="classunsigned.html">unsigned</a> CFDestroyOpcode=~0u, <a class="el" href="classunsigned.html">unsigned</a> CatchRetOpcode=~0u, <a class="el" href="classunsigned.html">unsigned</a> ReturnOpcode=~0u)</td></tr>
<tr class="separator:ab0ea1fe6f61d0e861ed2be7632a270bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc72b67ab4a799ac5472bb3ca3250fc" id="r_abfc72b67ab4a799ac5472bb3ca3250fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfc72b67ab4a799ac5472bb3ca3250fc">TargetInstrInfo</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetInstrInfo.html">TargetInstrInfo</a> &amp;)=delete</td></tr>
<tr class="separator:abfc72b67ab4a799ac5472bb3ca3250fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b4dd0611f4e9b708e1940a945581e9" id="r_a82b4dd0611f4e9b708e1940a945581e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1TargetInstrInfo.html">TargetInstrInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82b4dd0611f4e9b708e1940a945581e9">operator=</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetInstrInfo.html">TargetInstrInfo</a> &amp;)=delete</td></tr>
<tr class="separator:a82b4dd0611f4e9b708e1940a945581e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c402f5f405a15e3356949d3d1900c3" id="r_ac2c402f5f405a15e3356949d3d1900c3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2c402f5f405a15e3356949d3d1900c3">~TargetInstrInfo</a> ()</td></tr>
<tr class="separator:ac2c402f5f405a15e3356949d3d1900c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81ceec76ff4ca95f29b037c28a54ba7" id="r_af81ceec76ff4ca95f29b037c28a54ba7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterClass.html">TargetRegisterClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af81ceec76ff4ca95f29b037c28a54ba7">getRegClass</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MCInstrDesc.html">MCInstrDesc</a> &amp;MCID, <a class="el" href="classunsigned.html">unsigned</a> OpNum, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af81ceec76ff4ca95f29b037c28a54ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a machine instruction descriptor, returns the register class constraint for OpNum, or NULL.  <br /></td></tr>
<tr class="separator:af81ceec76ff4ca95f29b037c28a54ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d142d4718ca758481e0b49ad9d8ea97" id="r_a1d142d4718ca758481e0b49ad9d8ea97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d142d4718ca758481e0b49ad9d8ea97">isTriviallyReMaterializable</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a1d142d4718ca758481e0b49ad9d8ea97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the instruction is trivially rematerializable, meaning it has no side effects and requires no operands that aren't always available.  <br /></td></tr>
<tr class="separator:a1d142d4718ca758481e0b49ad9d8ea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6832cbbc9c9e128eed4484026c539781" id="r_a6832cbbc9c9e128eed4484026c539781"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6832cbbc9c9e128eed4484026c539781">isIgnorableUse</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &amp;MO) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6832cbbc9c9e128eed4484026c539781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>MO</code> is a PhysReg use return if it can be ignored for the purpose of instruction rematerialization or sinking.  <br /></td></tr>
<tr class="separator:a6832cbbc9c9e128eed4484026c539781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104cb332d459987fabfe9d7073150287" id="r_a104cb332d459987fabfe9d7073150287"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a104cb332d459987fabfe9d7073150287">isSafeToSink</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *SuccToSinkTo, <a class="el" href="namespacellvm.html#aee433bfa58b17266f2cff728e02fba26">MachineCycleInfo</a> *CI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a104cb332d459987fabfe9d7073150287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83870b05e73f275887a1e20baa621475" id="r_a83870b05e73f275887a1e20baa621475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83870b05e73f275887a1e20baa621475">getCallFrameSetupOpcode</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a83870b05e73f275887a1e20baa621475"><td class="mdescLeft">&#160;</td><td class="mdescRight">These methods return the opcode of the frame setup/destroy instructions if they exist (-1 otherwise).  <br /></td></tr>
<tr class="separator:a83870b05e73f275887a1e20baa621475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a18bb895aa0c46d5de27c4ad046aee" id="r_ab5a18bb895aa0c46d5de27c4ad046aee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5a18bb895aa0c46d5de27c4ad046aee">getCallFrameDestroyOpcode</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ab5a18bb895aa0c46d5de27c4ad046aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524001439888743cdddb9b79c45911d9" id="r_a524001439888743cdddb9b79c45911d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a524001439888743cdddb9b79c45911d9">isFrameInstr</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a524001439888743cdddb9b79c45911d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is a frame pseudo instruction.  <br /></td></tr>
<tr class="separator:a524001439888743cdddb9b79c45911d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cc48fa5e52de97bef32acbb6f76ddc" id="r_ac9cc48fa5e52de97bef32acbb6f76ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9cc48fa5e52de97bef32acbb6f76ddc">isFrameSetup</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac9cc48fa5e52de97bef32acbb6f76ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is a frame setup pseudo instruction.  <br /></td></tr>
<tr class="separator:ac9cc48fa5e52de97bef32acbb6f76ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c5ed9e614110e7cbdd8a4ab957ec06" id="r_ab5c5ed9e614110e7cbdd8a4ab957ec06"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5c5ed9e614110e7cbdd8a4ab957ec06">getFrameSize</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab5c5ed9e614110e7cbdd8a4ab957ec06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of the frame associated with the given frame instruction.  <br /></td></tr>
<tr class="separator:ab5c5ed9e614110e7cbdd8a4ab957ec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b59f9d1912a25fc5c03ae9b2ff960d" id="r_aa0b59f9d1912a25fc5c03ae9b2ff960d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0b59f9d1912a25fc5c03ae9b2ff960d">getFrameTotalSize</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa0b59f9d1912a25fc5c03ae9b2ff960d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total frame size, which is made up of the space set up inside the pair of frame start-stop instructions and the space that is set up prior to the pair.  <br /></td></tr>
<tr class="separator:aa0b59f9d1912a25fc5c03ae9b2ff960d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a831626be0c6e512d6d95246891c84" id="r_a98a831626be0c6e512d6d95246891c84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98a831626be0c6e512d6d95246891c84">getCatchReturnOpcode</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a98a831626be0c6e512d6d95246891c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6150cd07e9535b7e02d53953a1a54cdb" id="r_a6150cd07e9535b7e02d53953a1a54cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6150cd07e9535b7e02d53953a1a54cdb">getReturnOpcode</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a6150cd07e9535b7e02d53953a1a54cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4f8b28a8543924e7e3e566a847e691" id="r_a1e4f8b28a8543924e7e3e566a847e691"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e4f8b28a8543924e7e3e566a847e691">getSPAdjust</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a1e4f8b28a8543924e7e3e566a847e691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual stack pointer adjustment made by an instruction as part of a call sequence.  <br /></td></tr>
<tr class="separator:a1e4f8b28a8543924e7e3e566a847e691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236fc00ef404f232dcd8b88bbf3a2251" id="r_a236fc00ef404f232dcd8b88bbf3a2251"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a236fc00ef404f232dcd8b88bbf3a2251">isCoalescableExtInstr</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> &amp;SrcReg, <a class="el" href="classllvm_1_1Register.html">Register</a> &amp;DstReg, <a class="el" href="classunsigned.html">unsigned</a> &amp;SubIdx) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a236fc00ef404f232dcd8b88bbf3a2251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the instruction is a "coalescable" extension instruction.  <br /></td></tr>
<tr class="separator:a236fc00ef404f232dcd8b88bbf3a2251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6922ec50633977be02ab221c2de2adc1" id="r_a6922ec50633977be02ab221c2de2adc1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1Register.html">Register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6922ec50633977be02ab221c2de2adc1">isLoadFromStackSlot</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, int &amp;FrameIndex) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6922ec50633977be02ab221c2de2adc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified machine instruction is a direct load from a stack slot, return the virtual or physical register number of the destination along with the FrameIndex of the loaded stack slot.  <br /></td></tr>
<tr class="separator:a6922ec50633977be02ab221c2de2adc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb62c4d3c76506ef7a31dc75f98000db" id="r_afb62c4d3c76506ef7a31dc75f98000db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1Register.html">Register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb62c4d3c76506ef7a31dc75f98000db">isLoadFromStackSlot</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, int &amp;FrameIndex, <a class="el" href="classunsigned.html">unsigned</a> &amp;MemBytes) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:afb62c4d3c76506ef7a31dc75f98000db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional extension of isLoadFromStackSlot that returns the number of bytes loaded from the stack.  <br /></td></tr>
<tr class="separator:afb62c4d3c76506ef7a31dc75f98000db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dad862e186c4263edb6f7583754efcc" id="r_a8dad862e186c4263edb6f7583754efcc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1Register.html">Register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dad862e186c4263edb6f7583754efcc">isLoadFromStackSlotPostFE</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, int &amp;FrameIndex) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a8dad862e186c4263edb6f7583754efcc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> for post-frame ptr elimination stack locations as well.  <br /></td></tr>
<tr class="separator:a8dad862e186c4263edb6f7583754efcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c237cad94f54f0d82a18a131709d41" id="r_ae3c237cad94f54f0d82a18a131709d41"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3c237cad94f54f0d82a18a131709d41">hasLoadFromStackSlot</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineMemOperand.html">MachineMemOperand</a> * &gt; &amp;Accesses) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae3c237cad94f54f0d82a18a131709d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified machine instruction has a load from a stack slot, return true along with the FrameIndices of the loaded stack slot and the machine mem operands containing the reference.  <br /></td></tr>
<tr class="separator:ae3c237cad94f54f0d82a18a131709d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa095ffe13f7029e833f37e346f5fa5b0" id="r_aa095ffe13f7029e833f37e346f5fa5b0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1Register.html">Register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa095ffe13f7029e833f37e346f5fa5b0">isStoreToStackSlot</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, int &amp;FrameIndex) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa095ffe13f7029e833f37e346f5fa5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified machine instruction is a direct store to a stack slot, return the virtual or physical register number of the source reg along with the FrameIndex of the loaded stack slot.  <br /></td></tr>
<tr class="separator:aa095ffe13f7029e833f37e346f5fa5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a5b1227d7622151c06029e84d67ade" id="r_af4a5b1227d7622151c06029e84d67ade"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1Register.html">Register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4a5b1227d7622151c06029e84d67ade">isStoreToStackSlot</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, int &amp;FrameIndex, <a class="el" href="classunsigned.html">unsigned</a> &amp;MemBytes) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af4a5b1227d7622151c06029e84d67ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional extension of isStoreToStackSlot that returns the number of bytes stored to the stack.  <br /></td></tr>
<tr class="separator:af4a5b1227d7622151c06029e84d67ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4598ec7bb2753593259420bff01427" id="r_a8d4598ec7bb2753593259420bff01427"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1Register.html">Register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d4598ec7bb2753593259420bff01427">isStoreToStackSlotPostFE</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, int &amp;FrameIndex) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a8d4598ec7bb2753593259420bff01427"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> for post-frame ptr elimination stack locations as well.  <br /></td></tr>
<tr class="separator:a8d4598ec7bb2753593259420bff01427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df2834716ee814af9f2555897ecb932" id="r_a5df2834716ee814af9f2555897ecb932"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5df2834716ee814af9f2555897ecb932">hasStoreToStackSlot</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineMemOperand.html">MachineMemOperand</a> * &gt; &amp;Accesses) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5df2834716ee814af9f2555897ecb932"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified machine instruction has a store to a stack slot, return true along with the FrameIndices of the loaded stack slot and the machine mem operands containing the reference.  <br /></td></tr>
<tr class="separator:a5df2834716ee814af9f2555897ecb932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51770f677efd652c55498dc472bec14" id="r_aa51770f677efd652c55498dc472bec14"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa51770f677efd652c55498dc472bec14">isStackSlotCopy</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, int &amp;DestFrameIndex, int &amp;SrcFrameIndex) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa51770f677efd652c55498dc472bec14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified machine instruction is a copy of one stack slot to another and has no other effect.  <br /></td></tr>
<tr class="separator:aa51770f677efd652c55498dc472bec14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf58df95b00905950bdfee515cd5e9d" id="r_a5cf58df95b00905950bdfee515cd5e9d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cf58df95b00905950bdfee515cd5e9d">getStackSlotRange</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterClass.html">TargetRegisterClass</a> *RC, <a class="el" href="classunsigned.html">unsigned</a> SubIdx, <a class="el" href="classunsigned.html">unsigned</a> &amp;<a class="el" href="ELFObjHandler_8cpp.html#af1557b042f2005cd730068528cfad1d2">Size</a>, <a class="el" href="classunsigned.html">unsigned</a> &amp;<a class="el" href="namespacellvm.html#a05f5b9a11bdcc5feba62899f95dcf878a3134224cba2545bc57954d3b072aebb4">Offset</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5cf58df95b00905950bdfee515cd5e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size in bytes and offset within a stack slot of a spilled register or subregister.  <br /></td></tr>
<tr class="separator:a5cf58df95b00905950bdfee515cd5e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdf5a92f1195b3543b9412758c58106" id="r_a4bdf5a92f1195b3543b9412758c58106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bdf5a92f1195b3543b9412758c58106">isUnspillableTerminator</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a4bdf5a92f1195b3543b9412758c58106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given instruction is terminator that is unspillable, according to isUnspillableTerminatorImpl.  <br /></td></tr>
<tr class="separator:a4bdf5a92f1195b3543b9412758c58106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c95e145de31fbd3c6269ebe1b615f7" id="r_ad5c95e145de31fbd3c6269ebe1b615f7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5c95e145de31fbd3c6269ebe1b615f7">getInstSizeInBytes</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad5c95e145de31fbd3c6269ebe1b615f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the specified <a class="el" href="classllvm_1_1MachineInstr.html" title="Representation of each machine instruction.">MachineInstr</a>, or ~0U when this function is not implemented by a target.  <br /></td></tr>
<tr class="separator:ad5c95e145de31fbd3c6269ebe1b615f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5e9ccab2a323465af64b3661172af2" id="r_a9c5e9ccab2a323465af64b3661172af2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c5e9ccab2a323465af64b3661172af2">isAsCheapAsAMove</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a9c5e9ccab2a323465af64b3661172af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the instruction is as cheap as a move instruction.  <br /></td></tr>
<tr class="separator:a9c5e9ccab2a323465af64b3661172af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b2151fcd1d9e2cec1689aec6e5ed8a" id="r_ad9b2151fcd1d9e2cec1689aec6e5ed8a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9b2151fcd1d9e2cec1689aec6e5ed8a">shouldSink</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad9b2151fcd1d9e2cec1689aec6e5ed8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the instruction should be sunk by MachineSink.  <br /></td></tr>
<tr class="separator:ad9b2151fcd1d9e2cec1689aec6e5ed8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc848c0953b9a49b09c0ef3a577a34f" id="r_aefc848c0953b9a49b09c0ef3a577a34f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefc848c0953b9a49b09c0ef3a577a34f">shouldHoist</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineLoop.html">MachineLoop</a> *FromLoop) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aefc848c0953b9a49b09c0ef3a577a34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return false if the instruction should not be hoisted by MachineLICM.  <br /></td></tr>
<tr class="separator:aefc848c0953b9a49b09c0ef3a577a34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcfe8906a95ad57f3f7a7d433f47204" id="r_aadcfe8906a95ad57f3f7a7d433f47204"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadcfe8906a95ad57f3f7a7d433f47204">reMaterialize</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> <a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> DestReg, <a class="el" href="classunsigned.html">unsigned</a> SubIdx, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Orig, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> &amp;<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aadcfe8906a95ad57f3f7a7d433f47204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-issue the specified 'original' instruction at the specific location targeting a new destination register.  <br /></td></tr>
<tr class="separator:aadcfe8906a95ad57f3f7a7d433f47204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5210bd68a86582390a6fbf1f57e319" id="r_a8d5210bd68a86582390a6fbf1f57e319"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d5210bd68a86582390a6fbf1f57e319">duplicate</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> InsertBefore, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Orig) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a8d5210bd68a86582390a6fbf1f57e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones instruction or the whole instruction bundle <code>Orig</code> and insert into <code>MBB</code> before <code>InsertBefore</code>.  <br /></td></tr>
<tr class="separator:a8d5210bd68a86582390a6fbf1f57e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0a8cb9a764d058a63b77d50e9c0787" id="r_ada0a8cb9a764d058a63b77d50e9c0787"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada0a8cb9a764d058a63b77d50e9c0787">convertToThreeAddress</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1LiveVariables.html">LiveVariables</a> *LV, <a class="el" href="classllvm_1_1LiveIntervals.html">LiveIntervals</a> *LIS) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ada0a8cb9a764d058a63b77d50e9c0787"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be implemented by targets that set the M_CONVERTIBLE_TO_3_ADDR flag.  <br /></td></tr>
<tr class="separator:ada0a8cb9a764d058a63b77d50e9c0787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41720cc33b0511709c92abcb164a59d" id="r_aa41720cc33b0511709c92abcb164a59d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa41720cc33b0511709c92abcb164a59d">commuteInstruction</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classbool.html">bool</a> NewMI=false, <a class="el" href="classunsigned.html">unsigned</a> OpIdx1=<a class="el" href="#ae73e2be2b66dc9e4f2f90d56076d7ea9">CommuteAnyOperandIndex</a>, <a class="el" href="classunsigned.html">unsigned</a> OpIdx2=<a class="el" href="#ae73e2be2b66dc9e4f2f90d56076d7ea9">CommuteAnyOperandIndex</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa41720cc33b0511709c92abcb164a59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method commutes the operands of the given machine instruction MI.  <br /></td></tr>
<tr class="separator:aa41720cc33b0511709c92abcb164a59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422b844cc7e3db360908c008cb651f96" id="r_a422b844cc7e3db360908c008cb651f96"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a422b844cc7e3db360908c008cb651f96">findCommutedOpIndices</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> &amp;SrcOpIdx1, <a class="el" href="classunsigned.html">unsigned</a> &amp;SrcOpIdx2) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a422b844cc7e3db360908c008cb651f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the routine could find two commutable operands in the given machine instruction.  <br /></td></tr>
<tr class="separator:a422b844cc7e3db360908c008cb651f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae698a81cf1a8b23582f2964f57581dc2" id="r_ae698a81cf1a8b23582f2964f57581dc2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae698a81cf1a8b23582f2964f57581dc2">hasCommutePreference</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classbool.html">bool</a> &amp;Commute) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae698a81cf1a8b23582f2964f57581dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the target has a preference on the operands order of the given machine instruction.  <br /></td></tr>
<tr class="separator:ae698a81cf1a8b23582f2964f57581dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26cac7943070f09b4d7fa667d1adf95" id="r_ae26cac7943070f09b4d7fa667d1adf95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae26cac7943070f09b4d7fa667d1adf95">getRegSequenceInputs</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> DefIdx, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &gt; &amp;InputRegs) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae26cac7943070f09b4d7fa667d1adf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the equivalent inputs of a REG_SEQUENCE for the given <code>MI</code> and <code>DefIdx</code>.  <br /></td></tr>
<tr class="separator:ae26cac7943070f09b4d7fa667d1adf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1743a67877bf4ba56d53b235d3573e0" id="r_af1743a67877bf4ba56d53b235d3573e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1743a67877bf4ba56d53b235d3573e0">getExtractSubregInputs</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> DefIdx, <a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &amp;InputReg) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af1743a67877bf4ba56d53b235d3573e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the equivalent inputs of a EXTRACT_SUBREG for the given <code>MI</code> and <code>DefIdx</code>.  <br /></td></tr>
<tr class="separator:af1743a67877bf4ba56d53b235d3573e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea536f043de7994bc9b67c634a7c879" id="r_abea536f043de7994bc9b67c634a7c879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abea536f043de7994bc9b67c634a7c879">getInsertSubregInputs</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> DefIdx, <a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPair.html">RegSubRegPair</a> &amp;BaseReg, <a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &amp;InsertedReg) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:abea536f043de7994bc9b67c634a7c879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the equivalent inputs of a INSERT_SUBREG for the given <code>MI</code> and <code>DefIdx</code>.  <br /></td></tr>
<tr class="separator:abea536f043de7994bc9b67c634a7c879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66abaa28810e0bb35ab77012a3ea997" id="r_ac66abaa28810e0bb35ab77012a3ea997"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac66abaa28810e0bb35ab77012a3ea997">produceSameValue</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;MI0, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;MI1, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> *<a class="el" href="AArch64AdvSIMDScalarPass_8cpp.html#aacd2ab195054a3e6a74bfbb9d5d571c8">MRI</a>=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac66abaa28810e0bb35ab77012a3ea997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two machine instructions would produce identical values.  <br /></td></tr>
<tr class="separator:ac66abaa28810e0bb35ab77012a3ea997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6073542a939859dd8831f4cf9d710393" id="r_a6073542a939859dd8831f4cf9d710393"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6073542a939859dd8831f4cf9d710393">isBranchOffsetInRange</a> (<a class="el" href="classunsigned.html">unsigned</a> BranchOpc, int64_t BrOffset) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a6073542a939859dd8831f4cf9d710393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ab946af55bc208ded5c21c11ff71c2" id="r_ab8ab946af55bc208ded5c21c11ff71c2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ab946af55bc208ded5c21c11ff71c2">getBranchDestBlock</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ab8ab946af55bc208ded5c21c11ff71c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b07e0819e160f78c33a67838dea35c" id="r_a25b07e0819e160f78c33a67838dea35c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25b07e0819e160f78c33a67838dea35c">insertIndirectBranch</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;NewDestBB, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;RestoreBB, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#ad467c4ab9119043f9b7750ab986be61a">DL</a>, int64_t BrOffset=0, <a class="el" href="classllvm_1_1RegScavenger.html">RegScavenger</a> *RS=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a25b07e0819e160f78c33a67838dea35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an unconditional indirect branch at the end of <code>MBB</code> to <code>NewDestBB</code>.  <br /></td></tr>
<tr class="separator:a25b07e0819e160f78c33a67838dea35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfb0c744373d4b6112eb343a5b07fc7" id="r_a0dfb0c744373d4b6112eb343a5b07fc7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dfb0c744373d4b6112eb343a5b07fc7">analyzeBranch</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *&amp;<a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a1441f79530bc7f3a89118bb8067eac69">TBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *&amp;FBB, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;<a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>, <a class="el" href="classbool.html">bool</a> AllowModify=false) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0dfb0c744373d4b6112eb343a5b07fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the branching code at the end of MBB, returning true if it cannot be understood (e.g.  <br /></td></tr>
<tr class="separator:a0dfb0c744373d4b6112eb343a5b07fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3f813a206819029043906eedccc502" id="r_a2b3f813a206819029043906eedccc502"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b3f813a206819029043906eedccc502">analyzeBranchPredicate</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="structllvm_1_1TargetInstrInfo_1_1MachineBranchPredicate.html">MachineBranchPredicate</a> &amp;MBP, <a class="el" href="classbool.html">bool</a> AllowModify=false) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a2b3f813a206819029043906eedccc502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the branching code at the end of MBB and parse it into the <a class="el" href="structllvm_1_1TargetInstrInfo_1_1MachineBranchPredicate.html" title="Represents a predicate at the MachineFunction level.">MachineBranchPredicate</a> structure if possible.  <br /></td></tr>
<tr class="separator:a2b3f813a206819029043906eedccc502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0317b8d1d0eb9aaf9af9d636f5f66e8d" id="r_a0317b8d1d0eb9aaf9af9d636f5f66e8d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0317b8d1d0eb9aaf9af9d636f5f66e8d">removeBranch</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, int *BytesRemoved=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0317b8d1d0eb9aaf9af9d636f5f66e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the branching code at the end of the specific MBB.  <br /></td></tr>
<tr class="separator:a0317b8d1d0eb9aaf9af9d636f5f66e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762db1f75e789783b689f22cda71bad4" id="r_a762db1f75e789783b689f22cda71bad4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a762db1f75e789783b689f22cda71bad4">insertBranch</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *<a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a1441f79530bc7f3a89118bb8067eac69">TBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *FBB, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; <a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#ad467c4ab9119043f9b7750ab986be61a">DL</a>, int *BytesAdded=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a762db1f75e789783b689f22cda71bad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert branch code into the end of the specified <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a>.  <br /></td></tr>
<tr class="separator:a762db1f75e789783b689f22cda71bad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af382bec94f69d7c5fba1e67e62e6e6da" id="r_af382bec94f69d7c5fba1e67e62e6e6da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af382bec94f69d7c5fba1e67e62e6e6da">insertUnconditionalBranch</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *DestBB, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#ad467c4ab9119043f9b7750ab986be61a">DL</a>, int *BytesAdded=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:af382bec94f69d7c5fba1e67e62e6e6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047bd8fdcc19cf2047e947ca565ff8fc" id="r_a047bd8fdcc19cf2047e947ca565ff8fc"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classllvm_1_1TargetInstrInfo_1_1PipelinerLoopInfo.html">PipelinerLoopInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a047bd8fdcc19cf2047e947ca565ff8fc">analyzeLoopForPipelining</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *LoopBB) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a047bd8fdcc19cf2047e947ca565ff8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze loop L, which must be a single-basic-block loop, and if the conditions can be understood enough produce a <a class="el" href="classllvm_1_1TargetInstrInfo_1_1PipelinerLoopInfo.html" title="Object returned by analyzeLoopForPipelining.">PipelinerLoopInfo</a> object.  <br /></td></tr>
<tr class="separator:a047bd8fdcc19cf2047e947ca565ff8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951ed5729e865521d99c1b7bf2e4e4a2" id="r_a951ed5729e865521d99c1b7bf2e4e4a2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a951ed5729e865521d99c1b7bf2e4e4a2">analyzeLoop</a> (<a class="el" href="classllvm_1_1MachineLoop.html">MachineLoop</a> &amp;L, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&amp;IndVarInst, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&amp;<a class="el" href="classllvm_1_1CmpInst.html">CmpInst</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a951ed5729e865521d99c1b7bf2e4e4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the loop code, return true if it cannot be understood.  <br /></td></tr>
<tr class="separator:a951ed5729e865521d99c1b7bf2e4e4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18927162b9131e79e1ee778c7ae4a4e2" id="r_a18927162b9131e79e1ee778c7ae4a4e2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18927162b9131e79e1ee778c7ae4a4e2">reduceLoopCount</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;PreHeader, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *IndVar, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Cmp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;<a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;PrevInsts, <a class="el" href="classunsigned.html">unsigned</a> Iter, <a class="el" href="classunsigned.html">unsigned</a> MaxIter) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a18927162b9131e79e1ee778c7ae4a4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate code to reduce the loop iteration by one and check if the loop is finished.  <br /></td></tr>
<tr class="separator:a18927162b9131e79e1ee778c7ae4a4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e9655e762686aff18772a15139df27" id="r_a26e9655e762686aff18772a15139df27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e9655e762686aff18772a15139df27">ReplaceTailWithBranchTo</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> <a class="el" href="namespacellvm_1_1CallingConv.html#ab5129f11389b3bfacaf2971bc558a90bad6e9c0ff694f0fca0222e79e772b647e">Tail</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *NewDest) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a26e9655e762686aff18772a15139df27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the instruction OldInst and everything after it, replacing it with an unconditional branch to NewDest.  <br /></td></tr>
<tr class="separator:a26e9655e762686aff18772a15139df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8e907121203db549a15f70f615ef50" id="r_afa8e907121203db549a15f70f615ef50"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa8e907121203db549a15f70f615ef50">isLegalToSplitMBBAt</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> <a class="el" href="ARMSLSHardening_8cpp.html#ad5f691fdc1a09aaf6df5fef958b35a3d">MBBI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:afa8e907121203db549a15f70f615ef50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it's legal to split the given basic block at the specified instruction (i.e.  <br /></td></tr>
<tr class="separator:afa8e907121203db549a15f70f615ef50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b5a36b4d498deae0da42cab63b6b65" id="r_a00b5a36b4d498deae0da42cab63b6b65"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00b5a36b4d498deae0da42cab63b6b65">isProfitableToIfCvt</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classunsigned.html">unsigned</a> NumCycles, <a class="el" href="classunsigned.html">unsigned</a> ExtraPredCycles, <a class="el" href="classllvm_1_1BranchProbability.html">BranchProbability</a> Probability) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a00b5a36b4d498deae0da42cab63b6b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it's profitable to predicate instructions with accumulated instruction latency of "NumCycles" of the specified basic block, where the probability of the instructions being executed is given by Probability, and Confidence is a measure of our confidence that it will be properly predicted.  <br /></td></tr>
<tr class="separator:a00b5a36b4d498deae0da42cab63b6b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558a9e2bb84251c5a3dc6fbc2abf6b62" id="r_a558a9e2bb84251c5a3dc6fbc2abf6b62"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a558a9e2bb84251c5a3dc6fbc2abf6b62">isProfitableToIfCvt</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;TMBB, <a class="el" href="classunsigned.html">unsigned</a> NumTCycles, <a class="el" href="classunsigned.html">unsigned</a> ExtraTCycles, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;FMBB, <a class="el" href="classunsigned.html">unsigned</a> NumFCycles, <a class="el" href="classunsigned.html">unsigned</a> ExtraFCycles, <a class="el" href="classllvm_1_1BranchProbability.html">BranchProbability</a> Probability) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a558a9e2bb84251c5a3dc6fbc2abf6b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second variant of isProfitableToIfCvt.  <br /></td></tr>
<tr class="separator:a558a9e2bb84251c5a3dc6fbc2abf6b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5db14e4eee47b5fb139bf333d7f1516" id="r_ad5db14e4eee47b5fb139bf333d7f1516"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5db14e4eee47b5fb139bf333d7f1516">isProfitableToDupForIfCvt</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classunsigned.html">unsigned</a> NumCycles, <a class="el" href="classllvm_1_1BranchProbability.html">BranchProbability</a> Probability) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad5db14e4eee47b5fb139bf333d7f1516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it's profitable for if-converter to duplicate instructions of specified accumulated instruction latencies in the specified MBB to enable if-conversion.  <br /></td></tr>
<tr class="separator:ad5db14e4eee47b5fb139bf333d7f1516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1d5ead030ed9216dedce5a9cc304ec" id="r_acc1d5ead030ed9216dedce5a9cc304ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc1d5ead030ed9216dedce5a9cc304ec">extraSizeToPredicateInstructions</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF, <a class="el" href="classunsigned.html">unsigned</a> NumInsts) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:acc1d5ead030ed9216dedce5a9cc304ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the increase in code size needed to predicate a contiguous run of NumInsts instructions.  <br /></td></tr>
<tr class="separator:acc1d5ead030ed9216dedce5a9cc304ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eb74bb20ce93168ed6fc663d997c30" id="r_ac0eb74bb20ce93168ed6fc663d997c30"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0eb74bb20ce93168ed6fc663d997c30">predictBranchSizeForIfCvt</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac0eb74bb20ce93168ed6fc663d997c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an estimate for the code size reduction (in bytes) which will be caused by removing the given branch instruction during if-conversion.  <br /></td></tr>
<tr class="separator:ac0eb74bb20ce93168ed6fc663d997c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c46c756d842143ad24a09a2723be290" id="r_a4c46c756d842143ad24a09a2723be290"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c46c756d842143ad24a09a2723be290">isProfitableToUnpredicate</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;TMBB, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;FMBB) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a4c46c756d842143ad24a09a2723be290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it's profitable to unpredicate one side of a 'diamond', i.e.  <br /></td></tr>
<tr class="separator:a4c46c756d842143ad24a09a2723be290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0990ac346653cb1c820f391ffbf5ed5" id="r_ae0990ac346653cb1c820f391ffbf5ed5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0990ac346653cb1c820f391ffbf5ed5">canInsertSelect</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; <a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> DstReg, <a class="el" href="classllvm_1_1Register.html">Register</a> TrueReg, <a class="el" href="classllvm_1_1Register.html">Register</a> FalseReg, int &amp;CondCycles, int &amp;TrueCycles, int &amp;FalseCycles) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae0990ac346653cb1c820f391ffbf5ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is possible to insert a select instruction that chooses between TrueReg and FalseReg based on the condition code in Cond.  <br /></td></tr>
<tr class="separator:ae0990ac346653cb1c820f391ffbf5ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cd943142f3f93cebdab2134714793b" id="r_a57cd943142f3f93cebdab2134714793b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57cd943142f3f93cebdab2134714793b">insertSelect</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> <a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#ad467c4ab9119043f9b7750ab986be61a">DL</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> DstReg, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; <a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> TrueReg, <a class="el" href="classllvm_1_1Register.html">Register</a> FalseReg) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a57cd943142f3f93cebdab2134714793b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a select instruction into MBB before I that will copy TrueReg to DstReg when Cond is true, and FalseReg to DstReg when Cond is false.  <br /></td></tr>
<tr class="separator:a57cd943142f3f93cebdab2134714793b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e13c52b664b67847a458ba5e6f9009" id="r_ad0e13c52b664b67847a458ba5e6f9009"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0e13c52b664b67847a458ba5e6f9009">analyzeSelect</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;<a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>, <a class="el" href="classunsigned.html">unsigned</a> &amp;TrueOp, <a class="el" href="classunsigned.html">unsigned</a> &amp;FalseOp, <a class="el" href="classbool.html">bool</a> &amp;Optimizable) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad0e13c52b664b67847a458ba5e6f9009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the given select instruction, returning true if it cannot be understood.  <br /></td></tr>
<tr class="separator:ad0e13c52b664b67847a458ba5e6f9009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b099a7de1dfef1561ec6f7df09da47" id="r_a31b099a7de1dfef1561ec6f7df09da47"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31b099a7de1dfef1561ec6f7df09da47">optimizeSelect</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;NewMIs, <a class="el" href="classbool.html">bool</a> PreferFalse=false) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a31b099a7de1dfef1561ec6f7df09da47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a select instruction that was understood by analyzeSelect and returned Optimizable = true, attempt to optimize MI by merging it with one of its operands.  <br /></td></tr>
<tr class="separator:a31b099a7de1dfef1561ec6f7df09da47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3084582ccac0f7bfb05582b5be402f" id="r_a5e3084582ccac0f7bfb05582b5be402f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e3084582ccac0f7bfb05582b5be402f">copyPhysReg</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> <a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#ad467c4ab9119043f9b7750ab986be61a">DL</a>, <a class="el" href="classllvm_1_1MCRegister.html">MCRegister</a> DestReg, <a class="el" href="classllvm_1_1MCRegister.html">MCRegister</a> SrcReg, <a class="el" href="classbool.html">bool</a> KillSrc) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5e3084582ccac0f7bfb05582b5be402f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit instructions to copy a pair of physical registers.  <br /></td></tr>
<tr class="separator:a5e3084582ccac0f7bfb05582b5be402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccc261e5cc19c2d41a1ab9fb361cde8" id="r_aaccc261e5cc19c2d41a1ab9fb361cde8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaccc261e5cc19c2d41a1ab9fb361cde8">isPCRelRegisterOperandLegal</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &amp;MO) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aaccc261e5cc19c2d41a1ab9fb361cde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow targets to tell MachineVerifier whether a specific register <a class="el" href="classllvm_1_1MachineOperand.html" title="MachineOperand class - Representation of each machine instruction operand.">MachineOperand</a> can be used as part of PC-relative addressing.  <br /></td></tr>
<tr class="separator:aaccc261e5cc19c2d41a1ab9fb361cde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67b6d0847ff336198e7b56ecf022a3a" id="r_aa67b6d0847ff336198e7b56ecf022a3a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa67b6d0847ff336198e7b56ecf022a3a">getJumpTableIndex</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa67b6d0847ff336198e7b56ecf022a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an index for <a class="el" href="classllvm_1_1MachineJumpTableInfo.html">MachineJumpTableInfo</a> if <code>insn</code> is an indirect jump using a jump table, otherwise -1.  <br /></td></tr>
<tr class="separator:aa67b6d0847ff336198e7b56ecf022a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5bb5eb8d13b5726f90e7f38df45d60" id="r_ace5bb5eb8d13b5726f90e7f38df45d60"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structllvm_1_1DestSourcePair.html">DestSourcePair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace5bb5eb8d13b5726f90e7f38df45d60">isCopyInstr</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ace5bb5eb8d13b5726f90e7f38df45d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specific machine instruction is a instruction that moves/copies value from one register to another register return destination and source registers as machine operands.  <br /></td></tr>
<tr class="separator:ace5bb5eb8d13b5726f90e7f38df45d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dd4c26bf1be527376323f5c9889fbd" id="r_a82dd4c26bf1be527376323f5c9889fbd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structllvm_1_1DestSourcePair.html">DestSourcePair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82dd4c26bf1be527376323f5c9889fbd">isCopyLikeInstr</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a82dd4c26bf1be527376323f5c9889fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407338aee0ea958defdef5cb3993f1da" id="r_a407338aee0ea958defdef5cb3993f1da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a407338aee0ea958defdef5cb3993f1da">isFullCopyInstr</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a407338aee0ea958defdef5cb3993f1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ac5c3f21740cf8f3f63e50de016209" id="r_ae4ac5c3f21740cf8f3f63e50de016209"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="structllvm_1_1RegImmPair.html">RegImmPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4ac5c3f21740cf8f3f63e50de016209">isAddImmediate</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> <a class="el" href="MachineSink_8cpp.html#a359e1ff26f6d466d927a61aae45b05c3">Reg</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae4ac5c3f21740cf8f3f63e50de016209"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specific machine instruction is an instruction that adds an immediate value and a register, and stores the result in the given register <code>Reg</code>, return a pair of the source register and the offset which has been added.  <br /></td></tr>
<tr class="separator:ae4ac5c3f21740cf8f3f63e50de016209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820eea71d5b67cf63757e49e3c55736d" id="r_a820eea71d5b67cf63757e49e3c55736d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a820eea71d5b67cf63757e49e3c55736d">getConstValDefinedInReg</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Register.html">Register</a> <a class="el" href="MachineSink_8cpp.html#a359e1ff26f6d466d927a61aae45b05c3">Reg</a>, int64_t &amp;ImmVal) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a820eea71d5b67cf63757e49e3c55736d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if MI is an instruction that defines Reg to have a constant value and the value is recorded in ImmVal.  <br /></td></tr>
<tr class="separator:a820eea71d5b67cf63757e49e3c55736d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417192487f0e7d3a21af7c885de3152c" id="r_a417192487f0e7d3a21af7c885de3152c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a417192487f0e7d3a21af7c885de3152c">storeRegToStackSlot</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> <a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> SrcReg, <a class="el" href="classbool.html">bool</a> isKill, int FrameIndex, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterClass.html">TargetRegisterClass</a> *RC, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> VReg) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a417192487f0e7d3a21af7c885de3152c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the specified register of the given register class to the specified stack frame index.  <br /></td></tr>
<tr class="separator:a417192487f0e7d3a21af7c885de3152c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f37a2dbf11ae8af68936b0eeca620f6" id="r_a1f37a2dbf11ae8af68936b0eeca620f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f37a2dbf11ae8af68936b0eeca620f6">loadRegFromStackSlot</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> <a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> DestReg, int FrameIndex, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterClass.html">TargetRegisterClass</a> *RC, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> VReg) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a1f37a2dbf11ae8af68936b0eeca620f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the specified register of the given register class from the specified stack frame index.  <br /></td></tr>
<tr class="separator:a1f37a2dbf11ae8af68936b0eeca620f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb52dce7ed6b6e3abc562031782d77d" id="r_aeeb52dce7ed6b6e3abc562031782d77d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeeb52dce7ed6b6e3abc562031782d77d">expandPostRAPseudo</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aeeb52dce7ed6b6e3abc562031782d77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called for all pseudo instructions that remain after register allocation.  <br /></td></tr>
<tr class="separator:aeeb52dce7ed6b6e3abc562031782d77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838a9048864ddaea932c974de0e8ce1a" id="r_a838a9048864ddaea932c974de0e8ce1a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838a9048864ddaea932c974de0e8ce1a">isSubregFoldable</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a838a9048864ddaea932c974de0e8ce1a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> whether the target can fold a load that feeds a subreg operand (or a subreg operand that feeds a store).  <br /></td></tr>
<tr class="separator:a838a9048864ddaea932c974de0e8ce1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a028c45f323009b51ef27c5f5814a2" id="r_a34a028c45f323009b51ef27c5f5814a2"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34a028c45f323009b51ef27c5f5814a2">getPatchpointUnfoldableRange</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a34a028c45f323009b51ef27c5f5814a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a patchpoint, stackmap, or statepoint intrinsic, return the range of operands which can't be folded into stack references.  <br /></td></tr>
<tr class="separator:a34a028c45f323009b51ef27c5f5814a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a733ae5364b0de2225af33223f383a5" id="r_a6a733ae5364b0de2225af33223f383a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a733ae5364b0de2225af33223f383a5">foldMemoryOperand</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; Ops, int FI, <a class="el" href="classllvm_1_1LiveIntervals.html">LiveIntervals</a> *LIS=nullptr, <a class="el" href="classllvm_1_1VirtRegMap.html">VirtRegMap</a> *VRM=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6a733ae5364b0de2225af33223f383a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to fold a load or store of the specified stack slot into the specified machine instruction for the specified operand(s).  <br /></td></tr>
<tr class="separator:a6a733ae5364b0de2225af33223f383a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2432d0bb09d9fe3b6bb004d8dbf77a99" id="r_a2432d0bb09d9fe3b6bb004d8dbf77a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2432d0bb09d9fe3b6bb004d8dbf77a99">foldMemoryOperand</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; Ops, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;LoadMI, <a class="el" href="classllvm_1_1LiveIntervals.html">LiveIntervals</a> *LIS=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a2432d0bb09d9fe3b6bb004d8dbf77a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the previous version except it allows folding of any load and store from / to any address, not just from a specific stack slot.  <br /></td></tr>
<tr class="separator:a2432d0bb09d9fe3b6bb004d8dbf77a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b7b9c491045c788173e83be1ba5d2b" id="r_a68b7b9c491045c788173e83be1ba5d2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68b7b9c491045c788173e83be1ba5d2b">lowerCopy</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a68b7b9c491045c788173e83be1ba5d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function defines the logic to lower COPY instruction to target specific instruction(s).  <br /></td></tr>
<tr class="separator:a68b7b9c491045c788173e83be1ba5d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861381cad67866e249c6330631ac0742" id="r_a861381cad67866e249c6330631ac0742"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a861381cad67866e249c6330631ac0742">getMachineCombinerPatterns</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Root, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;Patterns, <a class="el" href="classbool.html">bool</a> DoRegPressureReduce) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a861381cad67866e249c6330631ac0742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true when there is potentially a faster code sequence for an instruction chain ending in <code>Root</code>.  <br /></td></tr>
<tr class="separator:a861381cad67866e249c6330631ac0742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8cfc1d0bd78872b33f4669f9a18927" id="r_a3b8cfc1d0bd78872b33f4669f9a18927"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b8cfc1d0bd78872b33f4669f9a18927">shouldReduceRegisterPressure</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1RegisterClassInfo.html">RegisterClassInfo</a> *RegClassInfo) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a3b8cfc1d0bd78872b33f4669f9a18927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if target supports reassociation of instructions in machine combiner pass to reduce register pressure for a given BB.  <br /></td></tr>
<tr class="separator:a3b8cfc1d0bd78872b33f4669f9a18927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494876c94cb3dba51694356488a996dd" id="r_a494876c94cb3dba51694356488a996dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a494876c94cb3dba51694356488a996dd">finalizeInsInstrs</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Root, <a class="el" href="classunsigned.html">unsigned</a> &amp;<a class="el" href="classllvm_1_1Pattern.html">Pattern</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;InsInstrs) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a494876c94cb3dba51694356488a996dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix up the placeholder we may add in <a class="el" href="#a6875e5a149ffdf299b10e8f969d379d4" title="When getMachineCombinerPatterns() finds patterns, this function generates the instructions that could...">genAlternativeCodeSequence()</a>.  <br /></td></tr>
<tr class="separator:a494876c94cb3dba51694356488a996dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321a2b25fab981c6d834e3d0df610921" id="r_a321a2b25fab981c6d834e3d0df610921"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a321a2b25fab981c6d834e3d0df610921">isThroughputPattern</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1Pattern.html">Pattern</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a321a2b25fab981c6d834e3d0df610921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true when a code sequence can improve throughput.  <br /></td></tr>
<tr class="separator:a321a2b25fab981c6d834e3d0df610921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf4712d0ec5fc344aa14efa9e5392b2" id="r_adcf4712d0ec5fc344aa14efa9e5392b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacellvm.html#a878ef42ed9660dc3a739a37e056f845d">CombinerObjective</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcf4712d0ec5fc344aa14efa9e5392b2">getCombinerObjective</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1Pattern.html">Pattern</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:adcf4712d0ec5fc344aa14efa9e5392b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the objective of a combiner pattern.  <br /></td></tr>
<tr class="separator:adcf4712d0ec5fc344aa14efa9e5392b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9f804c4f1407df72588bb00db16deb" id="r_ace9f804c4f1407df72588bb00db16deb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace9f804c4f1407df72588bb00db16deb">isReassociationCandidate</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Inst, <a class="el" href="classbool.html">bool</a> &amp;Commuted) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ace9f804c4f1407df72588bb00db16deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the input \P Inst is part of a chain of dependent ops that are suitable for reassociation, otherwise return false.  <br /></td></tr>
<tr class="separator:ace9f804c4f1407df72588bb00db16deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa792b566fb2d8e29af95aea690e33201" id="r_aa792b566fb2d8e29af95aea690e33201"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa792b566fb2d8e29af95aea690e33201">isAssociativeAndCommutative</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Inst, <a class="el" href="classbool.html">bool</a> Invert=false) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa792b566fb2d8e29af95aea690e33201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true when \P Inst is both associative and commutative.  <br /></td></tr>
<tr class="separator:aa792b566fb2d8e29af95aea690e33201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0568ec903d0544ec11e0fb013d2fbe2" id="r_ab0568ec903d0544ec11e0fb013d2fbe2"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0568ec903d0544ec11e0fb013d2fbe2">getInverseOpcode</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab0568ec903d0544ec11e0fb013d2fbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse operation opcode if it exists for \P Opcode (e.g.  <br /></td></tr>
<tr class="separator:ab0568ec903d0544ec11e0fb013d2fbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e545675db8b534aec8eccb7bedb2ee" id="r_a29e545675db8b534aec8eccb7bedb2ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29e545675db8b534aec8eccb7bedb2ee">areOpcodesEqualOrInverse</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode1, <a class="el" href="classunsigned.html">unsigned</a> Opcode2) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a29e545675db8b534aec8eccb7bedb2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true when \P Opcode1 or its inversion is equal to \P Opcode2.  <br /></td></tr>
<tr class="separator:a29e545675db8b534aec8eccb7bedb2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6034cfb230c4698caa60bdc3a9bf209b" id="r_a6034cfb230c4698caa60bdc3a9bf209b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6034cfb230c4698caa60bdc3a9bf209b">hasReassociableOperands</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Inst, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6034cfb230c4698caa60bdc3a9bf209b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true when \P Inst has reassociable operands in the same \P MBB.  <br /></td></tr>
<tr class="separator:a6034cfb230c4698caa60bdc3a9bf209b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea784a4f9e9aba7792c23484e2498e8d" id="r_aea784a4f9e9aba7792c23484e2498e8d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea784a4f9e9aba7792c23484e2498e8d">hasReassociableSibling</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Inst, <a class="el" href="classbool.html">bool</a> &amp;Commuted) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aea784a4f9e9aba7792c23484e2498e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true when \P Inst has reassociable sibling.  <br /></td></tr>
<tr class="separator:aea784a4f9e9aba7792c23484e2498e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6875e5a149ffdf299b10e8f969d379d4" id="r_a6875e5a149ffdf299b10e8f969d379d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6875e5a149ffdf299b10e8f969d379d4">genAlternativeCodeSequence</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Root, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1Pattern.html">Pattern</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;InsInstrs, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;DelInstrs, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;InstIdxForVirtReg) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6875e5a149ffdf299b10e8f969d379d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">When <a class="el" href="#a861381cad67866e249c6330631ac0742" title="Return true when there is potentially a faster code sequence for an instruction chain ending in Root.">getMachineCombinerPatterns()</a> finds patterns, this function generates the instructions that could replace the original code sequence.  <br /></td></tr>
<tr class="separator:a6875e5a149ffdf299b10e8f969d379d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6b72b3ba59a29cb680b5f00831a7b6" id="r_acd6b72b3ba59a29cb680b5f00831a7b6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd6b72b3ba59a29cb680b5f00831a7b6">accumulateInstrSeqToRootLatency</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Root) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:acd6b72b3ba59a29cb680b5f00831a7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">When calculate the latency of the root instruction, accumulate the latency of the sequence to the root latency.  <br /></td></tr>
<tr class="separator:acd6b72b3ba59a29cb680b5f00831a7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ccb406a2c930b241430e6b7b3d1a4f" id="r_a99ccb406a2c930b241430e6b7b3d1a4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99ccb406a2c930b241430e6b7b3d1a4f">getReassociateOperandIndices</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Root, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1Pattern.html">Pattern</a>, std::array&lt; <a class="el" href="classunsigned.html">unsigned</a>, 5 &gt; &amp;<a class="el" href="AMDGPUAsmParser_8cpp.html#a007cff11735bf9959b7cca9dd14eb299">OperandIndices</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a99ccb406a2c930b241430e6b7b3d1a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The returned array encodes the operand index for each parameter because the operands may be commuted; the operand indices for associative operations might also be target-specific.  <br /></td></tr>
<tr class="separator:a99ccb406a2c930b241430e6b7b3d1a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e0c947b38bdebad23286c7764b5249" id="r_ae5e0c947b38bdebad23286c7764b5249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5e0c947b38bdebad23286c7764b5249">reassociateOps</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Root, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Prev, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1Pattern.html">Pattern</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;InsInstrs, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;DelInstrs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; <a class="el" href="AMDGPUAsmParser_8cpp.html#a007cff11735bf9959b7cca9dd14eb299">OperandIndices</a>, <a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;InstrIdxForVirtReg) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae5e0c947b38bdebad23286c7764b5249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to reassociate \P Root and \P Prev according to \P <a class="el" href="classllvm_1_1Pattern.html">Pattern</a> to reduce critical path length.  <br /></td></tr>
<tr class="separator:ae5e0c947b38bdebad23286c7764b5249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903e4ccbdb00b36a08f5e84a8010c3cd" id="r_a903e4ccbdb00b36a08f5e84a8010c3cd"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a903e4ccbdb00b36a08f5e84a8010c3cd">getReassociationOpcodes</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1Pattern.html">Pattern</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Root, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Prev) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a903e4ccbdb00b36a08f5e84a8010c3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reassociation of some instructions requires inverse operations (e.g.  <br /></td></tr>
<tr class="separator:a903e4ccbdb00b36a08f5e84a8010c3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55912dd5bde1306ca2642c4aebca197b" id="r_a55912dd5bde1306ca2642c4aebca197b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55912dd5bde1306ca2642c4aebca197b">getExtendResourceLenLimit</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a55912dd5bde1306ca2642c4aebca197b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The limit on resource length extension we accept in MachineCombiner <a class="el" href="classllvm_1_1Pass.html" title="Pass interface - Implemented by all &#39;passes&#39;.">Pass</a>.  <br /></td></tr>
<tr class="separator:a55912dd5bde1306ca2642c4aebca197b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b63f89d9653388354a58218932dc2f8" id="r_a0b63f89d9653388354a58218932dc2f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b63f89d9653388354a58218932dc2f8">setSpecialOperandAttr</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;OldMI1, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;OldMI2, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;NewMI1, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;NewMI2) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0b63f89d9653388354a58218932dc2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an architecture-specific helper function of reassociateOps.  <br /></td></tr>
<tr class="separator:a0b63f89d9653388354a58218932dc2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb5569c23b5e1ed52164d9ec0496c05" id="r_a4cb5569c23b5e1ed52164d9ec0496c05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cb5569c23b5e1ed52164d9ec0496c05">useMachineCombiner</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a4cb5569c23b5e1ed52164d9ec0496c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true when a target supports MachineCombiner.  <br /></td></tr>
<tr class="separator:a4cb5569c23b5e1ed52164d9ec0496c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1778172912b443f67ccb9ee1af22776" id="r_ae1778172912b443f67ccb9ee1af22776"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacellvm.html#a08fc515218c080e73909645fecb41ed0">MachineTraceStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1778172912b443f67ccb9ee1af22776">getMachineCombinerTraceStrategy</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae1778172912b443f67ccb9ee1af22776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a strategy that MachineCombiner must use when creating traces.  <br /></td></tr>
<tr class="separator:ae1778172912b443f67ccb9ee1af22776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8003a932104a6adf3ddbf4435a49f0" id="r_a7b8003a932104a6adf3ddbf4435a49f0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b8003a932104a6adf3ddbf4435a49f0">canCopyGluedNodeDuringSchedule</a> (<a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7b8003a932104a6adf3ddbf4435a49f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given <a class="el" href="classllvm_1_1SDNode.html" title="Represents one node in the SelectionDAG.">SDNode</a> can be copied during scheduling even if it has glue.  <br /></td></tr>
<tr class="separator:a7b8003a932104a6adf3ddbf4435a49f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44220d7a83b114a21ca2d23ffed03b2" id="r_aa44220d7a83b114a21ca2d23ffed03b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa44220d7a83b114a21ca2d23ffed03b2">unfoldMemoryOperand</a> (<a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="MachineSink_8cpp.html#a359e1ff26f6d466d927a61aae45b05c3">Reg</a>, <a class="el" href="classbool.html">bool</a> UnfoldLoad, <a class="el" href="classbool.html">bool</a> UnfoldStore, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;NewMIs) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa44220d7a83b114a21ca2d23ffed03b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">unfoldMemoryOperand - Separate a single instruction which folded a load or a store or a load and a store into two or more instruction.  <br /></td></tr>
<tr class="separator:aa44220d7a83b114a21ca2d23ffed03b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a82bf89bd98729150cebde60be9dfd" id="r_af7a82bf89bd98729150cebde60be9dfd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7a82bf89bd98729150cebde60be9dfd">unfoldMemoryOperand</a> (<a class="el" href="classllvm_1_1SelectionDAG.html">SelectionDAG</a> &amp;DAG, <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> * &gt; &amp;NewNodes) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:af7a82bf89bd98729150cebde60be9dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b6d3fde7f1a20c72a6a7b4eeb4164f" id="r_a29b6d3fde7f1a20c72a6a7b4eeb4164f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29b6d3fde7f1a20c72a6a7b4eeb4164f">getOpcodeAfterMemoryUnfold</a> (<a class="el" href="classunsigned.html">unsigned</a> Opc, <a class="el" href="classbool.html">bool</a> UnfoldLoad, <a class="el" href="classbool.html">bool</a> UnfoldStore, <a class="el" href="classunsigned.html">unsigned</a> *LoadRegIndex=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a29b6d3fde7f1a20c72a6a7b4eeb4164f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the opcode of the would be new instruction after load / store are unfolded from an instruction of the specified opcode.  <br /></td></tr>
<tr class="separator:a29b6d3fde7f1a20c72a6a7b4eeb4164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ae1d6ce8dc191d8300c25b3e287961" id="r_af6ae1d6ce8dc191d8300c25b3e287961"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6ae1d6ce8dc191d8300c25b3e287961">areLoadsFromSameBasePtr</a> (<a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *Load1, <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *Load2, int64_t &amp;Offset1, int64_t &amp;Offset2) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af6ae1d6ce8dc191d8300c25b3e287961"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used by the pre-regalloc scheduler to determine if two loads are loading from the same base address.  <br /></td></tr>
<tr class="separator:af6ae1d6ce8dc191d8300c25b3e287961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7613f5f7e38ac5338a58172dd6429370" id="r_a7613f5f7e38ac5338a58172dd6429370"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7613f5f7e38ac5338a58172dd6429370">shouldScheduleLoadsNear</a> (<a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *Load1, <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *Load2, int64_t Offset1, int64_t Offset2, <a class="el" href="classunsigned.html">unsigned</a> NumLoads) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7613f5f7e38ac5338a58172dd6429370"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a used by the pre-regalloc scheduler to determine (in conjunction with areLoadsFromSameBasePtr) if two loads should be scheduled together.  <br /></td></tr>
<tr class="separator:a7613f5f7e38ac5338a58172dd6429370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbc2492f83b9a1b2b2b850283240272" id="r_afbbc2492f83b9a1b2b2b850283240272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbbc2492f83b9a1b2b2b850283240272">getMemOperandWithOffset</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> *&amp;BaseOp, int64_t &amp;<a class="el" href="namespacellvm.html#a05f5b9a11bdcc5feba62899f95dcf878a3134224cba2545bc57954d3b072aebb4">Offset</a>, <a class="el" href="classbool.html">bool</a> &amp;OffsetIsScalable, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:afbbc2492f83b9a1b2b2b850283240272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the base operand and byte offset of an instruction that reads/writes memory.  <br /></td></tr>
<tr class="separator:afbbc2492f83b9a1b2b2b850283240272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad562f15f35ef21a4965d1b9f522a360c" id="r_ad562f15f35ef21a4965d1b9f522a360c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad562f15f35ef21a4965d1b9f522a360c">getMemOperandsWithOffsetWidth</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> * &gt; &amp;BaseOps, int64_t &amp;<a class="el" href="namespacellvm.html#a05f5b9a11bdcc5feba62899f95dcf878a3134224cba2545bc57954d3b072aebb4">Offset</a>, <a class="el" href="classbool.html">bool</a> &amp;OffsetIsScalable, <a class="el" href="classllvm_1_1LocationSize.html">LocationSize</a> &amp;Width, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad562f15f35ef21a4965d1b9f522a360c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get zero or more base operands and the byte offset of an instruction that reads/writes memory.  <br /></td></tr>
<tr class="separator:ad562f15f35ef21a4965d1b9f522a360c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d18d91f58682d65e97e9c386064b5b" id="r_a28d18d91f58682d65e97e9c386064b5b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28d18d91f58682d65e97e9c386064b5b">getBaseAndOffsetPosition</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> &amp;BasePos, <a class="el" href="classunsigned.html">unsigned</a> &amp;OffsetPos) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a28d18d91f58682d65e97e9c386064b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the instruction contains a base register and offset.  <br /></td></tr>
<tr class="separator:a28d18d91f58682d65e97e9c386064b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea0602dc926bed4a92bc63ae99e7cc9" id="r_a7ea0602dc926bed4a92bc63ae99e7cc9"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="structllvm_1_1ExtAddrMode.html">ExtAddrMode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ea0602dc926bed4a92bc63ae99e7cc9">getAddrModeFromMemoryOp</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;MemI, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7ea0602dc926bed4a92bc63ae99e7cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Target.html" title="Target - Wrapper for Target specific information.">Target</a> dependent implementation to get the values constituting the address <a class="el" href="classllvm_1_1MachineInstr.html" title="Representation of each machine instruction.">MachineInstr</a> that is accessing memory.  <br /></td></tr>
<tr class="separator:a7ea0602dc926bed4a92bc63ae99e7cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32583e70bd8c1b6ccb45a21129efac24" id="r_a32583e70bd8c1b6ccb45a21129efac24"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32583e70bd8c1b6ccb45a21129efac24">canFoldIntoAddrMode</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;MemI, <a class="el" href="classllvm_1_1Register.html">Register</a> <a class="el" href="MachineSink_8cpp.html#a359e1ff26f6d466d927a61aae45b05c3">Reg</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;AddrI, <a class="el" href="structllvm_1_1ExtAddrMode.html">ExtAddrMode</a> &amp;AM) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a32583e70bd8c1b6ccb45a21129efac24"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacellvm_1_1Check.html">Check</a> if it's possible and beneficial to fold the addressing computation <code>AddrI</code> into the addressing mode of the load/store instruction <code>MemI</code>.  <br /></td></tr>
<tr class="separator:a32583e70bd8c1b6ccb45a21129efac24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed830dc2b930795e75691f1efa942b12" id="r_aed830dc2b930795e75691f1efa942b12"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed830dc2b930795e75691f1efa942b12">emitLdStWithAddr</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;MemI, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1ExtAddrMode.html">ExtAddrMode</a> &amp;AM) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aed830dc2b930795e75691f1efa942b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a load/store instruction with the same value register as <code>MemI</code>, but using the address from <code>AM</code>.  <br /></td></tr>
<tr class="separator:aed830dc2b930795e75691f1efa942b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45aa2763f52ee7bb3f41393d1d4ba079" id="r_a45aa2763f52ee7bb3f41393d1d4ba079"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45aa2763f52ee7bb3f41393d1d4ba079">preservesZeroValueInReg</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Register.html">Register</a> NullValueReg, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a45aa2763f52ee7bb3f41393d1d4ba079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if MI's Def is NullValueReg, and the MI does not change the Zero value.  <br /></td></tr>
<tr class="separator:a45aa2763f52ee7bb3f41393d1d4ba079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af454ffcb2775e8a8abf663da93a0a438" id="r_af454ffcb2775e8a8abf663da93a0a438"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af454ffcb2775e8a8abf663da93a0a438">getIncrementValue</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, int &amp;<a class="el" href="classllvm_1_1Value.html">Value</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af454ffcb2775e8a8abf663da93a0a438"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the instruction is an increment of a constant value, return the amount.  <br /></td></tr>
<tr class="separator:af454ffcb2775e8a8abf663da93a0a438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c56f769334913401fe67e9e123b3d59" id="r_a6c56f769334913401fe67e9e123b3d59"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c56f769334913401fe67e9e123b3d59">shouldClusterMemOps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> * &gt; BaseOps1, int64_t Offset1, <a class="el" href="classbool.html">bool</a> OffsetIsScalable1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> * &gt; BaseOps2, int64_t Offset2, <a class="el" href="classbool.html">bool</a> OffsetIsScalable2, <a class="el" href="classunsigned.html">unsigned</a> ClusterSize, <a class="el" href="classunsigned.html">unsigned</a> NumBytes) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6c56f769334913401fe67e9e123b3d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the two given memory operations should be scheduled adjacent.  <br /></td></tr>
<tr class="separator:a6c56f769334913401fe67e9e123b3d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013a36a3a8a5acbdb9bcf1d3c6fede83" id="r_a013a36a3a8a5acbdb9bcf1d3c6fede83"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a013a36a3a8a5acbdb9bcf1d3c6fede83">reverseBranchCondition</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;<a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a013a36a3a8a5acbdb9bcf1d3c6fede83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the branch condition of the specified condition list, returning false on success and true if it cannot be reversed.  <br /></td></tr>
<tr class="separator:a013a36a3a8a5acbdb9bcf1d3c6fede83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee57d5d6295dfeb44f3b55301b20020" id="r_a4ee57d5d6295dfeb44f3b55301b20020"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ee57d5d6295dfeb44f3b55301b20020">insertNoop</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> <a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a4ee57d5d6295dfeb44f3b55301b20020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a noop into the instruction stream at the specified point.  <br /></td></tr>
<tr class="separator:a4ee57d5d6295dfeb44f3b55301b20020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c15ac4d0e9521ba7225f100f657639" id="r_ab2c15ac4d0e9521ba7225f100f657639"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2c15ac4d0e9521ba7225f100f657639">insertNoops</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> <a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> Quantity) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab2c15ac4d0e9521ba7225f100f657639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert noops into the instruction stream at the specified point.  <br /></td></tr>
<tr class="separator:ab2c15ac4d0e9521ba7225f100f657639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8999c1de8a33ab1a9029e4852342e579" id="r_a8999c1de8a33ab1a9029e4852342e579"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MCInst.html">MCInst</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8999c1de8a33ab1a9029e4852342e579">getNop</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a8999c1de8a33ab1a9029e4852342e579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the noop instruction to use for a noop.  <br /></td></tr>
<tr class="separator:a8999c1de8a33ab1a9029e4852342e579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb223b29cc4acffa9ffd03d134b2a1e" id="r_a1cb223b29cc4acffa9ffd03d134b2a1e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cb223b29cc4acffa9ffd03d134b2a1e">isPostIncrement</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a1cb223b29cc4acffa9ffd03d134b2a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true for post-incremented instructions.  <br /></td></tr>
<tr class="separator:a1cb223b29cc4acffa9ffd03d134b2a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda2e966ced4c77ce8a78e5e063e07cd" id="r_abda2e966ced4c77ce8a78e5e063e07cd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abda2e966ced4c77ce8a78e5e063e07cd">isPredicated</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:abda2e966ced4c77ce8a78e5e063e07cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the instruction is already predicated.  <br /></td></tr>
<tr class="separator:abda2e966ced4c77ce8a78e5e063e07cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a593a2fa65858fcd920bd782108c999" id="r_a0a593a2fa65858fcd920bd782108c999"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a593a2fa65858fcd920bd782108c999">canPredicatePredicatedInstr</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0a593a2fa65858fcd920bd782108c999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assumes the instruction is already predicated and returns true if the instruction can be predicated again.  <br /></td></tr>
<tr class="separator:a0a593a2fa65858fcd920bd782108c999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7fb8b18a37883f51af73238e47dea4" id="r_aea7fb8b18a37883f51af73238e47dea4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea7fb8b18a37883f51af73238e47dea4">createMIROperandComment</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &amp;<a class="el" href="namespacellvm.html#ab471937b9a227e70c7fe8bd9604014d6">Op</a>, <a class="el" href="classunsigned.html">unsigned</a> OpIdx, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aea7fb8b18a37883f51af73238e47dea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4993b49c4db728d9669c0f6a08daae2e" id="r_a4993b49c4db728d9669c0f6a08daae2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4993b49c4db728d9669c0f6a08daae2e">isUnpredicatedTerminator</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a4993b49c4db728d9669c0f6a08daae2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the instruction is a terminator instruction that has not been predicated.  <br /></td></tr>
<tr class="separator:a4993b49c4db728d9669c0f6a08daae2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49711da0a9e246f5960bf2816b0d8aa3" id="r_a49711da0a9e246f5960bf2816b0d8aa3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49711da0a9e246f5960bf2816b0d8aa3">isUnconditionalTailCall</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a49711da0a9e246f5960bf2816b0d8aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if MI is an unconditional tail call.  <br /></td></tr>
<tr class="separator:a49711da0a9e246f5960bf2816b0d8aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163e14d44765e368d3a79ceea6d00eaa" id="r_a163e14d44765e368d3a79ceea6d00eaa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a163e14d44765e368d3a79ceea6d00eaa">canMakeTailCallConditional</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;<a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;TailCall) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a163e14d44765e368d3a79ceea6d00eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tail call can be made conditional on BranchCond.  <br /></td></tr>
<tr class="separator:a163e14d44765e368d3a79ceea6d00eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee18da5b03753cdb0cd484b2a4e2c35" id="r_abee18da5b03753cdb0cd484b2a4e2c35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abee18da5b03753cdb0cd484b2a4e2c35">replaceBranchWithTailCall</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;<a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;TailCall) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:abee18da5b03753cdb0cd484b2a4e2c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the conditional branch in MBB with a conditional tail call.  <br /></td></tr>
<tr class="separator:abee18da5b03753cdb0cd484b2a4e2c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29513f18e551370b1b438f95403efc04" id="r_a29513f18e551370b1b438f95403efc04"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29513f18e551370b1b438f95403efc04">PredicateInstruction</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; Pred) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a29513f18e551370b1b438f95403efc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the instruction into a predicated instruction.  <br /></td></tr>
<tr class="separator:a29513f18e551370b1b438f95403efc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ba312c2d730acd131fccc2cc787498" id="r_a51ba312c2d730acd131fccc2cc787498"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51ba312c2d730acd131fccc2cc787498">SubsumesPredicate</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; Pred1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; Pred2) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a51ba312c2d730acd131fccc2cc787498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first specified predicate subsumes the second, e.g.  <br /></td></tr>
<tr class="separator:a51ba312c2d730acd131fccc2cc787498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0695148f396023fb3cf404a5447a2412" id="r_a0695148f396023fb3cf404a5447a2412"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0695148f396023fb3cf404a5447a2412">ClobbersPredicate</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, std::vector&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;Pred, <a class="el" href="classbool.html">bool</a> SkipDead) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0695148f396023fb3cf404a5447a2412"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified instruction defines any predicate or condition code register(s) used for predication, returns true as well as the definition predicate(s) by reference.  <br /></td></tr>
<tr class="separator:a0695148f396023fb3cf404a5447a2412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf401885b0d39da5774814718bc889c8" id="r_adf401885b0d39da5774814718bc889c8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf401885b0d39da5774814718bc889c8">isPredicable</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:adf401885b0d39da5774814718bc889c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified instruction can be predicated.  <br /></td></tr>
<tr class="separator:adf401885b0d39da5774814718bc889c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf676347c6bf8157f319dac9e601f168" id="r_adf676347c6bf8157f319dac9e601f168"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf676347c6bf8157f319dac9e601f168">isSafeToMoveRegClassDefs</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterClass.html">TargetRegisterClass</a> *RC) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:adf676347c6bf8157f319dac9e601f168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it's safe to move a machine instruction that defines the specified register class.  <br /></td></tr>
<tr class="separator:adf676347c6bf8157f319dac9e601f168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad071e937f4986e51fd3fd54b10888894" id="r_ad071e937f4986e51fd3fd54b10888894"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad071e937f4986e51fd3fd54b10888894">isSchedulingBoundary</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad071e937f4986e51fd3fd54b10888894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given instruction should be considered a scheduling boundary.  <br /></td></tr>
<tr class="separator:ad071e937f4986e51fd3fd54b10888894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65168b27efceb92102521e2bc82b8d49" id="r_a65168b27efceb92102521e2bc82b8d49"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65168b27efceb92102521e2bc82b8d49">getInlineAsmLength</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> *Str, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MCAsmInfo.html">MCAsmInfo</a> &amp;MAI, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetSubtargetInfo.html">TargetSubtargetInfo</a> *STI=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a65168b27efceb92102521e2bc82b8d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the specified inline asm to determine an approximation of its length.  <br /></td></tr>
<tr class="separator:a65168b27efceb92102521e2bc82b8d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7242b69b2f705111801d717e2ea243b5" id="r_a7242b69b2f705111801d717e2ea243b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1ScheduleHazardRecognizer.html">ScheduleHazardRecognizer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7242b69b2f705111801d717e2ea243b5">CreateTargetHazardRecognizer</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetSubtargetInfo.html">TargetSubtargetInfo</a> *STI, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ScheduleDAG.html">ScheduleDAG</a> *DAG) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7242b69b2f705111801d717e2ea243b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and return a hazard recognizer to use for this target when scheduling the machine instructions before register allocation.  <br /></td></tr>
<tr class="separator:a7242b69b2f705111801d717e2ea243b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da941cb7cfe3ae9b3dae1f5caac8b78" id="r_a5da941cb7cfe3ae9b3dae1f5caac8b78"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1ScheduleHazardRecognizer.html">ScheduleHazardRecognizer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5da941cb7cfe3ae9b3dae1f5caac8b78">CreateTargetMIHazardRecognizer</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ScheduleDAGMI.html">ScheduleDAGMI</a> *DAG) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5da941cb7cfe3ae9b3dae1f5caac8b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and return a hazard recognizer to use for this target when scheduling the machine instructions before register allocation.  <br /></td></tr>
<tr class="separator:a5da941cb7cfe3ae9b3dae1f5caac8b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000bd55721d30de4fee9eb3d812714ea" id="r_a000bd55721d30de4fee9eb3d812714ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1ScheduleHazardRecognizer.html">ScheduleHazardRecognizer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a000bd55721d30de4fee9eb3d812714ea">CreateTargetPostRAHazardRecognizer</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ScheduleDAG.html">ScheduleDAG</a> *DAG) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a000bd55721d30de4fee9eb3d812714ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and return a hazard recognizer to use for this target when scheduling the machine instructions after register allocation.  <br /></td></tr>
<tr class="separator:a000bd55721d30de4fee9eb3d812714ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d2e824f1b036f45b51519f2844720b" id="r_a55d2e824f1b036f45b51519f2844720b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1ScheduleHazardRecognizer.html">ScheduleHazardRecognizer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55d2e824f1b036f45b51519f2844720b">CreateTargetPostRAHazardRecognizer</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a55d2e824f1b036f45b51519f2844720b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and return a hazard recognizer to use for by non-scheduling passes.  <br /></td></tr>
<tr class="separator:a55d2e824f1b036f45b51519f2844720b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af286c176e38f876d4f56a34cb9ee319a" id="r_af286c176e38f876d4f56a34cb9ee319a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af286c176e38f876d4f56a34cb9ee319a">usePreRAHazardRecognizer</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af286c176e38f876d4f56a34cb9ee319a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a global flag for disabling the PreRA hazard recognizer that targets may choose to honor.  <br /></td></tr>
<tr class="separator:af286c176e38f876d4f56a34cb9ee319a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90a0ce256d5ae1e1181b032da5d2779" id="r_af90a0ce256d5ae1e1181b032da5d2779"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af90a0ce256d5ae1e1181b032da5d2779">analyzeCompare</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> &amp;SrcReg, <a class="el" href="classllvm_1_1Register.html">Register</a> &amp;SrcReg2, int64_t &amp;Mask, int64_t &amp;<a class="el" href="classllvm_1_1Value.html">Value</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af90a0ce256d5ae1e1181b032da5d2779"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a comparison instruction, return the source registers in SrcReg and SrcReg2 if having two register operands, and the value it compares against in CmpValue.  <br /></td></tr>
<tr class="separator:af90a0ce256d5ae1e1181b032da5d2779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d95382897959324602ecb63f7392fda" id="r_a6d95382897959324602ecb63f7392fda"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d95382897959324602ecb63f7392fda">optimizeCompareInstr</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;CmpInstr, <a class="el" href="classllvm_1_1Register.html">Register</a> SrcReg, <a class="el" href="classllvm_1_1Register.html">Register</a> SrcReg2, int64_t Mask, int64_t <a class="el" href="classllvm_1_1Value.html">Value</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> *<a class="el" href="AArch64AdvSIMDScalarPass_8cpp.html#aacd2ab195054a3e6a74bfbb9d5d571c8">MRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6d95382897959324602ecb63f7392fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if the comparison instruction can be converted into something more efficient.  <br /></td></tr>
<tr class="separator:a6d95382897959324602ecb63f7392fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9414061830d845a2b79363614cf5b5db" id="r_a9414061830d845a2b79363614cf5b5db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9414061830d845a2b79363614cf5b5db">optimizeCondBranch</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a9414061830d845a2b79363614cf5b5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01961400ab1186ac9f849cf0e738447f" id="r_a01961400ab1186ac9f849cf0e738447f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01961400ab1186ac9f849cf0e738447f">optimizeLoadInstr</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> *<a class="el" href="AArch64AdvSIMDScalarPass_8cpp.html#aacd2ab195054a3e6a74bfbb9d5d571c8">MRI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> &amp;FoldAsLoadDefReg, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&amp;<a class="el" href="AArch64ExpandPseudoInsts_8cpp.html#ad3ece0ac2421637044624c9b01c42466">DefMI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a01961400ab1186ac9f849cf0e738447f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to remove the load by folding it to a register operand at the use.  <br /></td></tr>
<tr class="separator:a01961400ab1186ac9f849cf0e738447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41c45a69f227ee71e5ced4e6e3fde18" id="r_aa41c45a69f227ee71e5ced4e6e3fde18"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa41c45a69f227ee71e5ced4e6e3fde18">foldImmediate</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="AArch64ExpandPseudoInsts_8cpp.html#a6cf2f8996b1e9aaf2d7a435aaa62382f">UseMI</a>, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="AArch64ExpandPseudoInsts_8cpp.html#ad3ece0ac2421637044624c9b01c42466">DefMI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> <a class="el" href="MachineSink_8cpp.html#a359e1ff26f6d466d927a61aae45b05c3">Reg</a>, <a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> *<a class="el" href="AArch64AdvSIMDScalarPass_8cpp.html#aacd2ab195054a3e6a74bfbb9d5d571c8">MRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa41c45a69f227ee71e5ced4e6e3fde18"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Reg' is known to be defined by a move immediate instruction, try to fold the immediate into the use instruction.  <br /></td></tr>
<tr class="separator:aa41c45a69f227ee71e5ced4e6e3fde18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bf43322793449e23ced7810ac16ecb" id="r_a16bf43322793449e23ced7810ac16ecb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16bf43322793449e23ced7810ac16ecb">getNumMicroOps</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *ItinData, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a16bf43322793449e23ced7810ac16ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of u-operations the given machine instruction will be decoded to on the target cpu.  <br /></td></tr>
<tr class="separator:a16bf43322793449e23ced7810ac16ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba282dba26451dcfbbc938444595d7e" id="r_a0ba282dba26451dcfbbc938444595d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ba282dba26451dcfbbc938444595d7e">isZeroCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0ba282dba26451dcfbbc938444595d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true for pseudo instructions that don't consume any machine resources in their current form.  <br /></td></tr>
<tr class="separator:a0ba282dba26451dcfbbc938444595d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65c4a19ddc8ce7ddec084e5a1a4a62a" id="r_aa65c4a19ddc8ce7ddec084e5a1a4a62a"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa65c4a19ddc8ce7ddec084e5a1a4a62a">getOperandLatency</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *ItinData, <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *DefNode, <a class="el" href="classunsigned.html">unsigned</a> DefIdx, <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *UseNode, <a class="el" href="classunsigned.html">unsigned</a> UseIdx) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aa65c4a19ddc8ce7ddec084e5a1a4a62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1e693dee703f46fd28221e99d4acff" id="r_a9b1e693dee703f46fd28221e99d4acff"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b1e693dee703f46fd28221e99d4acff">getOperandLatency</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *ItinData, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="AArch64ExpandPseudoInsts_8cpp.html#ad3ece0ac2421637044624c9b01c42466">DefMI</a>, <a class="el" href="classunsigned.html">unsigned</a> DefIdx, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="AArch64ExpandPseudoInsts_8cpp.html#a6cf2f8996b1e9aaf2d7a435aaa62382f">UseMI</a>, <a class="el" href="classunsigned.html">unsigned</a> UseIdx) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a9b1e693dee703f46fd28221e99d4acff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the use operand latency of a given pair of def and use.  <br /></td></tr>
<tr class="separator:a9b1e693dee703f46fd28221e99d4acff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45af359a246cde99ce09578e3998985" id="r_ac45af359a246cde99ce09578e3998985"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac45af359a246cde99ce09578e3998985">getInstrLatency</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *ItinData, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> *PredCost=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac45af359a246cde99ce09578e3998985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the instruction latency of a given instruction.  <br /></td></tr>
<tr class="separator:ac45af359a246cde99ce09578e3998985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89d6efd5d16c7e44f26ef26296e13aa" id="r_ad89d6efd5d16c7e44f26ef26296e13aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad89d6efd5d16c7e44f26ef26296e13aa">getPredicationCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ad89d6efd5d16c7e44f26ef26296e13aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ea143f1ea40632ba851badcf377101" id="r_a86ea143f1ea40632ba851badcf377101"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86ea143f1ea40632ba851badcf377101">getInstrLatency</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *ItinData, <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="classNode.html">Node</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a86ea143f1ea40632ba851badcf377101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5424d7c9e608bd5b2087f1021908a08" id="r_ae5424d7c9e608bd5b2087f1021908a08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5424d7c9e608bd5b2087f1021908a08">defaultDefLatency</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1MCSchedModel.html">MCSchedModel</a> &amp;SchedModel, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="AArch64ExpandPseudoInsts_8cpp.html#ad3ece0ac2421637044624c9b01c42466">DefMI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae5424d7c9e608bd5b2087f1021908a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default expected latency for a def based on its opcode.  <br /></td></tr>
<tr class="separator:ae5424d7c9e608bd5b2087f1021908a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbd8a676ca4d2926a87022815a5015d" id="r_aebbd8a676ca4d2926a87022815a5015d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebbd8a676ca4d2926a87022815a5015d">isHighLatencyDef</a> (int opc) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aebbd8a676ca4d2926a87022815a5015d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this opcode has high latency to its result.  <br /></td></tr>
<tr class="separator:aebbd8a676ca4d2926a87022815a5015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4993bfe73a55f4fcc5d02d09c410ddaf" id="r_a4993bfe73a55f4fcc5d02d09c410ddaf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4993bfe73a55f4fcc5d02d09c410ddaf">hasHighOperandLatency</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetSchedModel.html">TargetSchedModel</a> &amp;SchedModel, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> *<a class="el" href="AArch64AdvSIMDScalarPass_8cpp.html#aacd2ab195054a3e6a74bfbb9d5d571c8">MRI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="AArch64ExpandPseudoInsts_8cpp.html#ad3ece0ac2421637044624c9b01c42466">DefMI</a>, <a class="el" href="classunsigned.html">unsigned</a> DefIdx, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="AArch64ExpandPseudoInsts_8cpp.html#a6cf2f8996b1e9aaf2d7a435aaa62382f">UseMI</a>, <a class="el" href="classunsigned.html">unsigned</a> UseIdx) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a4993bfe73a55f4fcc5d02d09c410ddaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute operand latency between a def of 'Reg' and a use in the current loop.  <br /></td></tr>
<tr class="separator:a4993bfe73a55f4fcc5d02d09c410ddaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa73253579dd1c4acde85953454e838" id="r_a0aa73253579dd1c4acde85953454e838"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aa73253579dd1c4acde85953454e838">hasLowDefLatency</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetSchedModel.html">TargetSchedModel</a> &amp;SchedModel, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="AArch64ExpandPseudoInsts_8cpp.html#ad3ece0ac2421637044624c9b01c42466">DefMI</a>, <a class="el" href="classunsigned.html">unsigned</a> DefIdx) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0aa73253579dd1c4acde85953454e838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute operand latency of a def of 'Reg'.  <br /></td></tr>
<tr class="separator:a0aa73253579dd1c4acde85953454e838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490afb5ecb8232428c7ce7b87ef24b43" id="r_a490afb5ecb8232428c7ce7b87ef24b43"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a490afb5ecb8232428c7ce7b87ef24b43">verifyInstruction</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1StringRef.html">StringRef</a> &amp;ErrInfo) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a490afb5ecb8232428c7ce7b87ef24b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform target-specific instruction verification.  <br /></td></tr>
<tr class="separator:a490afb5ecb8232428c7ce7b87ef24b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907019eb40cf2db5f3a35cb0bc456347" id="r_a907019eb40cf2db5f3a35cb0bc456347"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="classuint16__t.html">uint16_t</a>, <a class="el" href="classuint16__t.html">uint16_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a907019eb40cf2db5f3a35cb0bc456347">getExecutionDomain</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a907019eb40cf2db5f3a35cb0bc456347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current execution domain and bit mask of possible domains for instruction.  <br /></td></tr>
<tr class="separator:a907019eb40cf2db5f3a35cb0bc456347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcfa8a45f569feb4562cff3567163ef" id="r_adbcfa8a45f569feb4562cff3567163ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbcfa8a45f569feb4562cff3567163ef">setExecutionDomain</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="CorrelatedValuePropagation_8cpp.html#aad75d6f4f14a7b791076c6785aa59be4">Domain</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:adbcfa8a45f569feb4562cff3567163ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the opcode of MI to execute in Domain.  <br /></td></tr>
<tr class="separator:adbcfa8a45f569feb4562cff3567163ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14308e147ea57526f7fd1198ab551a9a" id="r_a14308e147ea57526f7fd1198ab551a9a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14308e147ea57526f7fd1198ab551a9a">getPartialRegUpdateClearance</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> OpNum, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a14308e147ea57526f7fd1198ab551a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the preferred minimum clearance before an instruction with an unwanted partial register update.  <br /></td></tr>
<tr class="separator:a14308e147ea57526f7fd1198ab551a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4159fd0062dd97fe920f738c776a7356" id="r_a4159fd0062dd97fe920f738c776a7356"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4159fd0062dd97fe920f738c776a7356">getUndefRegClearance</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> OpNum, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a4159fd0062dd97fe920f738c776a7356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum clearance before an instruction that reads an unused register.  <br /></td></tr>
<tr class="separator:a4159fd0062dd97fe920f738c776a7356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525a9aaabc1362deb245b0099ea5538e" id="r_a525a9aaabc1362deb245b0099ea5538e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a525a9aaabc1362deb245b0099ea5538e">breakPartialRegDependency</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> OpNum, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *<a class="el" href="MachineSink_8cpp.html#a0f36ed1bc17fc1aa97fe291c439a0698">TRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a525a9aaabc1362deb245b0099ea5538e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a dependency-breaking instruction before MI to eliminate an unwanted dependency on OpNum.  <br /></td></tr>
<tr class="separator:a525a9aaabc1362deb245b0099ea5538e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186f383639b8c8fe141b55411d1121a9" id="r_a186f383639b8c8fe141b55411d1121a9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1DFAPacketizer.html">DFAPacketizer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a186f383639b8c8fe141b55411d1121a9">CreateTargetScheduleState</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetSubtargetInfo.html">TargetSubtargetInfo</a> &amp;) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a186f383639b8c8fe141b55411d1121a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create machine specific model for scheduling.  <br /></td></tr>
<tr class="separator:a186f383639b8c8fe141b55411d1121a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8ea6535c262fbc8a16177783020314" id="r_a5f8ea6535c262fbc8a16177783020314"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8ea6535c262fbc8a16177783020314">areMemAccessesTriviallyDisjoint</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;MIa, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;MIb) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5f8ea6535c262fbc8a16177783020314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sometimes, it is possible for the target to tell, even without aliasing information, that two MIs access different memory addresses.  <br /></td></tr>
<tr class="separator:a5f8ea6535c262fbc8a16177783020314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3c5e05e3b2eb5e8dd9c763efbdca4b" id="r_afa3c5e05e3b2eb5e8dd9c763efbdca4b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa3c5e05e3b2eb5e8dd9c763efbdca4b">getMachineCSELookAheadLimit</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:afa3c5e05e3b2eb5e8dd9c763efbdca4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value to use for the MachineCSE's LookAheadLimit, which is a heuristic used for CSE'ing phys reg defs.  <br /></td></tr>
<tr class="separator:afa3c5e05e3b2eb5e8dd9c763efbdca4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f67bce035b491e5e6d95286ffe20da1" id="r_a6f67bce035b491e5e6d95286ffe20da1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f67bce035b491e5e6d95286ffe20da1">getMemOperandAACheckLimit</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6f67bce035b491e5e6d95286ffe20da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximal number of alias checks on memory operands.  <br /></td></tr>
<tr class="separator:a6f67bce035b491e5e6d95286ffe20da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3166a8e59fbea4a6f27fefd6a8fea1" id="r_a3d3166a8e59fbea4a6f27fefd6a8fea1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; int, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d3166a8e59fbea4a6f27fefd6a8fea1">getSerializableTargetIndices</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a3d3166a8e59fbea4a6f27fefd6a8fea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array that contains the ids of the target indices (used for the TargetIndex machine operand) and their names.  <br /></td></tr>
<tr class="separator:a3d3166a8e59fbea4a6f27fefd6a8fea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf55430291b4f35540c9c7dfc28fedaa" id="r_adf55430291b4f35540c9c7dfc28fedaa"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf55430291b4f35540c9c7dfc28fedaa">decomposeMachineOperandsTargetFlags</a> (<a class="el" href="classunsigned.html">unsigned</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:adf55430291b4f35540c9c7dfc28fedaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose the machine operand's target flags into two values - the direct target flag value and any of bit flags that are applied.  <br /></td></tr>
<tr class="separator:adf55430291b4f35540c9c7dfc28fedaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb630da1cbdfc0d8425933e20b37a73" id="r_aefb630da1cbdfc0d8425933e20b37a73"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefb630da1cbdfc0d8425933e20b37a73">getSerializableDirectMachineOperandTargetFlags</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aefb630da1cbdfc0d8425933e20b37a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array that contains the direct target flag values and their names.  <br /></td></tr>
<tr class="separator:aefb630da1cbdfc0d8425933e20b37a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ef2aeaba3f310827d58a0a3b16cfd8" id="r_a82ef2aeaba3f310827d58a0a3b16cfd8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82ef2aeaba3f310827d58a0a3b16cfd8">getSerializableBitmaskMachineOperandTargetFlags</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a82ef2aeaba3f310827d58a0a3b16cfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array that contains the bitmask target flag values and their names.  <br /></td></tr>
<tr class="separator:a82ef2aeaba3f310827d58a0a3b16cfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e0bf9b6a35f938342ed56dfcfe7786" id="r_a27e0bf9b6a35f938342ed56dfcfe7786"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classllvm_1_1MachineMemOperand.html#aaa2020e47e35179234b9ea27d555b2dd">MachineMemOperand::Flags</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27e0bf9b6a35f938342ed56dfcfe7786">getSerializableMachineMemOperandTargetFlags</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a27e0bf9b6a35f938342ed56dfcfe7786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array that contains the MMO target flag values and their names.  <br /></td></tr>
<tr class="separator:a27e0bf9b6a35f938342ed56dfcfe7786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d33681dd1899a420e4b30bf11f4b58e" id="r_a9d33681dd1899a420e4b30bf11f4b58e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d33681dd1899a420e4b30bf11f4b58e">isTailCall</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;Inst) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a9d33681dd1899a420e4b30bf11f4b58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code>Inst</code> is a tail call instruction.  <br /></td></tr>
<tr class="separator:a9d33681dd1899a420e4b30bf11f4b58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0138c08492e75b8b22f8fe0764b95853" id="r_a0138c08492e75b8b22f8fe0764b95853"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0138c08492e75b8b22f8fe0764b95853">isBasicBlockPrologue</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> <a class="el" href="MachineSink_8cpp.html#a359e1ff26f6d466d927a61aae45b05c3">Reg</a>=<a class="el" href="classllvm_1_1Register.html">Register</a>()) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0138c08492e75b8b22f8fe0764b95853"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the instruction is bound to the top of its basic block and no other instructions shall be inserted before it.  <br /></td></tr>
<tr class="separator:a0138c08492e75b8b22f8fe0764b95853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf855363122e65fd4e6f2df1d16aba0" id="r_a6cf855363122e65fd4e6f2df1d16aba0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cf855363122e65fd4e6f2df1d16aba0">getLiveRangeSplitOpcode</a> (<a class="el" href="classllvm_1_1Register.html">Register</a> <a class="el" href="MachineSink_8cpp.html#a359e1ff26f6d466d927a61aae45b05c3">Reg</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6cf855363122e65fd4e6f2df1d16aba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows targets to use appropriate copy instruction while spilitting live range of a register in register allocation.  <br /></td></tr>
<tr class="separator:a6cf855363122e65fd4e6f2df1d16aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804530332064e8450f5c01c1291e3ec8" id="r_a804530332064e8450f5c01c1291e3ec8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a804530332064e8450f5c01c1291e3ec8">createPHIDestinationCopy</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> InsPt, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#ad467c4ab9119043f9b7750ab986be61a">DL</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> Src, <a class="el" href="classllvm_1_1Register.html">Register</a> Dst) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a804530332064e8450f5c01c1291e3ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">During PHI eleimination lets target to make necessary checks and insert the copy to the PHI destination register in a target specific manner.  <br /></td></tr>
<tr class="separator:a804530332064e8450f5c01c1291e3ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9cd5e2258e984d377933b695ccf39b" id="r_aaf9cd5e2258e984d377933b695ccf39b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf9cd5e2258e984d377933b695ccf39b">createPHISourceCopy</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> InsPt, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#ad467c4ab9119043f9b7750ab986be61a">DL</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> Src, <a class="el" href="classunsigned.html">unsigned</a> SrcSubReg, <a class="el" href="classllvm_1_1Register.html">Register</a> Dst) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aaf9cd5e2258e984d377933b695ccf39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">During PHI eleimination lets target to make necessary checks and insert the copy to the PHI destination register in a target specific manner.  <br /></td></tr>
<tr class="separator:aaf9cd5e2258e984d377933b695ccf39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bd21a4fb5df9bcff11eee0200dab0b" id="r_ac3bd21a4fb5df9bcff11eee0200dab0b"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="structllvm_1_1outliner_1_1OutlinedFunction.html">outliner::OutlinedFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3bd21a4fb5df9bcff11eee0200dab0b">getOutliningCandidateInfo</a> (std::vector&lt; <a class="el" href="structllvm_1_1outliner_1_1Candidate.html">outliner::Candidate</a> &gt; &amp;RepeatedSequenceLocs) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac3bd21a4fb5df9bcff11eee0200dab0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structllvm_1_1outliner_1_1OutlinedFunction.html" title="The information necessary to create an outlined function for some class of candidate.">outliner::OutlinedFunction</a></code> struct containing target-specific information for a set of outlining candidates.  <br /></td></tr>
<tr class="separator:ac3bd21a4fb5df9bcff11eee0200dab0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4253df7a10e437a01d42c223e196c0b8" id="r_a4253df7a10e437a01d42c223e196c0b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4253df7a10e437a01d42c223e196c0b8">mergeOutliningCandidateAttributes</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>, std::vector&lt; <a class="el" href="structllvm_1_1outliner_1_1Candidate.html">outliner::Candidate</a> &gt; &amp;Candidates) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a4253df7a10e437a01d42c223e196c0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional target hook to create the LLVM IR attributes for the outlined function.  <br /></td></tr>
<tr class="separator:a4253df7a10e437a01d42c223e196c0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3916a50b6bf4f9591b5b7fcd2ad356dd" id="r_a3916a50b6bf4f9591b5b7fcd2ad356dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm_1_1outliner.html#a0765e098fe7aae0f01b60ec890ac1b52">outliner::InstrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3916a50b6bf4f9591b5b7fcd2ad356dd">getOutliningType</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> &amp;MIT, <a class="el" href="classunsigned.html">unsigned</a> Flags) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a3916a50b6bf4f9591b5b7fcd2ad356dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how or if <code>MIT</code> should be outlined.  <br /></td></tr>
<tr class="separator:a3916a50b6bf4f9591b5b7fcd2ad356dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952e245a616622682cd83b1291314660" id="r_a952e245a616622682cd83b1291314660"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a952e245a616622682cd83b1291314660">isMBBSafeToOutlineFrom</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classunsigned.html">unsigned</a> &amp;Flags) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a952e245a616622682cd83b1291314660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional target hook that returns true if <code>MBB</code> is safe to outline from, and returns any target-specific information in <code>Flags</code>.  <br /></td></tr>
<tr class="separator:a952e245a616622682cd83b1291314660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0028f0ee9f737ba5290254b7924accbb" id="r_a0028f0ee9f737ba5290254b7924accbb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::pair&lt; <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0028f0ee9f737ba5290254b7924accbb">getOutlinableRanges</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classunsigned.html">unsigned</a> &amp;Flags) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0028f0ee9f737ba5290254b7924accbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional target hook which partitions <code>MBB</code> into outlinable ranges for instruction mapping purposes.  <br /></td></tr>
<tr class="separator:a0028f0ee9f737ba5290254b7924accbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e2b33837925c6898584bc1118f2f2a" id="r_a73e2b33837925c6898584bc1118f2f2a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73e2b33837925c6898584bc1118f2f2a">buildOutlinedFrame</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1outliner_1_1OutlinedFunction.html">outliner::OutlinedFunction</a> &amp;OF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a73e2b33837925c6898584bc1118f2f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a custom frame for outlined functions.  <br /></td></tr>
<tr class="separator:a73e2b33837925c6898584bc1118f2f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00242d76e808398358fa1e46e9a6885" id="r_ab00242d76e808398358fa1e46e9a6885"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab00242d76e808398358fa1e46e9a6885">insertOutlinedCall</a> (<a class="el" href="classllvm_1_1Module.html">Module</a> &amp;M, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> &amp;It, <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF, <a class="el" href="structllvm_1_1outliner_1_1Candidate.html">outliner::Candidate</a> &amp;<a class="el" href="namespacellvm_1_1CallingConv.html#ab5129f11389b3bfacaf2971bc558a90bafd841a49aec1539bc88abc8ff9e170fb">C</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab00242d76e808398358fa1e46e9a6885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a call to an outlined function into the program.  <br /></td></tr>
<tr class="separator:ab00242d76e808398358fa1e46e9a6885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5b9f0e5e1e90caa9c8def3d230ddbf" id="r_a0c5b9f0e5e1e90caa9c8def3d230ddbf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c5b9f0e5e1e90caa9c8def3d230ddbf">buildClearRegister</a> (<a class="el" href="classllvm_1_1Register.html">Register</a> <a class="el" href="MachineSink_8cpp.html#a359e1ff26f6d466d927a61aae45b05c3">Reg</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> Iter, <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#ad467c4ab9119043f9b7750ab986be61a">DL</a>, <a class="el" href="classbool.html">bool</a> AllowSideEffects=<a class="el" href="BasicAliasAnalysis_8cpp.html#af6d5cafbdfc5313e65d990120021a3ec">true</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0c5b9f0e5e1e90caa9c8def3d230ddbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an architecture-specific instruction to clear a register.  <br /></td></tr>
<tr class="separator:a0c5b9f0e5e1e90caa9c8def3d230ddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd9a0614742c8f6c8523b0c34b984ee" id="r_a6fd9a0614742c8f6c8523b0c34b984ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fd9a0614742c8f6c8523b0c34b984ee">isFunctionSafeToOutlineFrom</a> (<a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF, <a class="el" href="classbool.html">bool</a> OutlineFromLinkOnceODRs) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6fd9a0614742c8f6c8523b0c34b984ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the function can safely be outlined from.  <br /></td></tr>
<tr class="separator:a6fd9a0614742c8f6c8523b0c34b984ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de90c613673f0815ee6aa406f67390a" id="r_a2de90c613673f0815ee6aa406f67390a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2de90c613673f0815ee6aa406f67390a">shouldOutlineFromFunctionByDefault</a> (<a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a2de90c613673f0815ee6aa406f67390a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the function should be outlined from by default.  <br /></td></tr>
<tr class="separator:a2de90c613673f0815ee6aa406f67390a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b0cbf92a3dd0f5cab9d5d3067c2003" id="r_ae0b0cbf92a3dd0f5cab9d5d3067c2003"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0b0cbf92a3dd0f5cab9d5d3067c2003">isFunctionSafeToSplit</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae0b0cbf92a3dd0f5cab9d5d3067c2003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the function is a viable candidate for machine function splitting.  <br /></td></tr>
<tr class="separator:ae0b0cbf92a3dd0f5cab9d5d3067c2003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726928467271e18f3d17b2942cd04984" id="r_a726928467271e18f3d17b2942cd04984"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a726928467271e18f3d17b2942cd04984">isMBBSafeToSplitToCold</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;<a class="el" href="ARMSLSHardening_8cpp.html#a5958512eae2979bd2eb383977996a600">MBB</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a726928467271e18f3d17b2942cd04984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> can safely be split to the cold section.  <br /></td></tr>
<tr class="separator:a726928467271e18f3d17b2942cd04984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6885e40448874565521daac98e11f50d" id="r_a6885e40448874565521daac98e11f50d"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="namespacellvm.html#ad81cebfbef0742380b0227ae7000e0a3">ParamLoadedValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6885e40448874565521daac98e11f50d">describeLoadedValue</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1Register.html">Register</a> <a class="el" href="MachineSink_8cpp.html#a359e1ff26f6d466d927a61aae45b05c3">Reg</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6885e40448874565521daac98e11f50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the expression describing the <code>MI</code> loading a value into the physical register <code>Reg</code>.  <br /></td></tr>
<tr class="separator:a6885e40448874565521daac98e11f50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec0a63c3d6d45dd9fee9c1115816e0b" id="r_a0ec0a63c3d6d45dd9fee9c1115816e0b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ec0a63c3d6d45dd9fee9c1115816e0b">isExtendLikelyToBeFolded</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;ExtMI, <a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> &amp;<a class="el" href="AArch64AdvSIMDScalarPass_8cpp.html#aacd2ab195054a3e6a74bfbb9d5d571c8">MRI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0ec0a63c3d6d45dd9fee9c1115816e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the generic extension instruction <code>ExtMI</code>, returns true if this extension is a likely candidate for being folded into an another instruction.  <br /></td></tr>
<tr class="separator:a0ec0a63c3d6d45dd9fee9c1115816e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3492aff3468d2d229f1a093379fbdcf7" id="r_a3492aff3468d2d229f1a093379fbdcf7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MIRFormatter.html">MIRFormatter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3492aff3468d2d229f1a093379fbdcf7">getMIRFormatter</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a3492aff3468d2d229f1a093379fbdcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return MIR formatter to format/parse MIR operands.  <br /></td></tr>
<tr class="separator:a3492aff3468d2d229f1a093379fbdcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fbe2cfd4ac1e373cdaba16ec4a70b4" id="r_af1fbe2cfd4ac1e373cdaba16ec4a70b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1fbe2cfd4ac1e373cdaba16ec4a70b4">getTailDuplicateSize</a> (<a class="el" href="namespacellvm.html#a8ec1bf8d7b792ca9fac56f8514db18d2">CodeGenOptLevel</a> OptLevel) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af1fbe2cfd4ac1e373cdaba16ec4a70b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target-specific default value for tail duplication.  <br /></td></tr>
<tr class="separator:af1fbe2cfd4ac1e373cdaba16ec4a70b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acee94fe64ebb7dc672f6e5697fbe6b" id="r_a9acee94fe64ebb7dc672f6e5697fbe6b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9acee94fe64ebb7dc672f6e5697fbe6b">getTailMergeSize</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a9acee94fe64ebb7dc672f6e5697fbe6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target-specific default value for tail merging.  <br /></td></tr>
<tr class="separator:a9acee94fe64ebb7dc672f6e5697fbe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8b374c12bde7a8aa400ae5e34e6956" id="r_a9e8b374c12bde7a8aa400ae5e34e6956"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e8b374c12bde7a8aa400ae5e34e6956">getCalleeOperand</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a9e8b374c12bde7a8aa400ae5e34e6956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the callee operand from the given <code>MI</code>.  <br /></td></tr>
<tr class="separator:a9e8b374c12bde7a8aa400ae5e34e6956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b400bea2e0c5c1d17478053b5acdd3e" id="r_a9b400bea2e0c5c1d17478053b5acdd3e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacellvm.html#ae58c751054b01f206f9b9e34e461d25f">InstructionUniformity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b400bea2e0c5c1d17478053b5acdd3e">getInstructionUniformity</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a9b400bea2e0c5c1d17478053b5acdd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the uniformity behavior of the given instruction.  <br /></td></tr>
<tr class="separator:a9b400bea2e0c5c1d17478053b5acdd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87a4a6ef69b65a33d072718a8e0e25e" id="r_aa87a4a6ef69b65a33d072718a8e0e25e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa87a4a6ef69b65a33d072718a8e0e25e">isExplicitTargetIndexDef</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, int &amp;<a class="el" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>, int64_t &amp;<a class="el" href="namespacellvm.html#a05f5b9a11bdcc5feba62899f95dcf878a3134224cba2545bc57954d3b072aebb4">Offset</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa87a4a6ef69b65a33d072718a8e0e25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>MI</code> defines a TargetIndex operand that can be tracked by their offset, can have values, and can have debug info associated with it.  <br /></td></tr>
<tr class="separator:aa87a4a6ef69b65a33d072718a8e0e25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e324da740d76918b3f2b2ecf807e49" id="r_a89e324da740d76918b3f2b2ecf807e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89e324da740d76918b3f2b2ecf807e49">getCallFrameSizeAt</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a89e324da740d76918b3f2b2ecf807e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d10b938465726d85e01bbb669e184d0" id="r_a0d10b938465726d85e01bbb669e184d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d10b938465726d85e01bbb669e184d0">getFrameIndexOperands</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;Ops, int FI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0d10b938465726d85e01bbb669e184d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills in the necessary MachineOperands to refer to a frame index.  <br /></td></tr>
<tr class="separator:a0d10b938465726d85e01bbb669e184d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cbdb78a500dfae42d591bb8d00b557" id="r_af6cbdb78a500dfae42d591bb8d00b557"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6cbdb78a500dfae42d591bb8d00b557">getUndefInitOpcode</a> (<a class="el" href="classunsigned.html">unsigned</a> RegClassID) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af6cbdb78a500dfae42d591bb8d00b557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the opcode for the Pseudo <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> used to initialize the undef value.  <br /></td></tr>
<tr class="separator:af6cbdb78a500dfae42d591bb8d00b557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classllvm_1_1MCInstrInfo"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classllvm_1_1MCInstrInfo')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classllvm_1_1MCInstrInfo.html">llvm::MCInstrInfo</a></td></tr>
<tr class="memitem:aeece82f0c3a3f34f46484c8857eee3ed inherit pub_methods_classllvm_1_1MCInstrInfo" id="r_aeece82f0c3a3f34f46484c8857eee3ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MCInstrInfo.html#aeece82f0c3a3f34f46484c8857eee3ed">InitMCInstrInfo</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MCInstrDesc.html">MCInstrDesc</a> *<a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classunsigned.html">unsigned</a> *NI, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> *ND, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> uint8_t *<a class="el" href="Debugify_8cpp.html#a9e8fa29f7cb6a03aa586afae7591f6cc">DF</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MCInstrInfo.html#a706bb246bd165a88f89a084058e89c2e">ComplexDeprecationPredicate</a> *CDI, <a class="el" href="classunsigned.html">unsigned</a> NO)</td></tr>
<tr class="memdesc:aeece82f0c3a3f34f46484c8857eee3ed inherit pub_methods_classllvm_1_1MCInstrInfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <a class="el" href="classllvm_1_1MCInstrInfo.html" title="Interface to description of machine instruction set.">MCInstrInfo</a>, called by <a class="el" href="namespacellvm_1_1TableGen.html">TableGen</a> auto-generated routines.  <br /></td></tr>
<tr class="separator:aeece82f0c3a3f34f46484c8857eee3ed inherit pub_methods_classllvm_1_1MCInstrInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8533f8fd8cabba0d3eb8c1fc7f1c73b4 inherit pub_methods_classllvm_1_1MCInstrInfo" id="r_a8533f8fd8cabba0d3eb8c1fc7f1c73b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MCInstrInfo.html#a8533f8fd8cabba0d3eb8c1fc7f1c73b4">getNumOpcodes</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a8533f8fd8cabba0d3eb8c1fc7f1c73b4 inherit pub_methods_classllvm_1_1MCInstrInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176ca2c9108a997dcfd8aadf4c0f0fa0 inherit pub_methods_classllvm_1_1MCInstrInfo" id="r_a176ca2c9108a997dcfd8aadf4c0f0fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MCInstrDesc.html">MCInstrDesc</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MCInstrInfo.html#a176ca2c9108a997dcfd8aadf4c0f0fa0">get</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a176ca2c9108a997dcfd8aadf4c0f0fa0 inherit pub_methods_classllvm_1_1MCInstrInfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the machine instruction descriptor that corresponds to the specified instruction opcode.  <br /></td></tr>
<tr class="separator:a176ca2c9108a997dcfd8aadf4c0f0fa0 inherit pub_methods_classllvm_1_1MCInstrInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbb44946a6951b5d90dd5313023156f inherit pub_methods_classllvm_1_1MCInstrInfo" id="r_abdbb44946a6951b5d90dd5313023156f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MCInstrInfo.html#abdbb44946a6951b5d90dd5313023156f">getName</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:abdbb44946a6951b5d90dd5313023156f inherit pub_methods_classllvm_1_1MCInstrInfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name for the instructions with the given opcode.  <br /></td></tr>
<tr class="separator:abdbb44946a6951b5d90dd5313023156f inherit pub_methods_classllvm_1_1MCInstrInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c570149fbd98b77ba4944f29216a6ec inherit pub_methods_classllvm_1_1MCInstrInfo" id="r_a7c570149fbd98b77ba4944f29216a6ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MCInstrInfo.html#a7c570149fbd98b77ba4944f29216a6ec">getDeprecatedInfo</a> (<a class="el" href="classllvm_1_1MCInst.html">MCInst</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MCSubtargetInfo.html">MCSubtargetInfo</a> &amp;STI, std::string &amp;<a class="el" href="CSEInfo_8cpp.html#a75f8a8519c2c9b30e7c06dc5e256fffa">Info</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7c570149fbd98b77ba4944f29216a6ec inherit pub_methods_classllvm_1_1MCInstrInfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a certain instruction is deprecated and if so returns the reason in <code>Info</code>.  <br /></td></tr>
<tr class="separator:a7c570149fbd98b77ba4944f29216a6ec inherit pub_methods_classllvm_1_1MCInstrInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a82a499274493eca235e684f82ee54b70" id="r_a82a499274493eca235e684f82ee54b70"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82a499274493eca235e684f82ee54b70">isGenericOpcode</a> (<a class="el" href="classunsigned.html">unsigned</a> Opc)</td></tr>
<tr class="separator:a82a499274493eca235e684f82ee54b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60fd4c7626ec53d75182d6f54743745" id="r_ae60fd4c7626ec53d75182d6f54743745"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae60fd4c7626ec53d75182d6f54743745">isGenericAtomicRMWOpcode</a> (<a class="el" href="classunsigned.html">unsigned</a> Opc)</td></tr>
<tr class="separator:ae60fd4c7626ec53d75182d6f54743745"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae73e2be2b66dc9e4f2f90d56076d7ea9" id="r_ae73e2be2b66dc9e4f2f90d56076d7ea9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae73e2be2b66dc9e4f2f90d56076d7ea9">CommuteAnyOperandIndex</a> = ~0U</td></tr>
<tr class="separator:ae73e2be2b66dc9e4f2f90d56076d7ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab671544f7af287b25a5e612f6e919975" id="r_ab671544f7af287b25a5e612f6e919975"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab671544f7af287b25a5e612f6e919975">isReallyTriviallyReMaterializable</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab671544f7af287b25a5e612f6e919975"><td class="mdescLeft">&#160;</td><td class="mdescRight">For instructions with opcodes for which the M_REMATERIALIZABLE flag is set, this hook lets the target specify whether the instruction is actually trivially rematerializable, taking into consideration its operands.  <br /></td></tr>
<tr class="separator:ab671544f7af287b25a5e612f6e919975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4d05c8ea2fc82ae12300ef5fb48951" id="r_adf4d05c8ea2fc82ae12300ef5fb48951"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf4d05c8ea2fc82ae12300ef5fb48951">commuteInstructionImpl</a> (<a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classbool.html">bool</a> NewMI, <a class="el" href="classunsigned.html">unsigned</a> OpIdx1, <a class="el" href="classunsigned.html">unsigned</a> OpIdx2) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:adf4d05c8ea2fc82ae12300ef5fb48951"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method commutes the operands of the given machine instruction MI.  <br /></td></tr>
<tr class="separator:adf4d05c8ea2fc82ae12300ef5fb48951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb5f369839e0987506e72b0ffc1b982" id="r_a7eb5f369839e0987506e72b0ffc1b982"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="structllvm_1_1DestSourcePair.html">DestSourcePair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eb5f369839e0987506e72b0ffc1b982">isCopyInstrImpl</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7eb5f369839e0987506e72b0ffc1b982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target-dependent implementation for IsCopyInstr.  <br /></td></tr>
<tr class="separator:a7eb5f369839e0987506e72b0ffc1b982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cf72d93ee18d693c7a74f0c1307cea" id="r_a13cf72d93ee18d693c7a74f0c1307cea"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="structllvm_1_1DestSourcePair.html">DestSourcePair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13cf72d93ee18d693c7a74f0c1307cea">isCopyLikeInstrImpl</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a13cf72d93ee18d693c7a74f0c1307cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47bacdac90d2744684f980e1ad40594" id="r_ae47bacdac90d2744684f980e1ad40594"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae47bacdac90d2744684f980e1ad40594">isUnspillableTerminatorImpl</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae47bacdac90d2744684f980e1ad40594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given terminator MI is not expected to spill.  <br /></td></tr>
<tr class="separator:ae47bacdac90d2744684f980e1ad40594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1e73b39957ad3da60cb9d3a690df89" id="r_a0a1e73b39957ad3da60cb9d3a690df89"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a1e73b39957ad3da60cb9d3a690df89">foldMemoryOperandImpl</a> (<a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; Ops, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> InsertPt, int FrameIndex, <a class="el" href="classllvm_1_1LiveIntervals.html">LiveIntervals</a> *LIS=nullptr, <a class="el" href="classllvm_1_1VirtRegMap.html">VirtRegMap</a> *VRM=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0a1e73b39957ad3da60cb9d3a690df89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target-dependent implementation for foldMemoryOperand.  <br /></td></tr>
<tr class="separator:a0a1e73b39957ad3da60cb9d3a690df89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f87b0480bb0e4d689f7b3cf2aa88a1" id="r_af4f87b0480bb0e4d689f7b3cf2aa88a1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4f87b0480bb0e4d689f7b3cf2aa88a1">foldMemoryOperandImpl</a> (<a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;MF, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; Ops, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> InsertPt, <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;LoadMI, <a class="el" href="classllvm_1_1LiveIntervals.html">LiveIntervals</a> *LIS=nullptr) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af4f87b0480bb0e4d689f7b3cf2aa88a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target-dependent implementation for foldMemoryOperand.  <br /></td></tr>
<tr class="separator:af4f87b0480bb0e4d689f7b3cf2aa88a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e026925b73de52f7a563693ebff007" id="r_a52e026925b73de52f7a563693ebff007"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52e026925b73de52f7a563693ebff007">getRegSequenceLikeInputs</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> DefIdx, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &gt; &amp;InputRegs) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a52e026925b73de52f7a563693ebff007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target-dependent implementation of getRegSequenceInputs.  <br /></td></tr>
<tr class="separator:a52e026925b73de52f7a563693ebff007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c44734f854fb7f620d16097f2af637" id="r_af1c44734f854fb7f620d16097f2af637"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1c44734f854fb7f620d16097f2af637">getExtractSubregLikeInputs</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> DefIdx, <a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &amp;InputReg) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af1c44734f854fb7f620d16097f2af637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target-dependent implementation of getExtractSubregInputs.  <br /></td></tr>
<tr class="separator:af1c44734f854fb7f620d16097f2af637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b51d2dd19b3859797509c03d5f451f1" id="r_a2b51d2dd19b3859797509c03d5f451f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b51d2dd19b3859797509c03d5f451f1">getInsertSubregLikeInputs</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;<a class="el" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>, <a class="el" href="classunsigned.html">unsigned</a> DefIdx, <a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPair.html">RegSubRegPair</a> &amp;BaseReg, <a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &amp;InsertedReg) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a2b51d2dd19b3859797509c03d5f451f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target-dependent implementation of getInsertSubregInputs.  <br /></td></tr>
<tr class="separator:a2b51d2dd19b3859797509c03d5f451f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6616508bb5d488d06f8122df46e3930c" id="r_a6616508bb5d488d06f8122df46e3930c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacellvm_1_1outliner.html#a0765e098fe7aae0f01b60ec890ac1b52">outliner::InstrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6616508bb5d488d06f8122df46e3930c">getOutliningTypeImpl</a> (<a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> &amp;MIT, <a class="el" href="classunsigned.html">unsigned</a> Flags) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6616508bb5d488d06f8122df46e3930c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target-dependent implementation for getOutliningTypeImpl.  <br /></td></tr>
<tr class="separator:a6616508bb5d488d06f8122df46e3930c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:aef5b8db7ddf8b00b66e4f64711a053cd" id="r_aef5b8db7ddf8b00b66e4f64711a053cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef5b8db7ddf8b00b66e4f64711a053cd">fixCommutedOpIndices</a> (<a class="el" href="classunsigned.html">unsigned</a> &amp;ResultIdx1, <a class="el" href="classunsigned.html">unsigned</a> &amp;ResultIdx2, <a class="el" href="classunsigned.html">unsigned</a> CommutableOpIdx1, <a class="el" href="classunsigned.html">unsigned</a> CommutableOpIdx2)</td></tr>
<tr class="memdesc:aef5b8db7ddf8b00b66e4f64711a053cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the (CommutableOpIdx1, CommutableOpIdx2) pair of commutable operand indices to (ResultIdx1, ResultIdx2).  <br /></td></tr>
<tr class="separator:aef5b8db7ddf8b00b66e4f64711a053cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classllvm_1_1MCInstrInfo"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classllvm_1_1MCInstrInfo')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classllvm_1_1MCInstrInfo.html">llvm::MCInstrInfo</a></td></tr>
<tr class="memitem:a706bb246bd165a88f89a084058e89c2e inherit pub_types_classllvm_1_1MCInstrInfo" id="r_a706bb246bd165a88f89a084058e89c2e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MCInstrInfo.html#a706bb246bd165a88f89a084058e89c2e">ComplexDeprecationPredicate</a></td></tr>
<tr class="separator:a706bb246bd165a88f89a084058e89c2e inherit pub_types_classllvm_1_1MCInstrInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classllvm_1_1TargetInstrInfo.html" title="TargetInstrInfo - Interface to description of machine instruction set.">TargetInstrInfo</a> - Interface to description of machine instruction set. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00111">111</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab0ea1fe6f61d0e861ed2be7632a270bb" name="ab0ea1fe6f61d0e861ed2be7632a270bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ea1fe6f61d0e861ed2be7632a270bb">&#9670;&#160;</a></span>TargetInstrInfo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::TargetInstrInfo::TargetInstrInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>CFSetupOpcode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">~0u</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>CFDestroyOpcode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">~0u</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>CatchRetOpcode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">~0u</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ReturnOpcode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">~0u</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00113">113</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="abfc72b67ab4a799ac5472bb3ca3250fc" name="abfc72b67ab4a799ac5472bb3ca3250fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc72b67ab4a799ac5472bb3ca3250fc">&#9670;&#160;</a></span>TargetInstrInfo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::TargetInstrInfo::TargetInstrInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetInstrInfo.html">TargetInstrInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2c402f5f405a15e3356949d3d1900c3" name="ac2c402f5f405a15e3356949d3d1900c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c402f5f405a15e3356949d3d1900c3">&#9670;&#160;</a></span>~TargetInstrInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TargetInstrInfo::~TargetInstrInfo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acd6b72b3ba59a29cb680b5f00831a7b6" name="acd6b72b3ba59a29cb680b5f00831a7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6b72b3ba59a29cb680b5f00831a7b6">&#9670;&#160;</a></span>accumulateInstrSeqToRootLatency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::accumulateInstrSeqToRootLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Root</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When calculate the latency of the root instruction, accumulate the latency of the sequence to the root latency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Root</td><td>- <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> that could be combined with one of its operands </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01295">1295</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a0dfb0c744373d4b6112eb343a5b07fc7" name="a0dfb0c744373d4b6112eb343a5b07fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfb0c744373d4b6112eb343a5b07fc7">&#9670;&#160;</a></span>analyzeBranch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::analyzeBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>TBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>FBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowModify</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyze the branching code at the end of MBB, returning true if it cannot be understood (e.g. </p>
<p>it's a switch dispatch or isn't implemented for a target). Upon success, this returns false and returns with the following information in various cases:</p>
<ol type="1">
<li>If this block ends with no branches (it just falls through to its succ) just return false, leaving TBB/FBB null.</li>
<li>If this block ends with only an unconditional branch, it sets TBB to be the destination block.</li>
<li>If this block ends with a conditional branch and it falls through to a successor block, it sets TBB to be the branch destination block and a list of operands that evaluate the condition. These operands can be passed to other <a class="el" href="classllvm_1_1TargetInstrInfo.html" title="TargetInstrInfo - Interface to description of machine instruction set.">TargetInstrInfo</a> methods to create new branches.</li>
<li>If this block ends with a conditional branch followed by an unconditional branch, it returns the 'true' destination in TBB, the 'false' destination in FBB, and a list of operands that evaluate the condition. These operands can be passed to other <a class="el" href="classllvm_1_1TargetInstrInfo.html" title="TargetInstrInfo - Interface to description of machine instruction set.">TargetInstrInfo</a> methods to create new branches.</li>
</ol>
<p>Note that removeBranch and insertBranch must be implemented to support cases where this method returns success.</p>
<p>If AllowModify is true, then this routine is allowed to modify the basic block (e.g. delete instructions after the unconditional branch).</p>
<p>The CFG information in MBB.Predecessors and MBB.Successors must be valid before calling this function. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00650">650</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TailDuplicator_8cpp_source.html#l00811">llvm::TailDuplicator::canTailDuplicate()</a>, and <a class="el" href="TailDuplicator_8cpp_source.html#l00565">llvm::TailDuplicator::shouldTailDuplicate()</a>.</p>

</div>
</div>
<a id="a2b3f813a206819029043906eedccc502" name="a2b3f813a206819029043906eedccc502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3f813a206819029043906eedccc502">&#9670;&#160;</a></span>analyzeBranchPredicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::analyzeBranchPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetInstrInfo_1_1MachineBranchPredicate.html">MachineBranchPredicate</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowModify</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyze the branching code at the end of MBB and parse it into the <a class="el" href="structllvm_1_1TargetInstrInfo_1_1MachineBranchPredicate.html" title="Represents a predicate at the MachineFunction level.">MachineBranchPredicate</a> structure if possible. </p>
<p>Returns false on success and true on failure.</p>
<p>If AllowModify is true, then this routine is allowed to modify the basic block (e.g. delete instructions after the unconditional branch). </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00692">692</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="af90a0ce256d5ae1e1181b032da5d2779" name="af90a0ce256d5ae1e1181b032da5d2779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90a0ce256d5ae1e1181b032da5d2779">&#9670;&#160;</a></span>analyzeCompare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::analyzeCompare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SrcReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SrcReg2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>Mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>Value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a comparison instruction, return the source registers in SrcReg and SrcReg2 if having two register operands, and the value it compares against in CmpValue. </p>
<p>Return true if the comparison instruction can be analyzed. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01712">1712</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a951ed5729e865521d99c1b7bf2e4e4a2" name="a951ed5729e865521d99c1b7bf2e4e4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951ed5729e865521d99c1b7bf2e4e4a2">&#9670;&#160;</a></span>analyzeLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::analyzeLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineLoop.html">MachineLoop</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>IndVarInst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>CmpInst</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyze the loop code, return true if it cannot be understood. </p>
<p>Upon success, this function returns false and returns information about the induction variable and compare instruction used at the end. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00819">819</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a047bd8fdcc19cf2047e947ca565ff8fc" name="a047bd8fdcc19cf2047e947ca565ff8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047bd8fdcc19cf2047e947ca565ff8fc">&#9670;&#160;</a></span>analyzeLoopForPipelining()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classllvm_1_1TargetInstrInfo_1_1PipelinerLoopInfo.html">PipelinerLoopInfo</a> &gt; llvm::TargetInstrInfo::analyzeLoopForPipelining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>LoopBB</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyze loop L, which must be a single-basic-block loop, and if the conditions can be understood enough produce a <a class="el" href="classllvm_1_1TargetInstrInfo_1_1PipelinerLoopInfo.html" title="Object returned by analyzeLoopForPipelining.">PipelinerLoopInfo</a> object. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00812">812</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="WindowScheduler_8cpp_source.html#l00173">llvm::WindowScheduler::initialize()</a>.</p>

</div>
</div>
<a id="ad0e13c52b664b67847a458ba5e6f9009" name="ad0e13c52b664b67847a458ba5e6f9009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e13c52b664b67847a458ba5e6f9009">&#9670;&#160;</a></span>analyzeSelect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::analyzeSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>TrueOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>FalseOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Optimizable</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyze the given select instruction, returning true if it cannot be understood. </p>
<p>It is assumed that MI-&gt;isSelect() is true.</p>
<p>When successful, return the controlling condition and the operands that determine the true and false result values.</p>
<p>Result = SELECT Cond, TrueOp, FalseOp</p>
<p>Some targets can optimize select instructions, for example by predicating the instruction defining one of the operands. Such targets should set Optimizable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MI</td><td>Select instruction to analyze. </td></tr>
    <tr><td class="paramname">Cond</td><td>Condition controlling the select. </td></tr>
    <tr><td class="paramname">TrueOp</td><td>Operand number of the value selected when Cond is true. </td></tr>
    <tr><td class="paramname">FalseOp</td><td>Operand number of the value selected when Cond is false. </td></tr>
    <tr><td class="paramname">Optimizable</td><td>Returned as true if MI is optimizable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False on success. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00982">982</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="af6ae1d6ce8dc191d8300c25b3e287961" name="af6ae1d6ce8dc191d8300c25b3e287961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ae1d6ce8dc191d8300c25b3e287961">&#9670;&#160;</a></span>areLoadsFromSameBasePtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::areLoadsFromSameBasePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>Load1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>Load2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>Offset1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>Offset2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is used by the pre-regalloc scheduler to determine if two loads are loading from the same base address. </p>
<p>It should only return true if the base pointers are the same and the only differences between the two addresses are the offset. It also returns the offsets by reference. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01444">1444</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a5f8ea6535c262fbc8a16177783020314" name="a5f8ea6535c262fbc8a16177783020314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8ea6535c262fbc8a16177783020314">&#9670;&#160;</a></span>areMemAccessesTriviallyDisjoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::areMemAccessesTriviallyDisjoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MIa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MIb</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sometimes, it is possible for the target to tell, even without aliasing information, that two MIs access different memory addresses. </p>
<p>This function returns true if two MIs access different memory addresses and false otherwise.</p>
<p>Assumes any physical registers used to compute addresses have the same value for both instructions. (This is the most useful assumption for post-RA scheduling.)</p>
<p>See also <a class="el" href="classllvm_1_1MachineInstr.html#a55aec6d9959470668bae2aeb8a7c0768" title="Returns true if this instruction&#39;s memory access aliases the memory access of Other.">MachineInstr::mayAlias</a>, which is implemented on top of this function. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01964">1964</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="MachineInstr_8h_source.html#l01159">llvm::MachineInstr::mayLoadOrStore()</a>.</p>

</div>
</div>
<a id="a29e545675db8b534aec8eccb7bedb2ee" name="a29e545675db8b534aec8eccb7bedb2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e545675db8b534aec8eccb7bedb2ee">&#9670;&#160;</a></span>areOpcodesEqualOrInverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::areOpcodesEqualOrInverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true when \P Opcode1 or its inversion is equal to \P Opcode2. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00852">852</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l01261">getInverseOpcode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00954">getReassociationOpcodes()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l00857">hasReassociableSibling()</a>.</p>

</div>
</div>
<a id="a525a9aaabc1362deb245b0099ea5538e" name="a525a9aaabc1362deb245b0099ea5538e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525a9aaabc1362deb245b0099ea5538e">&#9670;&#160;</a></span>breakPartialRegDependency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::breakPartialRegDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>OpNum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a dependency-breaking instruction before MI to eliminate an unwanted dependency on OpNum. </p>
<p>If it wasn't possible to avoid a def in the last N instructions before MI (see getPartialRegUpdateClearance), this hook will be called to break the unwanted dependency.</p>
<p>On x86, an xorps instruction can be used as a dependency breaker:</p>
<p>addps xmm1, xmm0 movaps xmm0, (rax) xorps xmm0, xmm0 cvtsi2ss rbx, xmm0</p>
<p>An &lt;imp-kill&gt; operand should be added to MI if an instruction was inserted. This ties the instructions together in the post-ra scheduler. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01943">1943</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a0c5b9f0e5e1e90caa9c8def3d230ddbf" name="a0c5b9f0e5e1e90caa9c8def3d230ddbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5b9f0e5e1e90caa9c8def3d230ddbf">&#9670;&#160;</a></span>buildClearRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::buildClearRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>Iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DL</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowSideEffects</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="BasicAliasAnalysis_8cpp.html#af6d5cafbdfc5313e65d990120021a3ec">true</a></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an architecture-specific instruction to clear a register. </p>
<p>If you need to avoid sideeffects (e.g. avoid XOR on x86, which sets EFLAGS), set <code>AllowSideEffects</code> to <code>false</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02162">2162</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="a73e2b33837925c6898584bc1118f2f2a" name="a73e2b33837925c6898584bc1118f2f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e2b33837925c6898584bc1118f2f2a">&#9670;&#160;</a></span>buildOutlinedFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::buildOutlinedFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1outliner_1_1OutlinedFunction.html">outliner::OutlinedFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OF</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a custom frame for outlined functions. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02142">2142</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="a7b8003a932104a6adf3ddbf4435a49f0" name="a7b8003a932104a6adf3ddbf4435a49f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8003a932104a6adf3ddbf4435a49f0">&#9670;&#160;</a></span>canCopyGluedNodeDuringSchedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::canCopyGluedNodeDuringSchedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the given <a class="el" href="classllvm_1_1SDNode.html" title="Represents one node in the SelectionDAG.">SDNode</a> can be copied during scheduling even if it has glue. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01340">1340</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a32583e70bd8c1b6ccb45a21129efac24" name="a32583e70bd8c1b6ccb45a21129efac24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32583e70bd8c1b6ccb45a21129efac24">&#9670;&#160;</a></span>canFoldIntoAddrMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::canFoldIntoAddrMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MemI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>AddrI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1ExtAddrMode.html">ExtAddrMode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>AM</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> if it's possible and beneficial to fold the addressing computation <code>AddrI</code> into the addressing mode of the load/store instruction <code>MemI</code>. </p>
<p>The memory instruction is a user of the virtual register <code>Reg</code>, which in turn is the ultimate destination of zero or more COPY instructions from the output register of <code>AddrI</code>. Return the adddressing mode after folding in <code>AM</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01515">1515</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="ae0990ac346653cb1c820f391ffbf5ed5" name="ae0990ac346653cb1c820f391ffbf5ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0990ac346653cb1c820f391ffbf5ed5">&#9670;&#160;</a></span>canInsertSelect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::canInsertSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>DstReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>TrueReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>FalseReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>CondCycles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>TrueCycles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>FalseCycles</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if it is possible to insert a select instruction that chooses between TrueReg and FalseReg based on the condition code in Cond. </p>
<p>When successful, also return the latency in cycles from TrueReg, FalseReg, and Cond to the destination register. In most cases, a select instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1</p>
<p>Some x86 implementations have 2-cycle cmov instructions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MBB</td><td>Block where select instruction would be inserted. </td></tr>
    <tr><td class="paramname">Cond</td><td>Condition returned by analyzeBranch. </td></tr>
    <tr><td class="paramname">DstReg</td><td>Virtual dest register that the result should write to. </td></tr>
    <tr><td class="paramname">TrueReg</td><td>Virtual register to select when Cond is true. </td></tr>
    <tr><td class="paramname">FalseReg</td><td>Virtual register to select when Cond is false. </td></tr>
    <tr><td class="paramname">CondCycles</td><td>Latency from Cond+Branch to select output. </td></tr>
    <tr><td class="paramname">TrueCycles</td><td>Latency from TrueReg to select output. </td></tr>
    <tr><td class="paramname">FalseCycles</td><td>Latency from FalseReg to select output. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00934">934</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a163e14d44765e368d3a79ceea6d00eaa" name="a163e14d44765e368d3a79ceea6d00eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163e14d44765e368d3a79ceea6d00eaa">&#9670;&#160;</a></span>canMakeTailCallConditional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::canMakeTailCallConditional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>TailCall</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the tail call can be made conditional on BranchCond. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01617">1617</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a0a593a2fa65858fcd920bd782108c999" name="a0a593a2fa65858fcd920bd782108c999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a593a2fa65858fcd920bd782108c999">&#9670;&#160;</a></span>canPredicatePredicatedInstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::canPredicatePredicatedInstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assumes the instruction is already predicated and returns true if the instruction can be predicated again. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01597">1597</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01593">isPredicated()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="a0695148f396023fb3cf404a5447a2412" name="a0695148f396023fb3cf404a5447a2412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0695148f396023fb3cf404a5447a2412">&#9670;&#160;</a></span>ClobbersPredicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::ClobbersPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>SkipDead</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the specified instruction defines any predicate or condition code register(s) used for predication, returns true as well as the definition predicate(s) by reference. </p>
<p>SkipDead should be set to false at any point that dead predicate instructions should be considered as being defined. A dead predicate instruction is one that is guaranteed to be removed after a call to PredicateInstruction. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01648">1648</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="aa41720cc33b0511709c92abcb164a59d" name="aa41720cc33b0511709c92abcb164a59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41720cc33b0511709c92abcb164a59d">&#9670;&#160;</a></span>commuteInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * TargetInstrInfo::commuteInstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>NewMI</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>OpIdx1</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae73e2be2b66dc9e4f2f90d56076d7ea9">CommuteAnyOperandIndex</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>OpIdx2</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae73e2be2b66dc9e4f2f90d56076d7ea9">CommuteAnyOperandIndex</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method commutes the operands of the given machine instruction MI. </p>
<p>The operands to be commuted are specified by their indices OpIdx1 and OpIdx2. OpIdx1 and OpIdx2 arguments may be set to a special value 'CommuteAnyOperandIndex', which means that the method is free to choose any arbitrarily chosen commutable operand. If both arguments are set to 'CommuteAnyOperandIndex' then the method looks for 2 different commutable operands; then commutes them if such operands could be found.</p>
<p>If NewMI is false, MI is modified in place and returned; otherwise, a new machine instruction is created and returned.</p>
<p>Do not call this method for a non-commutable instruction or for non-commuable operands. Even though the instruction is commutable, the method may still fail to commute the operands, null pointer is returned in such cases. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00249">249</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00450">CommuteAnyOperandIndex</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00168">commuteInstructionImpl()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00295">findCommutedOpIndices()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="adf4d05c8ea2fc82ae12300ef5fb48951" name="adf4d05c8ea2fc82ae12300ef5fb48951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4d05c8ea2fc82ae12300ef5fb48951">&#9670;&#160;</a></span>commuteInstructionImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * TargetInstrInfo::commuteInstructionImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>NewMI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>OpIdx1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>OpIdx2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method commutes the operands of the given machine instruction MI. </p>
<p>The operands to be commuted are specified by their indices OpIdx1 and OpIdx2.</p>
<p>If a target has any instructions that are commutable but require converting to different instructions or making non-trivial changes to commute them, this method can be overloaded to do that. The default implementation simply swaps the commutable operands.</p>
<p>If NewMI is false, MI is modified in place and returned; otherwise, a new machine instruction is created and returned.</p>
<p>Do not call this method for a non-commutable instruction. Even though the instruction is commutable, the method may still fail to commute the operands, null pointer is returned in such cases. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00168">168</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00295">findCommutedOpIndices()</a>, <a class="el" href="MCInstrDesc_8h_source.html#l00248">llvm::MCInstrDesc::getNumDefs()</a>, <a class="el" href="MachineInstr_8h_source.html#l00579">llvm::MachineInstr::getOperand()</a>, <a class="el" href="Register_8h_source.html#l00095">llvm::Register::isPhysical()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="Mem2Reg_8cpp_source.html#l00110">Register</a>, <a class="el" href="MachineOperand_8h_source.html#l00537">llvm::MachineOperand::setIsInternalRead()</a>, <a class="el" href="MachineOperand_8h_source.html#l00519">llvm::MachineOperand::setIsKill()</a>, <a class="el" href="MachineOperand_8cpp_source.html#l00142">llvm::MachineOperand::setIsRenamable()</a>, <a class="el" href="MachineOperand_8h_source.html#l00530">llvm::MachineOperand::setIsUndef()</a>, <a class="el" href="MachineOperand_8cpp_source.html#l00061">llvm::MachineOperand::setReg()</a>, <a class="el" href="MachineOperand_8h_source.html#l00490">llvm::MachineOperand::setSubReg()</a>, and <a class="el" href="MCInstrDesc_8h_source.html#l00036">llvm::MCOI::TIED_TO</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00249">commuteInstruction()</a>, <a class="el" href="ARMBaseInstrInfo_8cpp_source.html#l02256">llvm::ARMBaseInstrInfo::commuteInstructionImpl()</a>, <a class="el" href="PPCInstrInfo_8cpp_source.html#l01131">llvm::PPCInstrInfo::commuteInstructionImpl()</a>, <a class="el" href="RISCVInstrInfo_8cpp_source.html#l03336">llvm::RISCVInstrInfo::commuteInstructionImpl()</a>, <a class="el" href="SIInstrInfo_8cpp_source.html#l02768">llvm::SIInstrInfo::commuteInstructionImpl()</a>, <a class="el" href="SystemZInstrInfo_8cpp_source.html#l00290">llvm::SystemZInstrInfo::commuteInstructionImpl()</a>, <a class="el" href="WebAssemblyInstrInfo_8cpp_source.html#l00075">llvm::WebAssemblyInstrInfo::commuteInstructionImpl()</a>, and <a class="el" href="X86InstrInfo_8cpp_source.html#l02283">llvm::X86InstrInfo::commuteInstructionImpl()</a>.</p>

</div>
</div>
<a id="ada0a8cb9a764d058a63b77d50e9c0787" name="ada0a8cb9a764d058a63b77d50e9c0787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0a8cb9a764d058a63b77d50e9c0787">&#9670;&#160;</a></span>convertToThreeAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * llvm::TargetInstrInfo::convertToThreeAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LiveVariables.html">LiveVariables</a> *</td>          <td class="paramname"><span class="paramname"><em>LV</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LiveIntervals.html">LiveIntervals</a> *</td>          <td class="paramname"><span class="paramname"><em>LIS</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method must be implemented by targets that set the M_CONVERTIBLE_TO_3_ADDR flag. </p>
<p>When this flag is set, the target may be able to convert a two-address instruction into one or more true three-address instructions on demand. This allows the <a class="el" href="namespacellvm_1_1X86.html" title="Define some predicates that are used for node matching.">X86</a> target (for example) to convert ADD and SHL instructions into LEA instructions if they would require register copies due to two-addressness.</p>
<p>This method returns a null pointer if the transformation cannot be performed, otherwise it returns the last new instruction.</p>
<p>If <code>LIS</code> is not nullptr, the <a class="el" href="classllvm_1_1LiveIntervals.html">LiveIntervals</a> info should be updated for replacing <code>MI</code> with new instructions, even though this function does not remove MI. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00440">440</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a5e3084582ccac0f7bfb05582b5be402f" name="a5e3084582ccac0f7bfb05582b5be402f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3084582ccac0f7bfb05582b5be402f">&#9670;&#160;</a></span>copyPhysReg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::copyPhysReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DL</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MCRegister.html">MCRegister</a></td>          <td class="paramname"><span class="paramname"><em>DestReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MCRegister.html">MCRegister</a></td>          <td class="paramname"><span class="paramname"><em>SrcReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>KillSrc</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit instructions to copy a pair of physical registers. </p>
<p>This function should support copies within any legal register class as well as any cross-class copies created during instruction selection.</p>
<p>The source and destination registers may overlap, which may require a careful implementation when multiple copy instructions are required for large registers. See for example the <a class="el" href="namespacellvm_1_1ARM.html" title="Define some predicates that are used for node matching.">ARM</a> target. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01020">1020</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00800">lowerCopy()</a>.</p>

</div>
</div>
<a id="aea7fb8b18a37883f51af73238e47dea4" name="aea7fb8b18a37883f51af73238e47dea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7fb8b18a37883f51af73238e47dea4">&#9670;&#160;</a></span>createMIROperandComment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TargetInstrInfo::createMIROperandComment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>OpIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01732">1732</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="namespacellvm.html#a9eb4f5b98b70ee4fab9614ed58282c1fa7fb55ed0b7a30342ba6da306428cae04">llvm::First</a>, <a class="el" href="InlineAsm_8h_source.html#l00443">llvm::InlineAsm::getExtraInfoNames()</a>, <a class="el" href="InlineAsm_8h_source.html#l00467">llvm::InlineAsm::getMemConstraintName()</a>, <a class="el" href="CSEInfo_8cpp_source.html#l00027">Info</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="InlineAsm_8h_source.html#l00210">llvm::InlineAsm::MIOp_ExtraInfo</a>, <a class="el" href="SampleProfWriter_8cpp_source.html#l00053">OS</a>, and <a class="el" href="MachineSink_8cpp_source.html#l01928">TRI</a>.</p>

<p class="reference">Referenced by <a class="el" href="ARMBaseInstrInfo_8cpp_source.html#l00577">llvm::ARMBaseInstrInfo::createMIROperandComment()</a>, and <a class="el" href="RISCVInstrInfo_8cpp_source.html#l02970">llvm::RISCVInstrInfo::createMIROperandComment()</a>.</p>

</div>
</div>
<a id="a804530332064e8450f5c01c1291e3ec8" name="a804530332064e8450f5c01c1291e3ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804530332064e8450f5c01c1291e3ec8">&#9670;&#160;</a></span>createPHIDestinationCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * llvm::TargetInstrInfo::createPHIDestinationCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>InsPt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DL</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Dst</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During PHI eleimination lets target to make necessary checks and insert the copy to the PHI destination register in a target specific manner. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02069">2069</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="MachineInstrBuilder_8h_source.html#l00099">llvm::MachineInstrBuilder::addReg()</a>, <a class="el" href="MachineInstrBuilder_8h_source.html#l00373">llvm::BuildMI()</a>, <a class="el" href="ARMSLSHardening_8cpp_source.html#l00073">DL</a>, <a class="el" href="MCInstrInfo_8h_source.html#l00063">llvm::MCInstrInfo::get()</a>, and <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>.</p>

<p class="reference">Referenced by <a class="el" href="SIInstrInfo_8cpp_source.html#l09459">llvm::SIInstrInfo::createPHIDestinationCopy()</a>.</p>

</div>
</div>
<a id="aaf9cd5e2258e984d377933b695ccf39b" name="aaf9cd5e2258e984d377933b695ccf39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9cd5e2258e984d377933b695ccf39b">&#9670;&#160;</a></span>createPHISourceCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * llvm::TargetInstrInfo::createPHISourceCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>InsPt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DL</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>SrcSubReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Dst</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During PHI eleimination lets target to make necessary checks and insert the copy to the PHI destination register in a target specific manner. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02079">2079</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="MachineInstrBuilder_8h_source.html#l00099">llvm::MachineInstrBuilder::addReg()</a>, <a class="el" href="MachineInstrBuilder_8h_source.html#l00373">llvm::BuildMI()</a>, <a class="el" href="ARMSLSHardening_8cpp_source.html#l00073">DL</a>, <a class="el" href="MCInstrInfo_8h_source.html#l00063">llvm::MCInstrInfo::get()</a>, and <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>.</p>

<p class="reference">Referenced by <a class="el" href="SIInstrInfo_8cpp_source.html#l09474">llvm::SIInstrInfo::createPHISourceCopy()</a>.</p>

</div>
</div>
<a id="a7242b69b2f705111801d717e2ea243b5" name="a7242b69b2f705111801d717e2ea243b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7242b69b2f705111801d717e2ea243b5">&#9670;&#160;</a></span>CreateTargetHazardRecognizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ScheduleHazardRecognizer.html">ScheduleHazardRecognizer</a> * TargetInstrInfo::CreateTargetHazardRecognizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetSubtargetInfo.html">TargetSubtargetInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>STI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ScheduleDAG.html">ScheduleDAG</a> *</td>          <td class="paramname"><span class="paramname"><em>DAG</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and return a hazard recognizer to use for this target when scheduling the machine instructions before register allocation. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01403">1403</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ARMBaseInstrInfo_8cpp_source.html#l00130">llvm::ARMBaseInstrInfo::CreateTargetHazardRecognizer()</a>, and <a class="el" href="PPCInstrInfo_8cpp_source.html#l00101">llvm::PPCInstrInfo::CreateTargetHazardRecognizer()</a>.</p>

</div>
</div>
<a id="a5da941cb7cfe3ae9b3dae1f5caac8b78" name="a5da941cb7cfe3ae9b3dae1f5caac8b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da941cb7cfe3ae9b3dae1f5caac8b78">&#9670;&#160;</a></span>CreateTargetMIHazardRecognizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ScheduleHazardRecognizer.html">ScheduleHazardRecognizer</a> * TargetInstrInfo::CreateTargetMIHazardRecognizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *</td>          <td class="paramname"><span class="paramname"><em>II</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ScheduleDAGMI.html">ScheduleDAGMI</a> *</td>          <td class="paramname"><span class="paramname"><em>DAG</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and return a hazard recognizer to use for this target when scheduling the machine instructions before register allocation. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01411">1411</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="NVVMIntrRange_8cpp_source.html#l00052">II</a>.</p>

<p class="reference">Referenced by <a class="el" href="ARMBaseInstrInfo_8cpp_source.html#l00143">llvm::ARMBaseInstrInfo::CreateTargetMIHazardRecognizer()</a>, <a class="el" href="SIInstrInfo_8cpp_source.html#l08869">llvm::SIInstrInfo::CreateTargetMIHazardRecognizer()</a>, <a class="el" href="MachineScheduler_8cpp_source.html#l03248">llvm::GenericScheduler::initialize()</a>, and <a class="el" href="MachineScheduler_8cpp_source.html#l03882">llvm::PostGenericScheduler::initialize()</a>.</p>

</div>
</div>
<a id="a000bd55721d30de4fee9eb3d812714ea" name="a000bd55721d30de4fee9eb3d812714ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000bd55721d30de4fee9eb3d812714ea">&#9670;&#160;</a></span>CreateTargetPostRAHazardRecognizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ScheduleHazardRecognizer.html">ScheduleHazardRecognizer</a> * TargetInstrInfo::CreateTargetPostRAHazardRecognizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *</td>          <td class="paramname"><span class="paramname"><em>II</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ScheduleDAG.html">ScheduleDAG</a> *</td>          <td class="paramname"><span class="paramname"><em>DAG</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and return a hazard recognizer to use for this target when scheduling the machine instructions after register allocation. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01417">1417</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="NVVMIntrRange_8cpp_source.html#l00052">II</a>.</p>

<p class="reference">Referenced by <a class="el" href="ARMBaseInstrInfo_8cpp_source.html#l00166">llvm::ARMBaseInstrInfo::CreateTargetPostRAHazardRecognizer()</a>, and <a class="el" href="HexagonInstrInfo_8cpp_source.html#l01869">llvm::HexagonInstrInfo::CreateTargetPostRAHazardRecognizer()</a>.</p>

</div>
</div>
<a id="a55d2e824f1b036f45b51519f2844720b" name="a55d2e824f1b036f45b51519f2844720b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d2e824f1b036f45b51519f2844720b">&#9670;&#160;</a></span>CreateTargetPostRAHazardRecognizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1ScheduleHazardRecognizer.html">ScheduleHazardRecognizer</a> * llvm::TargetInstrInfo::CreateTargetPostRAHazardRecognizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and return a hazard recognizer to use for by non-scheduling passes. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01700">1700</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a186f383639b8c8fe141b55411d1121a9" name="a186f383639b8c8fe141b55411d1121a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186f383639b8c8fe141b55411d1121a9">&#9670;&#160;</a></span>CreateTargetScheduleState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1DFAPacketizer.html">DFAPacketizer</a> * llvm::TargetInstrInfo::CreateTargetScheduleState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetSubtargetInfo.html">TargetSubtargetInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create machine specific model for scheduling. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01948">1948</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="VLIWMachineScheduler_8cpp_source.html#l00194">llvm::VLIWResourceModel::createPacketizer()</a>, <a class="el" href="ResourcePriorityQueue_8cpp_source.html#l00043">llvm::ResourcePriorityQueue::ResourcePriorityQueue()</a>, and <a class="el" href="DFAPacketizer_8cpp_source.html#l00118">llvm::VLIWPacketizerList::VLIWPacketizerList()</a>.</p>

</div>
</div>
<a id="adf55430291b4f35540c9c7dfc28fedaa" name="adf55430291b4f35540c9c7dfc28fedaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf55430291b4f35540c9c7dfc28fedaa">&#9670;&#160;</a></span>decomposeMachineOperandsTargetFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; llvm::TargetInstrInfo::decomposeMachineOperandsTargetFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompose the machine operand's target flags into two values - the direct target flag value and any of bit flags that are applied. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02009">2009</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="ae5424d7c9e608bd5b2087f1021908a08" name="ae5424d7c9e608bd5b2087f1021908a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5424d7c9e608bd5b2087f1021908a08">&#9670;&#160;</a></span>defaultDefLatency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetInstrInfo::defaultDefLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1MCSchedModel.html">MCSchedModel</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SchedModel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DefMI</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the default expected latency for a def based on its opcode. </p>
<p>Return the default expected latency for a def based on it's opcode. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01489">1489</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="AArch64ExpandPseudoInsts_8cpp_source.html#l00111">DefMI</a>, <a class="el" href="MCSchedule_8h_source.html#l00301">llvm::MCSchedModel::HighLatency</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01803">isHighLatencyDef()</a>, and <a class="el" href="MCSchedule_8h_source.html#l00294">llvm::MCSchedModel::LoadLatency</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetSchedule_8cpp_source.html#l00257">llvm::TargetSchedModel::computeInstrLatency()</a>, and <a class="el" href="TargetSchedule_8cpp_source.html#l00173">llvm::TargetSchedModel::computeOperandLatency()</a>.</p>

</div>
</div>
<a id="a6885e40448874565521daac98e11f50d" name="a6885e40448874565521daac98e11f50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6885e40448874565521daac98e11f50d">&#9670;&#160;</a></span>describeLoadedValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacellvm.html#ad81cebfbef0742380b0227ae7000e0a3">ParamLoadedValue</a> &gt; TargetInstrInfo::describeLoadedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Reg</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce the expression describing the <code>MI</code> loading a value into the physical register <code>Reg</code>. </p>
<p>This hook should only be used with <code>MIs</code> belonging to VReg-less functions. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01548">1548</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="DebugInfoMetadata_8cpp_source.html#l01717">llvm::DIExpression::appendOffset()</a>, <a class="el" href="DebugInfoMetadata_8h_source.html#l03007">llvm::DIExpression::ApplyOffset</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="MachineOperand_8h_source.html#l00837">llvm::MachineOperand::CreateReg()</a>, <a class="el" href="Metadata_8h_source.html#l01543">llvm::MDNode::get()</a>, <a class="el" href="Function_8cpp_source.html#l00358">llvm::Function::getContext()</a>, <a class="el" href="MachineFunction_8h_source.html#l00733">llvm::MachineFunction::getFrameInfo()</a>, <a class="el" href="MachineFunction_8h_source.html#l00683">llvm::MachineFunction::getFunction()</a>, <a class="el" href="TargetSubtargetInfo_8h_source.html#l00096">llvm::TargetSubtargetInfo::getInstrInfo()</a>, <a class="el" href="MachineFunction_8h_source.html#l00808">llvm::MachineFunction::getProperties()</a>, <a class="el" href="MachineMemOperand_8h_source.html#l00216">llvm::MachineMemOperand::getPseudoValue()</a>, <a class="el" href="TargetSubtargetInfo_8h_source.html#l00128">llvm::TargetSubtargetInfo::getRegisterInfo()</a>, <a class="el" href="MachineMemOperand_8h_source.html#l00239">llvm::MachineMemOperand::getSize()</a>, <a class="el" href="MachineFunction_8h_source.html#l00717">llvm::MachineFunction::getSubtarget()</a>, <a class="el" href="MemoryLocation_8h_source.html#l00171">llvm::LocationSize::getValue()</a>, <a class="el" href="MachineFunction_8h_source.html#l00194">llvm::MachineFunctionProperties::hasProperty()</a>, <a class="el" href="MemoryLocation_8h_source.html#l00166">llvm::LocationSize::hasValue()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01106">isAddImmediate()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01077">isCopyInstr()</a>, <a class="el" href="PseudoSourceValue_8cpp_source.html#l00055">llvm::PseudoSourceValue::mayAlias()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="classllvm_1_1MachineFunctionProperties.html#ad85237c6c667e4713efe8921e9c32ac1a72f7d830dd5ddb30f06d8e9639558ac3">llvm::MachineFunctionProperties::NoVRegs</a>, <a class="el" href="DWP_8cpp_source.html#l00480">llvm::Offset</a>, <a class="el" href="DebugInfoMetadata_8cpp_source.html#l01838">llvm::DIExpression::prepend()</a>, <a class="el" href="DebugInfoMetadata_8cpp_source.html#l01911">llvm::DIExpression::prependOpcodes()</a>, <a class="el" href="SmallVector_8h_source.html#l00427">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>, <a class="el" href="HexagonCopyToCombine_8cpp_source.html#l00125">TII</a>, and <a class="el" href="MachineSink_8cpp_source.html#l01928">TRI</a>.</p>

<p class="reference">Referenced by <a class="el" href="ARMBaseInstrInfo_8cpp_source.html#l01075">llvm::ARMBaseInstrInfo::describeLoadedValue()</a>, <a class="el" href="MipsInstrInfo_8cpp_source.html#l00937">llvm::MipsInstrInfo::describeLoadedValue()</a>, and <a class="el" href="X86InstrInfo_8cpp_source.html#l10009">llvm::X86InstrInfo::describeLoadedValue()</a>.</p>

</div>
</div>
<a id="a8d5210bd68a86582390a6fbf1f57e319" name="a8d5210bd68a86582390a6fbf1f57e319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5210bd68a86582390a6fbf1f57e319">&#9670;&#160;</a></span>duplicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp; TargetInstrInfo::duplicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>InsertBefore</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Orig</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones instruction or the whole instruction bundle <code>Orig</code> and insert into <code>MBB</code> before <code>InsertBefore</code>. </p>
<p>The target may update operands that are required to be unique.</p>
<p><code>Orig</code> must not return true for <a class="el" href="classllvm_1_1MachineInstr.html#a7ffc14f594434308433335d6b62ded60" title="Return true if this instruction cannot be safely duplicated.">MachineInstr::isNotDuplicable()</a>. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00435">435</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l00310">llvm::MachineBasicBlock::getParent()</a>, <a class="el" href="MachineFunction_8h_source.html#l00713">llvm::MachineFunction::getTarget()</a>, <a class="el" href="llvm_2Target_2TargetMachine_8h_source.html#l00126">llvm::TargetMachine::getTargetTriple()</a>, <a class="el" href="MachineInstr_8h_source.html#l01331">llvm::MachineInstr::isCFIInstruction()</a>, <a class="el" href="MachineInstr_8h_source.html#l01048">llvm::MachineInstr::isNotDuplicable()</a>, <a class="el" href="Triple_8h_source.html#l00560">llvm::Triple::isOSDarwin()</a>, and <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>.</p>

<p class="reference">Referenced by <a class="el" href="ARMBaseInstrInfo_8cpp_source.html#l01837">llvm::ARMBaseInstrInfo::duplicate()</a>.</p>

</div>
</div>
<a id="aed830dc2b930795e75691f1efa942b12" name="aed830dc2b930795e75691f1efa942b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed830dc2b930795e75691f1efa942b12">&#9670;&#160;</a></span>emitLdStWithAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * llvm::TargetInstrInfo::emitLdStWithAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MemI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1ExtAddrMode.html">ExtAddrMode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>AM</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit a load/store instruction with the same value register as <code>MemI</code>, but using the address from <code>AM</code>. </p>
<p>The addressing mode must have been obtained from <code>canFoldIntoAddr</code> for the same memory instruction. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01524">1524</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="aeeb52dce7ed6b6e3abc562031782d77d" name="aeeb52dce7ed6b6e3abc562031782d77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb52dce7ed6b6e3abc562031782d77d">&#9670;&#160;</a></span>expandPostRAPseudo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::expandPostRAPseudo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is called for all pseudo instructions that remain after register allocation. </p>
<p>Many pseudo instructions are created to help register allocation. This is the place to convert them into real instructions. The target can edit MI in place, or it can insert new instructions and erase MI. The function should return true if anything was changed. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01163">1163</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SIInstrInfo_8cpp_source.html#l02100">llvm::SIInstrInfo::expandPostRAPseudo()</a>.</p>

</div>
</div>
<a id="acc1d5ead030ed9216dedce5a9cc304ec" name="acc1d5ead030ed9216dedce5a9cc304ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1d5ead030ed9216dedce5a9cc304ec">&#9670;&#160;</a></span>extraSizeToPredicateInstructions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::extraSizeToPredicateInstructions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumInsts</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the increase in code size needed to predicate a contiguous run of NumInsts instructions. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00889">889</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a494876c94cb3dba51694356488a996dd" name="a494876c94cb3dba51694356488a996dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494876c94cb3dba51694356488a996dd">&#9670;&#160;</a></span>finalizeInsInstrs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::finalizeInsInstrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InsInstrs</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fix up the placeholder we may add in <a class="el" href="#a6875e5a149ffdf299b10e8f969d379d4" title="When getMachineCombinerPatterns() finds patterns, this function generates the instructions that could...">genAlternativeCodeSequence()</a>. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01233">1233</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a422b844cc7e3db360908c008cb651f96" name="a422b844cc7e3db360908c008cb651f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422b844cc7e3db360908c008cb651f96">&#9670;&#160;</a></span>findCommutedOpIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::findCommutedOpIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SrcOpIdx1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SrcOpIdx2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the routine could find two commutable operands in the given machine instruction. </p>
<p>The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments. If any of the INPUT values is set to the special value 'CommuteAnyOperandIndex' then the method arbitrarily picks a commutable operand, then returns its index in the corresponding argument. If both of INPUT values are set to 'CommuteAnyOperandIndex' then method looks for 2 commutable operands. If INPUT values refer to some operands of MI, then the method simply returns true if the corresponding operands are commutable and returns false otherwise.</p>
<p>For example, calling this method this way: unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex; findCommutedOpIndices(MI, Op1, Op2); can be interpreted as a query asking to find an operand that would be commutable with the operand#1. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00295">295</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00264">fixCommutedOpIndices()</a>, <a class="el" href="MCInstrDesc_8h_source.html#l00248">llvm::MCInstrDesc::getNumDefs()</a>, <a class="el" href="MCInstrDesc_8h_source.html#l00481">llvm::MCInstrDesc::isCommutable()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00249">commuteInstruction()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00168">commuteInstructionImpl()</a>, <a class="el" href="MipsInstrInfo_8cpp_source.html#l00771">llvm::MipsInstrInfo::findCommutedOpIndices()</a>, <a class="el" href="PPCInstrInfo_8cpp_source.html#l01215">llvm::PPCInstrInfo::findCommutedOpIndices()</a>, <a class="el" href="RISCVInstrInfo_8cpp_source.html#l03111">llvm::RISCVInstrInfo::findCommutedOpIndices()</a>, and <a class="el" href="X86InstrInfo_8cpp_source.html#l02816">llvm::X86InstrInfo::findCommutedOpIndices()</a>.</p>

</div>
</div>
<a id="aef5b8db7ddf8b00b66e4f64711a053cd" name="aef5b8db7ddf8b00b66e4f64711a053cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5b8db7ddf8b00b66e4f64711a053cd">&#9670;&#160;</a></span>fixCommutedOpIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::fixCommutedOpIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ResultIdx1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ResultIdx2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>CommutableOpIdx1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>CommutableOpIdx2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the (CommutableOpIdx1, CommutableOpIdx2) pair of commutable operand indices to (ResultIdx1, ResultIdx2). </p>
<p>One or both input values of the pair: (ResultIdx1, ResultIdx2) may be predefined to some indices or be undefined (designated by the special value 'CommuteAnyOperandIndex'). The predefined result indices cannot be re-defined. The function returns true iff after the result pair redefinition the fixed result pair is equal to or equivalent to the source pair of indices: (CommutableOpIdx1, CommutableOpIdx2). It is assumed here that the pairs (x,y) and (y,x) are equivalent. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00264">264</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l00450">CommuteAnyOperandIndex</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00295">findCommutedOpIndices()</a>.</p>

</div>
</div>
<a id="aa41c45a69f227ee71e5ced4e6e3fde18" name="aa41c45a69f227ee71e5ced4e6e3fde18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41c45a69f227ee71e5ced4e6e3fde18">&#9670;&#160;</a></span>foldImmediate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::foldImmediate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UseMI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DefMI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>MRI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Reg' is known to be defined by a move immediate instruction, try to fold the immediate into the use instruction. </p>
<p>If MRI-&gt;hasOneNonDBGUse(Reg) is true, and this function returns true, then the caller may assume that DefMI has been erased from its parent block. The caller may assume that it will not be erased by this function otherwise. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01749">1749</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a6a733ae5364b0de2225af33223f383a5" name="a6a733ae5364b0de2225af33223f383a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a733ae5364b0de2225af33223f383a5">&#9670;&#160;</a></span>foldMemoryOperand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * TargetInstrInfo::foldMemoryOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>FI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LiveIntervals.html">LiveIntervals</a> *</td>          <td class="paramname"><span class="paramname"><em>LIS</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VirtRegMap.html">VirtRegMap</a> *</td>          <td class="paramname"><span class="paramname"><em>VRM</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to fold a load or store of the specified stack slot into the specified machine instruction for the specified operand(s). </p>
<p>If this is possible, a new instruction is returned with the specified operand folded, otherwise NULL is returned. The new instruction is inserted before MI, and the client is responsible for removing the old instruction. If VRM is passed, the assigned physregs can be inspected by target to decide on using an opcode (note that those assignments can still change). </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00634">634</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineInstr_8cpp_source.html#l00381">llvm::MachineInstr::addMemOperand()</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00451">canFoldCopy()</a>, <a class="el" href="MachineInstr_8cpp_source.html#l00545">llvm::MachineInstr::cloneInstrSymbols()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00568">foldInlineAsmMemOperand()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01349">foldMemoryOperandImpl()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00503">foldPatchpoint()</a>, <a class="el" href="MachineOperand_8cpp_source.html#l01062">llvm::MachinePointerInfo::getFixedStack()</a>, <a class="el" href="MachineFunction_8h_source.html#l00733">llvm::MachineFunction::getFrameInfo()</a>, <a class="el" href="MachineFunction_8cpp_source.html#l00501">llvm::MachineFunction::getMachineMemOperand()</a>, <a class="el" href="MachineFrameInfo_8h_source.html#l00486">llvm::MachineFrameInfo::getObjectAlign()</a>, <a class="el" href="MachineFrameInfo_8h_source.html#l00528">llvm::MachineFrameInfo::getObjectOffset()</a>, <a class="el" href="MachineFrameInfo_8h_source.html#l00472">llvm::MachineFrameInfo::getObjectSize()</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l00310">llvm::MachineBasicBlock::getParent()</a>, <a class="el" href="MachineOperand_8h_source.html#l00369">llvm::MachineOperand::getReg()</a>, <a class="el" href="TargetSubtargetInfo_8h_source.html#l00128">llvm::TargetSubtargetInfo::getRegisterInfo()</a>, <a class="el" href="MachineFunction_8h_source.html#l00717">llvm::MachineFunction::getSubtarget()</a>, <a class="el" href="MachineBasicBlock_8cpp_source.html#l01454">llvm::MachineBasicBlock::insert()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01077">isCopyInstr()</a>, <a class="el" href="MachineOperand_8h_source.html#l00399">llvm::MachineOperand::isKill()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01147">loadRegFromStackSlot()</a>, <a class="el" href="MachineInstr_8h_source.html#l01136">llvm::MachineInstr::mayLoad()</a>, <a class="el" href="MachineInstr_8h_source.html#l01149">llvm::MachineInstr::mayStore()</a>, <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="MachineMemOperand_8h_source.html#l00136">llvm::MachineMemOperand::MOLoad</a>, <a class="el" href="MachineMemOperand_8h_source.html#l00134">llvm::MachineMemOperand::MONone</a>, <a class="el" href="MachineMemOperand_8h_source.html#l00138">llvm::MachineMemOperand::MOStore</a>, <a class="el" href="MachineInstr_8cpp_source.html#l00369">llvm::MachineInstr::setMemRefs()</a>, <a class="el" href="ArrayRef_8h_source.html#l00165">llvm::ArrayRef&lt; T &gt;::size()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01129">storeRegToStackSlot()</a>, <a class="el" href="AArch64AdvSIMDScalarPass_8cpp_source.html#l00104">SubReg</a>, and <a class="el" href="MachineSink_8cpp_source.html#l01928">TRI</a>.</p>

</div>
</div>
<a id="a2432d0bb09d9fe3b6bb004d8dbf77a99" name="a2432d0bb09d9fe3b6bb004d8dbf77a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2432d0bb09d9fe3b6bb004d8dbf77a99">&#9670;&#160;</a></span>foldMemoryOperand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * TargetInstrInfo::foldMemoryOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>LoadMI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LiveIntervals.html">LiveIntervals</a> *</td>          <td class="paramname"><span class="paramname"><em>LIS</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the previous version except it allows folding of any load and store from / to any address, not just from a specific stack slot. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00729">729</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineInstr_8cpp_source.html#l00381">llvm::MachineInstr::addMemOperand()</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="MachineInstr_8h_source.html#l01082">llvm::MachineInstr::canFoldAsLoad()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00568">foldInlineAsmMemOperand()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01349">foldMemoryOperandImpl()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00503">foldPatchpoint()</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l00310">llvm::MachineBasicBlock::getParent()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="MachineBasicBlock_8cpp_source.html#l01454">llvm::MachineBasicBlock::insert()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00274">isLoadFromStackSlot()</a>, <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>, <a class="el" href="MachineInstr_8h_source.html#l00782">llvm::MachineInstr::memoperands()</a>, <a class="el" href="MachineInstr_8h_source.html#l00800">llvm::MachineInstr::memoperands_begin()</a>, <a class="el" href="MachineInstr_8h_source.html#l00807">llvm::MachineInstr::memoperands_end()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, and <a class="el" href="MachineInstr_8cpp_source.html#l00369">llvm::MachineInstr::setMemRefs()</a>.</p>

</div>
</div>
<a id="a0a1e73b39957ad3da60cb9d3a690df89" name="a0a1e73b39957ad3da60cb9d3a690df89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1e73b39957ad3da60cb9d3a690df89">&#9670;&#160;</a></span>foldMemoryOperandImpl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * llvm::TargetInstrInfo::foldMemoryOperandImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>InsertPt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>FrameIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LiveIntervals.html">LiveIntervals</a> *</td>          <td class="paramname"><span class="paramname"><em>LIS</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VirtRegMap.html">VirtRegMap</a> *</td>          <td class="paramname"><span class="paramname"><em>VRM</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target-dependent implementation for foldMemoryOperand. </p>
<p>Target-independent code in foldMemoryOperand will take care of adding a <a class="el" href="classllvm_1_1MachineMemOperand.html" title="A description of a memory reference used in the backend.">MachineMemOperand</a> to the newly created instruction. The instruction and any auxiliary instructions necessary will be inserted at InsertPt. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01349">1349</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00634">foldMemoryOperand()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l00729">foldMemoryOperand()</a>.</p>

</div>
</div>
<a id="af4f87b0480bb0e4d689f7b3cf2aa88a1" name="af4f87b0480bb0e4d689f7b3cf2aa88a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f87b0480bb0e4d689f7b3cf2aa88a1">&#9670;&#160;</a></span>foldMemoryOperandImpl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * llvm::TargetInstrInfo::foldMemoryOperandImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>InsertPt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>LoadMI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LiveIntervals.html">LiveIntervals</a> *</td>          <td class="paramname"><span class="paramname"><em>LIS</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target-dependent implementation for foldMemoryOperand. </p>
<p>Target-independent code in foldMemoryOperand will take care of adding a <a class="el" href="classllvm_1_1MachineMemOperand.html" title="A description of a memory reference used in the backend.">MachineMemOperand</a> to the newly created instruction. The instruction and any auxiliary instructions necessary will be inserted at InsertPt. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01362">1362</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a6875e5a149ffdf299b10e8f969d379d4" name="a6875e5a149ffdf299b10e8f969d379d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6875e5a149ffdf299b10e8f969d379d4">&#9670;&#160;</a></span>genAlternativeCodeSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TargetInstrInfo::genAlternativeCodeSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InsInstrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>DelInstrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InstIdxForVirtReg</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When <a class="el" href="#a861381cad67866e249c6330631ac0742" title="Return true when there is potentially a faster code sequence for an instruction chain ending in Root.">getMachineCombinerPatterns()</a> finds patterns, this function generates the instructions that could replace the original code sequence. </p>
<p>The client has to decide whether the actual replacement is beneficial or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Root</td><td>- <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> that could be combined with one of its operands </td></tr>
    <tr><td class="paramname"><a class="el" href="classllvm_1_1Pattern.html">Pattern</a></td><td>- Combination pattern for Root </td></tr>
    <tr><td class="paramname">InsInstrs</td><td>- Vector of new instructions that implement P </td></tr>
    <tr><td class="paramname">DelInstrs</td><td>- Old instructions, including Root, that could be replaced by InsInstr </td></tr>
    <tr><td class="paramname">InstIdxForVirtReg</td><td>- map of virtual register to instruction in InsInstr that defines it </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01247">1247</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineInstr_8cpp_source.html#l00747">llvm::MachineInstr::getMF()</a>, <a class="el" href="MachineInstr_8h_source.html#l00579">llvm::MachineInstr::getOperand()</a>, <a class="el" href="MachineInstr_8h_source.html#l00346">llvm::MachineInstr::getParent()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l01058">getReassociateOperandIndices()</a>, <a class="el" href="MachineOperand_8h_source.html#l00369">llvm::MachineOperand::getReg()</a>, <a class="el" href="MachineFunction_8h_source.html#l00727">llvm::MachineFunction::getRegInfo()</a>, <a class="el" href="AArch64AdvSIMDScalarPass_8cpp_source.html#l00105">MRI</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l01081">reassociateOps()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPCInstrInfo_8cpp_source.html#l00768">llvm::PPCInstrInfo::genAlternativeCodeSequence()</a>, <a class="el" href="RISCVInstrInfo_8cpp_source.html#l02320">llvm::RISCVInstrInfo::genAlternativeCodeSequence()</a>, and <a class="el" href="X86InstrInfo_8cpp_source.html#l10801">llvm::X86InstrInfo::genAlternativeCodeSequence()</a>.</p>

</div>
</div>
<a id="a7ea0602dc926bed4a92bc63ae99e7cc9" name="a7ea0602dc926bed4a92bc63ae99e7cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea0602dc926bed4a92bc63ae99e7cc9">&#9670;&#160;</a></span>getAddrModeFromMemoryOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; <a class="el" href="structllvm_1_1ExtAddrMode.html">ExtAddrMode</a> &gt; llvm::TargetInstrInfo::getAddrModeFromMemoryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MemI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classllvm_1_1Target.html" title="Target - Wrapper for Target specific information.">Target</a> dependent implementation to get the values constituting the address <a class="el" href="classllvm_1_1MachineInstr.html" title="Representation of each machine instruction.">MachineInstr</a> that is accessing memory. </p>
<p>These values are returned as a struct <a class="el" href="structllvm_1_1ExtAddrMode.html" title="Used to describe addressing mode similar to ExtAddrMode in CodeGenPrepare.">ExtAddrMode</a> which contains all relevant information to make up the address. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01504">1504</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a28d18d91f58682d65e97e9c386064b5b" name="a28d18d91f58682d65e97e9c386064b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d18d91f58682d65e97e9c386064b5b">&#9670;&#160;</a></span>getBaseAndOffsetPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::getBaseAndOffsetPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>BasePos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OffsetPos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the instruction contains a base register and offset. </p>
<p>If true, the function also sets the operand position in the instruction for the base register and offset. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01493">1493</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MachinePipeliner_8cpp_source.html#l02666">llvm::SwingSchedulerDAG::applyInstrChange()</a>, and <a class="el" href="MachinePipeliner_8cpp_source.html#l03358">llvm::SwingSchedulerDAG::fixupRegisterOverlaps()</a>.</p>

</div>
</div>
<a id="ab8ab946af55bc208ded5c21c11ff71c2" name="ab8ab946af55bc208ded5c21c11ff71c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ab946af55bc208ded5c21c11ff71c2">&#9670;&#160;</a></span>getBranchDestBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> * llvm::TargetInstrInfo::getBranchDestBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The block that branch instruction <code>MI</code> jumps to. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00607">607</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="a9e8b374c12bde7a8aa400ae5e34e6956" name="a9e8b374c12bde7a8aa400ae5e34e6956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8b374c12bde7a8aa400ae5e34e6956">&#9670;&#160;</a></span>getCalleeOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &amp; llvm::TargetInstrInfo::getCalleeOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the callee operand from the given <code>MI</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02236">2236</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="ab5a18bb895aa0c46d5de27c4ad046aee" name="ab5a18bb895aa0c46d5de27c4ad046aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a18bb895aa0c46d5de27c4ad046aee">&#9670;&#160;</a></span>getCallFrameDestroyOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getCallFrameDestroyOpcode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00211">211</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="M68kFrameLowering_8cpp_source.html#l00227">llvm::M68kFrameLowering::eliminateCallFramePseudoInstr()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l01626">getCallFrameSizeAt()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l01351">getSPAdjust()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00214">isFrameInstr()</a>, and <a class="el" href="FastISel_8cpp_source.html#l00642">llvm::FastISel::selectStackmap()</a>.</p>

</div>
</div>
<a id="a83870b05e73f275887a1e20baa621475" name="a83870b05e73f275887a1e20baa621475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83870b05e73f275887a1e20baa621475">&#9670;&#160;</a></span>getCallFrameSetupOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getCallFrameSetupOpcode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These methods return the opcode of the frame setup/destroy instructions if they exist (-1 otherwise). </p>
<p>Some targets use pseudo instructions in order to abstract away the difference between operating with a frame pointer and operating without, through the use of these two instructions. A FrameSetup MI in MF implies MFI::AdjustsStack. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00210">210</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01626">getCallFrameSizeAt()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l01351">getSPAdjust()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00214">isFrameInstr()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00220">isFrameSetup()</a>, and <a class="el" href="FastISel_8cpp_source.html#l00642">llvm::FastISel::selectStackmap()</a>.</p>

</div>
</div>
<a id="a89e324da740d76918b3f2b2ecf807e49" name="a89e324da740d76918b3f2b2ecf807e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e324da740d76918b3f2b2ecf807e49">&#9670;&#160;</a></span>getCallFrameSizeAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetInstrInfo::getCallFrameSizeAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01626">1626</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l00211">getCallFrameDestroyOpcode()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00210">getCallFrameSetupOpcode()</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l01211">llvm::MachineBasicBlock::getCallFrameSize()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00241">getFrameTotalSize()</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l00338">llvm::MachineBasicBlock::instr_begin()</a>, <a class="el" href="iterator__range_8h_source.html#l00076">llvm::make_range()</a>, <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, and <a class="el" href="STLExtras_8h_source.html#l00419">llvm::reverse()</a>.</p>

</div>
</div>
<a id="a98a831626be0c6e512d6d95246891c84" name="a98a831626be0c6e512d6d95246891c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a831626be0c6e512d6d95246891c84">&#9670;&#160;</a></span>getCatchReturnOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getCatchReturnOpcode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00250">250</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="adcf4712d0ec5fc344aa14efa9e5392b2" name="adcf4712d0ec5fc344aa14efa9e5392b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf4712d0ec5fc344aa14efa9e5392b2">&#9670;&#160;</a></span>getCombinerObjective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacellvm.html#a878ef42ed9660dc3a739a37e056f845d">CombinerObjective</a> TargetInstrInfo::getCombinerObjective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the objective of a combiner pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classllvm_1_1Pattern.html">Pattern</a></td><td>- combiner pattern </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00949">949</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a878ef42ed9660dc3a739a37e056f845da7a1920d61156abc05a60135aefe8bc67">llvm::Default</a>.</p>

<p class="reference">Referenced by <a class="el" href="AArch64InstrInfo_8cpp_source.html#l06599">llvm::AArch64InstrInfo::getCombinerObjective()</a>, <a class="el" href="PPCInstrInfo_8cpp_source.html#l00740">llvm::PPCInstrInfo::getCombinerObjective()</a>, and <a class="el" href="RISCVInstrInfo_8cpp_source.html#l02155">llvm::RISCVInstrInfo::getCombinerObjective()</a>.</p>

</div>
</div>
<a id="a820eea71d5b67cf63757e49e3c55736d" name="a820eea71d5b67cf63757e49e3c55736d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820eea71d5b67cf63757e49e3c55736d">&#9670;&#160;</a></span>getConstValDefinedInReg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::getConstValDefinedInReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>ImmVal</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if MI is an instruction that defines Reg to have a constant value and the value is recorded in ImmVal. </p>
<p>The ImmVal is a result that should be interpreted as modulo size of Reg. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01114">1114</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a907019eb40cf2db5f3a35cb0bc456347" name="a907019eb40cf2db5f3a35cb0bc456347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907019eb40cf2db5f3a35cb0bc456347">&#9670;&#160;</a></span>getExecutionDomain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt; <a class="el" href="classuint16__t.html">uint16_t</a>, <a class="el" href="classuint16__t.html">uint16_t</a> &gt; llvm::TargetInstrInfo::getExecutionDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current execution domain and bit mask of possible domains for instruction. </p>
<p>Some micro-architectures have multiple execution domains, and multiple opcodes that perform the same operation in different domains. For example, the x86 architecture provides the por, orps, and orpd instructions that all do the same thing. There is a latency penalty if a register is written in one domain and read in another.</p>
<p>This function returns a pair (domain, mask) containing the execution domain of MI, and a bit mask of possible domains. The setExecutionDomain function can be used to change the opcode to one of the domains in the bit mask. Instructions whose execution domain can't be changed should return a 0 mask.</p>
<p>The execution domain numbers don't have any special meaning except domain 0 is used for instructions that are not associated with any interesting execution domain. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01850">1850</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a55912dd5bde1306ca2642c4aebca197b" name="a55912dd5bde1306ca2642c4aebca197b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55912dd5bde1306ca2642c4aebca197b">&#9670;&#160;</a></span>getExtendResourceLenLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int llvm::TargetInstrInfo::getExtendResourceLenLimit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The limit on resource length extension we accept in MachineCombiner <a class="el" href="classllvm_1_1Pass.html" title="Pass interface - Implemented by all &#39;passes&#39;.">Pass</a>. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01324">1324</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="af1743a67877bf4ba56d53b235d3573e0" name="af1743a67877bf4ba56d53b235d3573e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1743a67877bf4ba56d53b235d3573e0">&#9670;&#160;</a></span>getExtractSubregInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::getExtractSubregInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DefIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InputReg</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the equivalent inputs of a EXTRACT_SUBREG for the given <code>MI</code> and <code>DefIdx</code>. </p>
<p><code></code>[out] InputReg of the equivalent EXTRACT_SUBREG. E.g., EXTRACT_SUBREG %1:sub1, sub0, sub1 would produce:</p><ul>
<li>%1:sub1, sub0</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if it is possible to build such an input sequence with the pair <code>MI</code>, <code>DefIdx</code> and the operand has no undef flag set. False otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>MI.isExtractSubreg() or MI.isExtractSubregLike().</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The generic implementation does not provide any support for MI.isExtractSubregLike(). In other words, one has to override getExtractSubregLikeInputs for target specific instructions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01678">1678</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01391">getExtractSubregLikeInputs()</a>, <a class="el" href="MachineOperand_8h_source.html#l00556">llvm::MachineOperand::getImm()</a>, <a class="el" href="MachineOperand_8h_source.html#l00369">llvm::MachineOperand::getReg()</a>, <a class="el" href="MachineOperand_8h_source.html#l00374">llvm::MachineOperand::getSubReg()</a>, <a class="el" href="MachineOperand_8h_source.html#l00331">llvm::MachineOperand::isImm()</a>, <a class="el" href="MachineOperand_8h_source.html#l00404">llvm::MachineOperand::isUndef()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00504">llvm::TargetInstrInfo::RegSubRegPair::Reg</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00522">llvm::TargetInstrInfo::RegSubRegPairAndIdx::SubIdx</a>, and <a class="el" href="TargetInstrInfo_8h_source.html#l00505">llvm::TargetInstrInfo::RegSubRegPair::SubReg</a>.</p>

</div>
</div>
<a id="af1c44734f854fb7f620d16097f2af637" name="af1c44734f854fb7f620d16097f2af637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c44734f854fb7f620d16097f2af637">&#9670;&#160;</a></span>getExtractSubregLikeInputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::getExtractSubregLikeInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DefIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InputReg</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target-dependent implementation of getExtractSubregInputs. </p>
<dl class="section return"><dt>Returns</dt><dd>true if it is possible to build the equivalent EXTRACT_SUBREG inputs with the pair <code>MI</code>, <code>DefIdx</code>. False otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>MI.isExtractSubregLike().</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af1743a67877bf4ba56d53b235d3573e0" title="Build the equivalent inputs of a EXTRACT_SUBREG for the given MI and DefIdx.">TargetInstrInfo::getExtractSubregInputs</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01391">1391</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01678">getExtractSubregInputs()</a>.</p>

</div>
</div>
<a id="a0d10b938465726d85e01bbb669e184d0" name="a0d10b938465726d85e01bbb669e184d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d10b938465726d85e01bbb669e184d0">&#9670;&#160;</a></span>getFrameIndexOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::getFrameIndexOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>FI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills in the necessary MachineOperands to refer to a frame index. </p>
<p>The best way to understand this is to print <code>asm(""::"m"(x));</code> after finalize-isel. Example: INLINEASM ... 262190 /* mem:m *&zwj;/, stack.0.x.addr, 1, $noreg, 0, $noreg we would add placeholders for: ^ ^ ^ ^ </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02263">2263</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="ab5c5ed9e614110e7cbdd8a4ab957ec06" name="ab5c5ed9e614110e7cbdd8a4ab957ec06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c5ed9e614110e7cbdd8a4ab957ec06">&#9670;&#160;</a></span>getFrameSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t llvm::TargetInstrInfo::getFrameSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns size of the frame associated with the given frame instruction. </p>
<p>For frame setup instruction this is frame that is set up space set up after the instruction. For frame destroy instruction this is the frame freed by the caller. Note, in some cases a call frame (or a part of it) may be prepared prior to the frame setup instruction. It occurs in the calls that involve inalloca arguments. This function reports only the size of the frame part that is set up between the frame setup and destroy pseudo instructions. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00232">232</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="TargetInstrInfo_8h_source.html#l00214">isFrameInstr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8h_source.html#l00241">getFrameTotalSize()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l01351">getSPAdjust()</a>.</p>

</div>
</div>
<a id="aa0b59f9d1912a25fc5c03ae9b2ff960d" name="aa0b59f9d1912a25fc5c03ae9b2ff960d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b59f9d1912a25fc5c03ae9b2ff960d">&#9670;&#160;</a></span>getFrameTotalSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t llvm::TargetInstrInfo::getFrameTotalSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total frame size, which is made up of the space set up inside the pair of frame start-stop instructions and the space that is set up prior to the pair. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00241">241</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00232">getFrameSize()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="TargetInstrInfo_8h_source.html#l00220">isFrameSetup()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01626">getCallFrameSizeAt()</a>.</p>

</div>
</div>
<a id="af454ffcb2775e8a8abf663da93a0a438" name="af454ffcb2775e8a8abf663da93a0a438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af454ffcb2775e8a8abf663da93a0a438">&#9670;&#160;</a></span>getIncrementValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::getIncrementValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>Value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the instruction is an increment of a constant value, return the amount. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01541">1541</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MachinePipeliner_8cpp_source.html#l02721">llvm::SwingSchedulerDAG::isLoopCarriedDep()</a>.</p>

</div>
</div>
<a id="a65168b27efceb92102521e2bc82b8d49" name="a65168b27efceb92102521e2bc82b8d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65168b27efceb92102521e2bc82b8d49">&#9670;&#160;</a></span>getInlineAsmLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetInstrInfo::getInlineAsmLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>Str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MCAsmInfo.html">MCAsmInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MAI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetSubtargetInfo.html">TargetSubtargetInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>STI</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Measure the specified inline asm to determine an approximation of its length. </p>
<p>Comments (which run till the next SeparatorString or newline) do not count as an instruction. <a class="el" href="classllvm_1_1Any.html">Any</a> other non-whitespace text is considered an instruction, with multiple instructions separated by SeparatorString or newlines. Variable-length instructions are not handled here; this function may be overloaded in the target code to do that. We implement a special case of the .space directive which takes only a single integer argument in base 10 that is the size in bytes. This is a restricted form of the GAS directive in that we only interpret simple&ndash;i.e. not a logical or arithmetic expression&ndash;size values without the optional fill value. This is primarily used for creating arbitrary sized inline asm blocks for testing purposes. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00101">101</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MCAsmInfo_8h_source.html#l00631">llvm::MCAsmInfo::getMaxInstLength()</a>, <a class="el" href="MCAsmInfo_8h_source.html#l00639">llvm::MCAsmInfo::getSeparatorString()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00082">isAsmComment()</a>, and <a class="el" href="DWP_8cpp_source.html#l00480">llvm::Length</a>.</p>

</div>
</div>
<a id="abea536f043de7994bc9b67c634a7c879" name="abea536f043de7994bc9b67c634a7c879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea536f043de7994bc9b67c634a7c879">&#9670;&#160;</a></span>getInsertSubregInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::getInsertSubregInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DefIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPair.html">RegSubRegPair</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>BaseReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InsertedReg</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the equivalent inputs of a INSERT_SUBREG for the given <code>MI</code> and <code>DefIdx</code>. </p>
<p><code></code>[out] BaseReg and <code></code>[out] InsertedReg contain the equivalent inputs of INSERT_SUBREG. E.g., INSERT_SUBREG %0:sub0, %1:sub1, sub3 would produce:</p><ul>
<li>BaseReg: %0:sub0</li>
<li>InsertedReg: %1:sub1, sub3</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if it is possible to build such an input sequence with the pair <code>MI</code>, <code>DefIdx</code> and the operand has no undef flag set. False otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>MI.isInsertSubreg() or MI.isInsertSubregLike().</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The generic implementation does not provide any support for MI.isInsertSubregLike(). In other words, one has to override getInsertSubregLikeInputs for target specific instructions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01703">1703</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="MachineOperand_8h_source.html#l00556">llvm::MachineOperand::getImm()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01406">getInsertSubregLikeInputs()</a>, <a class="el" href="MachineOperand_8h_source.html#l00369">llvm::MachineOperand::getReg()</a>, <a class="el" href="MachineOperand_8h_source.html#l00374">llvm::MachineOperand::getSubReg()</a>, <a class="el" href="MachineOperand_8h_source.html#l00331">llvm::MachineOperand::isImm()</a>, <a class="el" href="MachineOperand_8h_source.html#l00404">llvm::MachineOperand::isUndef()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00504">llvm::TargetInstrInfo::RegSubRegPair::Reg</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00522">llvm::TargetInstrInfo::RegSubRegPairAndIdx::SubIdx</a>, and <a class="el" href="TargetInstrInfo_8h_source.html#l00505">llvm::TargetInstrInfo::RegSubRegPair::SubReg</a>.</p>

</div>
</div>
<a id="a2b51d2dd19b3859797509c03d5f451f1" name="a2b51d2dd19b3859797509c03d5f451f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b51d2dd19b3859797509c03d5f451f1">&#9670;&#160;</a></span>getInsertSubregLikeInputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::getInsertSubregLikeInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DefIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPair.html">RegSubRegPair</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>BaseReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InsertedReg</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target-dependent implementation of getInsertSubregInputs. </p>
<dl class="section return"><dt>Returns</dt><dd>true if it is possible to build the equivalent INSERT_SUBREG inputs with the pair <code>MI</code>, <code>DefIdx</code>. False otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>MI.isInsertSubregLike().</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abea536f043de7994bc9b67c634a7c879" title="Build the equivalent inputs of a INSERT_SUBREG for the given MI and DefIdx.">TargetInstrInfo::getInsertSubregInputs</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01406">1406</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01703">getInsertSubregInputs()</a>.</p>

</div>
</div>
<a id="ac45af359a246cde99ce09578e3998985" name="ac45af359a246cde99ce09578e3998985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45af359a246cde99ce09578e3998985">&#9670;&#160;</a></span>getInstrLatency() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetInstrInfo::getInstrLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *</td>          <td class="paramname"><span class="paramname"><em>ItinData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *</td>          <td class="paramname"><span class="paramname"><em>PredCost</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the instruction latency of a given instruction. </p>
<p>If the instruction has higher cost when predicated, it's returned via PredCost. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01504">1504</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MCInstrItineraries_8h_source.html#l00150">llvm::InstrItineraryData::getStageLatency()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetSchedule_8cpp_source.html#l00257">llvm::TargetSchedModel::computeInstrLatency()</a>, and <a class="el" href="ScheduleDAGSDNodes_8cpp_source.html#l00616">llvm::ScheduleDAGSDNodes::computeLatency()</a>.</p>

</div>
</div>
<a id="a86ea143f1ea40632ba851badcf377101" name="a86ea143f1ea40632ba851badcf377101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ea143f1ea40632ba851badcf377101">&#9670;&#160;</a></span>getInstrLatency() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetInstrInfo::getInstrLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *</td>          <td class="paramname"><span class="paramname"><em>ItinData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>Node</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01458">1458</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MCInstrInfo_8h_source.html#l00063">llvm::MCInstrInfo::get()</a>, <a class="el" href="MCInstrDesc_8h_source.html#l00600">llvm::MCInstrDesc::getSchedClass()</a>, <a class="el" href="MCInstrItineraries_8h_source.html#l00150">llvm::InstrItineraryData::getStageLatency()</a>, <a class="el" href="MCInstrItineraries_8h_source.html#l00127">llvm::InstrItineraryData::isEmpty()</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

</div>
</div>
<a id="a9b400bea2e0c5c1d17478053b5acdd3e" name="a9b400bea2e0c5c1d17478053b5acdd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b400bea2e0c5c1d17478053b5acdd3e">&#9670;&#160;</a></span>getInstructionUniformity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacellvm.html#ae58c751054b01f206f9b9e34e461d25f">InstructionUniformity</a> llvm::TargetInstrInfo::getInstructionUniformity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the uniformity behavior of the given instruction. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02242">2242</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#ae58c751054b01f206f9b9e34e461d25fa7a1920d61156abc05a60135aefe8bc67">llvm::Default</a>.</p>

</div>
</div>
<a id="ad5c95e145de31fbd3c6269ebe1b615f7" name="ad5c95e145de31fbd3c6269ebe1b615f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c95e145de31fbd3c6269ebe1b615f7">&#9670;&#160;</a></span>getInstSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getInstSizeInBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size in bytes of the specified <a class="el" href="classllvm_1_1MachineInstr.html" title="Representation of each machine instruction.">MachineInstr</a>, or ~0U when this function is not implemented by a target. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00378">378</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8h_source.html#l00896">predictBranchSizeForIfCvt()</a>.</p>

</div>
</div>
<a id="ab0568ec903d0544ec11e0fb013d2fbe2" name="ab0568ec903d0544ec11e0fb013d2fbe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0568ec903d0544ec11e0fb013d2fbe2">&#9670;&#160;</a></span>getInverseOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; llvm::TargetInstrInfo::getInverseOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the inverse operation opcode if it exists for \P Opcode (e.g. </p>
<p>add for sub and vice versa). </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01261">1261</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00852">areOpcodesEqualOrInverse()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l00954">getReassociationOpcodes()</a>.</p>

</div>
</div>
<a id="aa67b6d0847ff336198e7b56ecf022a3a" name="aa67b6d0847ff336198e7b56ecf022a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67b6d0847ff336198e7b56ecf022a3a">&#9670;&#160;</a></span>getJumpTableIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int llvm::TargetInstrInfo::getJumpTableIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an index for <a class="el" href="classllvm_1_1MachineJumpTableInfo.html">MachineJumpTableInfo</a> if <code>insn</code> is an indirect jump using a jump table, otherwise -1. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01042">1042</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a6cf855363122e65fd4e6f2df1d16aba0" name="a6cf855363122e65fd4e6f2df1d16aba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf855363122e65fd4e6f2df1d16aba0">&#9670;&#160;</a></span>getLiveRangeSplitOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getLiveRangeSplitOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows targets to use appropriate copy instruction while spilitting live range of a register in register allocation. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02061">2061</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a861381cad67866e249c6330631ac0742" name="a861381cad67866e249c6330631ac0742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861381cad67866e249c6330631ac0742">&#9670;&#160;</a></span>getMachineCombinerPatterns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::getMachineCombinerPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Patterns</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>DoRegPressureReduce</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true when there is potentially a faster code sequence for an instruction chain ending in <code>Root</code>. </p>
<p>All potential patterns are returned in the <code><a class="el" href="classllvm_1_1Pattern.html">Pattern</a></code> vector. <a class="el" href="classllvm_1_1Pattern.html">Pattern</a> should be sorted in priority order since the pattern evaluator stops checking as soon as it finds a faster sequence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Root</td><td>- <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> that could be combined with one of its operands </td></tr>
    <tr><td class="paramname">Patterns</td><td>- Vector of possible combination patterns </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00921">921</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8cpp_source.html#l00892">isReassociationCandidate()</a>, <a class="el" href="SmallVector_8h_source.html#l00427">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00031">llvm::REASSOC_AX_BY</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00032">llvm::REASSOC_AX_YB</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00033">llvm::REASSOC_XA_BY</a>, and <a class="el" href="MachineCombinerPattern_8h_source.html#l00034">llvm::REASSOC_XA_YB</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPCInstrInfo_8cpp_source.html#l00753">llvm::PPCInstrInfo::getMachineCombinerPatterns()</a>, <a class="el" href="RISCVInstrInfo_8cpp_source.html#l02167">llvm::RISCVInstrInfo::getMachineCombinerPatterns()</a>, and <a class="el" href="X86InstrInfo_8cpp_source.html#l10679">llvm::X86InstrInfo::getMachineCombinerPatterns()</a>.</p>

</div>
</div>
<a id="ae1778172912b443f67ccb9ee1af22776" name="ae1778172912b443f67ccb9ee1af22776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1778172912b443f67ccb9ee1af22776">&#9670;&#160;</a></span>getMachineCombinerTraceStrategy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacellvm.html#a08fc515218c080e73909645fecb41ed0">MachineTraceStrategy</a> TargetInstrInfo::getMachineCombinerTraceStrategy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a strategy that MachineCombiner must use when creating traces. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01268">1268</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a08fc515218c080e73909645fecb41ed0ab5435d2dc82cf75225dd888985989f5a">llvm::TS_MinInstrCount</a>.</p>

</div>
</div>
<a id="afa3c5e05e3b2eb5e8dd9c763efbdca4b" name="afa3c5e05e3b2eb5e8dd9c763efbdca4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3c5e05e3b2eb5e8dd9c763efbdca4b">&#9670;&#160;</a></span>getMachineCSELookAheadLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getMachineCSELookAheadLimit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value to use for the MachineCSE's LookAheadLimit, which is a heuristic used for CSE'ing phys reg defs. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01975">1975</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a6f67bce035b491e5e6d95286ffe20da1" name="a6f67bce035b491e5e6d95286ffe20da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f67bce035b491e5e6d95286ffe20da1">&#9670;&#160;</a></span>getMemOperandAACheckLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getMemOperandAACheckLimit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximal number of alias checks on memory operands. </p>
<p>For instructions with more than one memory operands, the alias check on a single <a class="el" href="classllvm_1_1MachineInstr.html" title="Representation of each machine instruction.">MachineInstr</a> pair has quadratic overhead and results in unacceptable performance in the worst case. The limit here is to clamp that maximal checks performed. Usually, that's the product of memory operand numbers from that pair of <a class="el" href="classllvm_1_1MachineInstr.html" title="Representation of each machine instruction.">MachineInstr</a> to be checked. For instance, with two MachineInstrs with 4 and 5 memory operands correspondingly, a total of 20 checks are required. With this limit set to 16, their alias check is skipped. We choose to limit the product instead of the individual instruction as targets may have special MachineInstrs with a considerably high number of memory operands, such as <code>ldm</code> in <a class="el" href="namespacellvm_1_1ARM.html" title="Define some predicates that are used for node matching.">ARM</a>. Setting this limit per <a class="el" href="classllvm_1_1MachineInstr.html" title="Representation of each machine instruction.">MachineInstr</a> would result in either too high overhead or too rigid restriction. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01994">1994</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="ad562f15f35ef21a4965d1b9f522a360c" name="ad562f15f35ef21a4965d1b9f522a360c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad562f15f35ef21a4965d1b9f522a360c">&#9670;&#160;</a></span>getMemOperandsWithOffsetWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::getMemOperandsWithOffsetWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>BaseOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OffsetIsScalable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LocationSize.html">LocationSize</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get zero or more base operands and the byte offset of an instruction that reads/writes memory. </p>
<p>Note that there may be zero base operands if the instruction accesses a constant address. It returns false if MI does not read/write memory. It returns false if base operands and offset could not be determined. It is not guaranteed to always recognize base operands and offsets in all cases. FIXME: Move Offset and OffsetIsScalable to some ElementCount-style abstraction that supports negative offsets. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01483">1483</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01424">getMemOperandWithOffset()</a>.</p>

</div>
</div>
<a id="afbbc2492f83b9a1b2b2b850283240272" name="afbbc2492f83b9a1b2b2b850283240272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbc2492f83b9a1b2b2b850283240272">&#9670;&#160;</a></span>getMemOperandWithOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::getMemOperandWithOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>BaseOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OffsetIsScalable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the base operand and byte offset of an instruction that reads/writes memory. </p>
<p>This is a convenience function for callers that are only prepared to handle a single base operand. FIXME: Move Offset and OffsetIsScalable to some ElementCount-style abstraction that supports negative offsets. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01424">1424</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SmallVector_8h_source.html#l00313">llvm::SmallVectorTemplateCommon&lt; T, typename &gt;::front()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01483">getMemOperandsWithOffsetWidth()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="DWP_8cpp_source.html#l00480">llvm::Offset</a>, <a class="el" href="SmallVector_8h_source.html#l00092">llvm::SmallVectorBase&lt; Size_T &gt;::size()</a>, and <a class="el" href="MachineSink_8cpp_source.html#l01928">TRI</a>.</p>

<p class="reference">Referenced by <a class="el" href="MachinePipeliner_8cpp_source.html#l02721">llvm::SwingSchedulerDAG::isLoopCarriedDep()</a>.</p>

</div>
</div>
<a id="a3492aff3468d2d229f1a093379fbdcf7" name="a3492aff3468d2d229f1a093379fbdcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3492aff3468d2d229f1a093379fbdcf7">&#9670;&#160;</a></span>getMIRFormatter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MIRFormatter.html">MIRFormatter</a> * llvm::TargetInstrInfo::getMIRFormatter </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return MIR formatter to format/parse MIR operands. </p>
<p><a class="el" href="classllvm_1_1Target.html" title="Target - Wrapper for Target specific information.">Target</a> can override this virtual function and return target specific MIR formatter. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02216">2216</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a8999c1de8a33ab1a9029e4852342e579" name="a8999c1de8a33ab1a9029e4852342e579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8999c1de8a33ab1a9029e4852342e579">&#9670;&#160;</a></span>getNop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MCInst.html">MCInst</a> TargetInstrInfo::getNop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the noop instruction to use for a noop. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00483">483</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

<p class="reference">Referenced by <a class="el" href="AsmPrinter_8cpp_source.html#l01689">llvm::AsmPrinter::emitFunctionBody()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l03806">llvm::AsmPrinter::emitNops()</a>.</p>

</div>
</div>
<a id="a16bf43322793449e23ced7810ac16ecb" name="a16bf43322793449e23ced7810ac16ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bf43322793449e23ced7810ac16ecb">&#9670;&#160;</a></span>getNumMicroOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetInstrInfo::getNumMicroOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *</td>          <td class="paramname"><span class="paramname"><em>ItinData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of u-operations the given machine instruction will be decoded to on the target cpu. </p>
<p>The itinerary's IssueWidth is the number of microops that can be dispatched each cycle. An instruction with zero microops takes no dispatch resources. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01473">1473</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MCInstrItineraries_8h_source.html#l00127">llvm::InstrItineraryData::isEmpty()</a>, <a class="el" href="MCInstrItineraries_8h_source.html#l00117">llvm::InstrItineraryData::Itineraries</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, and <a class="el" href="MCInstrItineraries_8h_source.html#l00100">llvm::InstrItinerary::NumMicroOps</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetSchedule_8cpp_source.html#l00095">llvm::TargetSchedModel::getNumMicroOps()</a>.</p>

</div>
</div>
<a id="a29b6d3fde7f1a20c72a6a7b4eeb4164f" name="a29b6d3fde7f1a20c72a6a7b4eeb4164f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b6d3fde7f1a20c72a6a7b4eeb4164f">&#9670;&#160;</a></span>getOpcodeAfterMemoryUnfold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getOpcodeAfterMemoryUnfold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>UnfoldLoad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>UnfoldStore</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *</td>          <td class="paramname"><span class="paramname"><em>LoadRegIndex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the opcode of the would be new instruction after load / store are unfolded from an instruction of the specified opcode. </p>
<p>It returns zero if the specified unfolding is not possible. If LoadRegIndex is non-null, it is filled in with the operand index of the operand which will hold the register holding the loaded value. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01435">1435</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a9b1e693dee703f46fd28221e99d4acff" name="a9b1e693dee703f46fd28221e99d4acff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1e693dee703f46fd28221e99d4acff">&#9670;&#160;</a></span>getOperandLatency() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; TargetInstrInfo::getOperandLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *</td>          <td class="paramname"><span class="paramname"><em>ItinData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DefMI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DefIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UseMI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>UseIdx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and return the use operand latency of a given pair of def and use. </p>
<p>Both DefMI and UseMI must be valid.</p>
<p>In most cases, the static scheduling itinerary was enough to determine the operand latency. But it may not be possible for instructions with variable number of defs / uses.</p>
<p>This is a raw interface to the itinerary that may be directly overridden by a target. <a class="el" href="classllvm_1_1Use.html" title="A Use represents the edge between a Value definition and its users.">Use</a> computeOperandLatency to get the best estimate of latency.</p>
<p>By default, call directly to the itinerary. This may be overriden by the target. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01643">1643</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="AArch64ExpandPseudoInsts_8cpp_source.html#l00111">DefMI</a>, <a class="el" href="MCInstrItineraries_8h_source.html#l00208">llvm::InstrItineraryData::getOperandLatency()</a>, and <a class="el" href="AArch64ExpandPseudoInsts_8cpp_source.html#l00110">UseMI</a>.</p>

</div>
</div>
<a id="aa65c4a19ddc8ce7ddec084e5a1a4a62a" name="aa65c4a19ddc8ce7ddec084e5a1a4a62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65c4a19ddc8ce7ddec084e5a1a4a62a">&#9670;&#160;</a></span>getOperandLatency() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; TargetInstrInfo::getOperandLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1InstrItineraryData.html">InstrItineraryData</a> *</td>          <td class="paramname"><span class="paramname"><em>ItinData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>DefNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DefIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>UseNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>UseIdx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01442">1442</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MCInstrInfo_8h_source.html#l00063">llvm::MCInstrInfo::get()</a>, <a class="el" href="SelectionDAGNodes_8h_source.html#l00730">llvm::SDNode::getMachineOpcode()</a>, <a class="el" href="MCInstrItineraries_8h_source.html#l00168">llvm::InstrItineraryData::getOperandCycle()</a>, <a class="el" href="MCInstrItineraries_8h_source.html#l00208">llvm::InstrItineraryData::getOperandLatency()</a>, <a class="el" href="MCInstrDesc_8h_source.html#l00600">llvm::MCInstrDesc::getSchedClass()</a>, <a class="el" href="MCInstrItineraries_8h_source.html#l00127">llvm::InstrItineraryData::isEmpty()</a>, and <a class="el" href="SelectionDAGNodes_8h_source.html#l00725">llvm::SDNode::isMachineOpcode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScheduleDAGSDNodes_8cpp_source.html#l00650">llvm::ScheduleDAGSDNodes::computeOperandLatency()</a>, <a class="el" href="TargetSchedule_8cpp_source.html#l00173">llvm::TargetSchedModel::computeOperandLatency()</a>, and <a class="el" href="HexagonInstrInfo_8cpp_source.html#l04327">llvm::HexagonInstrInfo::getOperandLatency()</a>.</p>

</div>
</div>
<a id="a0028f0ee9f737ba5290254b7924accbb" name="a0028f0ee9f737ba5290254b7924accbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0028f0ee9f737ba5290254b7924accbb">&#9670;&#160;</a></span>getOutlinableRanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::pair&lt; <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a>, <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> &gt; &gt; llvm::TargetInstrInfo::getOutlinableRanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Flags</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional target hook which partitions <code>MBB</code> into outlinable ranges for instruction mapping purposes. </p>
<p>Each range is defined by two iterators: [start, end).</p>
<p>Ranges are expected to be ordered top-down. That is, ranges closer to the top of the block should come before ranges closer to the end of the block.</p>
<p>Ranges cannot overlap.</p>
<p>If an entire block is mappable, then its range is [MBB.begin(), MBB.end())</p>
<p>All instructions not present in an outlinable range are considered illegal. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02137">2137</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>.</p>

</div>
</div>
<a id="ac3bd21a4fb5df9bcff11eee0200dab0b" name="ac3bd21a4fb5df9bcff11eee0200dab0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bd21a4fb5df9bcff11eee0200dab0b">&#9670;&#160;</a></span>getOutliningCandidateInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; <a class="el" href="structllvm_1_1outliner_1_1OutlinedFunction.html">outliner::OutlinedFunction</a> &gt; llvm::TargetInstrInfo::getOutliningCandidateInfo </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structllvm_1_1outliner_1_1Candidate.html">outliner::Candidate</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>RepeatedSequenceLocs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="structllvm_1_1outliner_1_1OutlinedFunction.html" title="The information necessary to create an outlined function for some class of candidate.">outliner::OutlinedFunction</a></code> struct containing target-specific information for a set of outlining candidates. </p>
<p>Returns std::nullopt if the candidates are not suitable for outlining. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02091">2091</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="a3916a50b6bf4f9591b5b7fcd2ad356dd" name="a3916a50b6bf4f9591b5b7fcd2ad356dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3916a50b6bf4f9591b5b7fcd2ad356dd">&#9670;&#160;</a></span>getOutliningType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacellvm_1_1outliner.html#a0765e098fe7aae0f01b60ec890ac1b52">outliner::InstrType</a> TargetInstrInfo::getOutliningType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MIT</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Flags</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns how or if <code>MIT</code> should be outlined. </p>
<p><code>Flags</code> is the target-specific information returned by isMBBSafeToOutlineFrom. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01812">1812</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l02106">getOutliningTypeImpl()</a>, <a class="el" href="MachineOutliner_8h_source.html#l00033">llvm::outliner::Illegal</a>, <a class="el" href="MachineOutliner_8h_source.html#l00033">llvm::outliner::Invisible</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01593">isPredicated()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="a6616508bb5d488d06f8122df46e3930c" name="a6616508bb5d488d06f8122df46e3930c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6616508bb5d488d06f8122df46e3930c">&#9670;&#160;</a></span>getOutliningTypeImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacellvm_1_1outliner.html#a0765e098fe7aae0f01b60ec890ac1b52">outliner::InstrType</a> llvm::TargetInstrInfo::getOutliningTypeImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MIT</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Flags</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target-dependent implementation for getOutliningTypeImpl. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02106">2106</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01812">getOutliningType()</a>.</p>

</div>
</div>
<a id="a14308e147ea57526f7fd1198ab551a9a" name="a14308e147ea57526f7fd1198ab551a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14308e147ea57526f7fd1198ab551a9a">&#9670;&#160;</a></span>getPartialRegUpdateClearance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getPartialRegUpdateClearance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>OpNum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the preferred minimum clearance before an instruction with an unwanted partial register update. </p>
<p>Some instructions only write part of a register, and implicitly need to read the other parts of the register. This may cause unwanted stalls preventing otherwise unrelated instructions from executing in parallel in an out-of-order CPU.</p>
<p>For example, the x86 instruction cvtsi2ss writes its result to bits [31:0] of the destination xmm register. Bits [127:32] are unaffected, so the instruction needs to wait for the old value of the register to become available:</p>
<p>addps xmm1, xmm0 movaps xmm0, (rax) cvtsi2ss rbx, xmm0</p>
<p>In the code above, the cvtsi2ss instruction needs to wait for the addps instruction before it can issue, even though the high bits of xmm0 probably aren't needed.</p>
<p>This hook returns the preferred clearance before MI, measured in instructions. Other defs of MI's operand OpNum are avoided in the last N instructions before MI. It should only return a positive value for unwanted dependencies. If the old bits of the defined register have useful values, or if MI is determined to otherwise read the dependency, the hook should return 0.</p>
<p>The unwanted dependency may be handled by:</p>
<ol type="1">
<li>Allocating the same register for an MI def and use. That makes the unwanted dependency identical to a required dependency.</li>
<li>Allocating a register for the def that has no defs in the previous N instructions.</li>
<li>Calling <a class="el" href="#a525a9aaabc1362deb245b0099ea5538e" title="Insert a dependency-breaking instruction before MI to eliminate an unwanted dependency on OpNum.">breakPartialRegDependency()</a> with the same arguments. This allows the target to insert a dependency breaking instruction. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01900">1900</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a34a028c45f323009b51ef27c5f5814a2" name="a34a028c45f323009b51ef27c5f5814a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a028c45f323009b51ef27c5f5814a2">&#9670;&#160;</a></span>getPatchpointUnfoldableRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; TargetInstrInfo::getPatchpointUnfoldableRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a patchpoint, stackmap, or statepoint intrinsic, return the range of operands which can't be folded into stack references. </p>
<p>Operands outside of the range are most likely foldable but it is not guaranteed. These instructions are unique in that stack references for some operands have the same execution cost (e.g. none) as the unfolded register forms. The ranged return is guaranteed to include all operands which can't be folded at zero cost. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00486">486</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="ad89d6efd5d16c7e44f26ef26296e13aa" name="ad89d6efd5d16c7e44f26ef26296e13aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89d6efd5d16c7e44f26ef26296e13aa">&#9670;&#160;</a></span>getPredicationCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetInstrInfo::getPredicationCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01500">1500</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

</div>
</div>
<a id="a99ccb406a2c930b241430e6b7b3d1a4f" name="a99ccb406a2c930b241430e6b7b3d1a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ccb406a2c930b241430e6b7b3d1a4f">&#9670;&#160;</a></span>getReassociateOperandIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TargetInstrInfo::getReassociateOperandIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="classunsigned.html">unsigned</a>, 5 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OperandIndices</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The returned array encodes the operand index for each parameter because the operands may be commuted; the operand indices for associative operations might also be target-specific. </p>
<p>Each element specifies the index of {Prev, A, B, X, Y}. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01058">1058</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00031">llvm::REASSOC_AX_BY</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00032">llvm::REASSOC_AX_YB</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00033">llvm::REASSOC_XA_BY</a>, and <a class="el" href="MachineCombinerPattern_8h_source.html#l00034">llvm::REASSOC_XA_YB</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01247">genAlternativeCodeSequence()</a>, and <a class="el" href="RISCVInstrInfo_8cpp_source.html#l01862">llvm::RISCVInstrInfo::getReassociateOperandIndices()</a>.</p>

</div>
</div>
<a id="a903e4ccbdb00b36a08f5e84a8010c3cd" name="a903e4ccbdb00b36a08f5e84a8010c3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903e4ccbdb00b36a08f5e84a8010c3cd">&#9670;&#160;</a></span>getReassociationOpcodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; TargetInstrInfo::getReassociationOpcodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Prev</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reassociation of some instructions requires inverse operations (e.g. </p>
<p>(X + A) - Y =&gt; (X - Y) + A). This method returns a pair of new opcodes (new root opcode, new prev opcode) that must be used to reassociate \P Root and \P Prev accoring to \P <a class="el" href="classllvm_1_1Pattern.html">Pattern</a>. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00954">954</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8cpp_source.html#l00852">areOpcodesEqualOrInverse()</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01261">getInverseOpcode()</a>, <a class="el" href="MachineInstr_8h_source.html#l00569">llvm::MachineInstr::getOpcode()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01254">isAssociativeAndCommutative()</a>, <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00031">llvm::REASSOC_AX_BY</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00032">llvm::REASSOC_AX_YB</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00033">llvm::REASSOC_XA_BY</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00034">llvm::REASSOC_XA_YB</a>, and <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01081">reassociateOps()</a>.</p>

</div>
</div>
<a id="af81ceec76ff4ca95f29b037c28a54ba7" name="af81ceec76ff4ca95f29b037c28a54ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81ceec76ff4ca95f29b037c28a54ba7">&#9670;&#160;</a></span>getRegClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterClass.html">TargetRegisterClass</a> * TargetInstrInfo::getRegClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MCInstrDesc.html">MCInstrDesc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MCID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>OpNum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a machine instruction descriptor, returns the register class constraint for OpNum, or NULL. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00048">48</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MCInstrDesc_8h_source.html#l00237">llvm::MCInstrDesc::getNumOperands()</a>, <a class="el" href="MCInstrDesc_8h_source.html#l00239">llvm::MCInstrDesc::operands()</a>, and <a class="el" href="MachineSink_8cpp_source.html#l01928">TRI</a>.</p>

<p class="reference">Referenced by <a class="el" href="FastISel_8cpp_source.html#l02020">llvm::FastISel::constrainOperandRegClass()</a>, and <a class="el" href="X86InstrInfo_8cpp_source.html#l00094">llvm::X86InstrInfo::getRegClass()</a>.</p>

</div>
</div>
<a id="ae26cac7943070f09b4d7fa667d1adf95" name="ae26cac7943070f09b4d7fa667d1adf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26cac7943070f09b4d7fa667d1adf95">&#9670;&#160;</a></span>getRegSequenceInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::getRegSequenceInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DefIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InputRegs</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the equivalent inputs of a REG_SEQUENCE for the given <code>MI</code> and <code>DefIdx</code>. </p>
<p><code></code>[out] InputRegs of the equivalent REG_SEQUENCE. Each element of the list is modeled as &lt;Reg:SubReg, SubIdx&gt;. Operands with the undef flag are not added to this list. E.g., REG_SEQUENCE %1:sub1, sub0, %2, sub1 would produce two elements:</p><ul>
<li>%1:sub1, sub0</li>
<li>%2&lt;:0&gt;, sub1</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if it is possible to build such an input sequence with the pair <code>MI</code>, <code>DefIdx</code>. False otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>MI.isRegSequence() or MI.isRegSequenceLike().</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The generic implementation does not provide any support for MI.isRegSequenceLike(). In other words, one has to override getRegSequenceLikeInputs for target specific instructions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01651">1651</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="MachineOperand_8h_source.html#l00556">llvm::MachineOperand::getImm()</a>, <a class="el" href="MachineOperand_8h_source.html#l00369">llvm::MachineOperand::getReg()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01377">getRegSequenceLikeInputs()</a>, <a class="el" href="MachineOperand_8h_source.html#l00374">llvm::MachineOperand::getSubReg()</a>, <a class="el" href="MachineOperand_8h_source.html#l00331">llvm::MachineOperand::isImm()</a>, <a class="el" href="MachineOperand_8h_source.html#l00404">llvm::MachineOperand::isUndef()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, and <a class="el" href="SmallVector_8h_source.html#l00427">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>.</p>

</div>
</div>
<a id="a52e026925b73de52f7a563693ebff007" name="a52e026925b73de52f7a563693ebff007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e026925b73de52f7a563693ebff007">&#9670;&#160;</a></span>getRegSequenceLikeInputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::getRegSequenceLikeInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DefIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structllvm_1_1TargetInstrInfo_1_1RegSubRegPairAndIdx.html">RegSubRegPairAndIdx</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InputRegs</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target-dependent implementation of getRegSequenceInputs. </p>
<dl class="section return"><dt>Returns</dt><dd>true if it is possible to build the equivalent REG_SEQUENCE inputs with the pair <code>MI</code>, <code>DefIdx</code>. False otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>MI.isRegSequenceLike().</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae26cac7943070f09b4d7fa667d1adf95" title="Build the equivalent inputs of a REG_SEQUENCE for the given MI and DefIdx.">TargetInstrInfo::getRegSequenceInputs</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01377">1377</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01651">getRegSequenceInputs()</a>.</p>

</div>
</div>
<a id="a6150cd07e9535b7e02d53953a1a54cdb" name="a6150cd07e9535b7e02d53953a1a54cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6150cd07e9535b7e02d53953a1a54cdb">&#9670;&#160;</a></span>getReturnOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getReturnOpcode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00251">251</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a82ef2aeaba3f310827d58a0a3b16cfd8" name="a82ef2aeaba3f310827d58a0a3b16cfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ef2aeaba3f310827d58a0a3b16cfd8">&#9670;&#160;</a></span>getSerializableBitmaskMachineOperandTargetFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> * &gt; &gt; llvm::TargetInstrInfo::getSerializableBitmaskMachineOperandTargetFlags </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array that contains the bitmask target flag values and their names. </p>
<p>MIR Serialization is able to serialize only the target flags that are defined by this method. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02029">2029</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="aefb630da1cbdfc0d8425933e20b37a73" name="aefb630da1cbdfc0d8425933e20b37a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb630da1cbdfc0d8425933e20b37a73">&#9670;&#160;</a></span>getSerializableDirectMachineOperandTargetFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> * &gt; &gt; llvm::TargetInstrInfo::getSerializableDirectMachineOperandTargetFlags </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array that contains the direct target flag values and their names. </p>
<p>MIR Serialization is able to serialize only the target flags that are defined by this method. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02019">2019</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a27e0bf9b6a35f938342ed56dfcfe7786" name="a27e0bf9b6a35f938342ed56dfcfe7786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e0bf9b6a35f938342ed56dfcfe7786">&#9670;&#160;</a></span>getSerializableMachineMemOperandTargetFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classllvm_1_1MachineMemOperand.html#aaa2020e47e35179234b9ea27d555b2dd">MachineMemOperand::Flags</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> * &gt; &gt; llvm::TargetInstrInfo::getSerializableMachineMemOperandTargetFlags </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array that contains the MMO target flag values and their names. </p>
<p>MIR Serialization is able to serialize only the MMO target flags that are defined by this method. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02039">2039</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a3d3166a8e59fbea4a6f27fefd6a8fea1" name="a3d3166a8e59fbea4a6f27fefd6a8fea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3166a8e59fbea4a6f27fefd6a8fea1">&#9670;&#160;</a></span>getSerializableTargetIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; int, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> * &gt; &gt; llvm::TargetInstrInfo::getSerializableTargetIndices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array that contains the ids of the target indices (used for the TargetIndex machine operand) and their names. </p>
<p>MIR Serialization is able to serialize only the target indices that are defined by this method. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02002">2002</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a1e4f8b28a8543924e7e3e566a847e691" name="a1e4f8b28a8543924e7e3e566a847e691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4f8b28a8543924e7e3e566a847e691">&#9670;&#160;</a></span>getSPAdjust()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int TargetInstrInfo::getSPAdjust </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the actual stack pointer adjustment made by an instruction as part of a call sequence. </p>
<p>By default, only call frame setup/destroy instructions adjust the stack, but targets may want to override this to enable more fine-grained adjustment, or adjust by a different value. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01351">1351</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetFrameLowering_8h_source.html#l00114">llvm::TargetFrameLowering::alignSPAdjust()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00211">getCallFrameDestroyOpcode()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00210">getCallFrameSetupOpcode()</a>, <a class="el" href="TargetSubtargetInfo_8h_source.html#l00097">llvm::TargetSubtargetInfo::getFrameLowering()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00232">getFrameSize()</a>, <a class="el" href="TargetFrameLowering_8h_source.html#l00094">llvm::TargetFrameLowering::getStackGrowthDirection()</a>, <a class="el" href="MachineFunction_8h_source.html#l00717">llvm::MachineFunction::getSubtarget()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00214">isFrameInstr()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, and <a class="el" href="TargetFrameLowering_8h_source.html#l00049">llvm::TargetFrameLowering::StackGrowsDown</a>.</p>

</div>
</div>
<a id="a5cf58df95b00905950bdfee515cd5e9d" name="a5cf58df95b00905950bdfee515cd5e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf58df95b00905950bdfee515cd5e9d">&#9670;&#160;</a></span>getStackSlotRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::getStackSlotRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterClass.html">TargetRegisterClass</a> *</td>          <td class="paramname"><span class="paramname"><em>RC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>SubIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the size in bytes and offset within a stack slot of a spilled register or subregister. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Size</td><td>in bytes of the spilled value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Offset</td><td>in bytes within the stack slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both Size and Offset are successfully computed.</dd></dl>
<p>Not all subregisters have computable spill slots. For example, subregisters registers may not be byte-sized, and a pair of discontiguous subregisters has no single offset.</p>
<p>Targets with nontrivial bigendian implementations may need to override this, particularly to support spilled vector registers. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00388">388</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="MachineFunction_8cpp_source.html#l00309">llvm::MachineFunction::getDataLayout()</a>, <a class="el" href="TargetSubtargetInfo_8h_source.html#l00128">llvm::TargetSubtargetInfo::getRegisterInfo()</a>, <a class="el" href="MachineFunction_8h_source.html#l00717">llvm::MachineFunction::getSubtarget()</a>, <a class="el" href="DataLayout_8h_source.html#l00238">llvm::DataLayout::isLittleEndian()</a>, <a class="el" href="DWP_8cpp_source.html#l00480">llvm::Offset</a>, <a class="el" href="ELFObjHandler_8cpp_source.html#l00081">Size</a>, and <a class="el" href="MachineSink_8cpp_source.html#l01928">TRI</a>.</p>

</div>
</div>
<a id="af1fbe2cfd4ac1e373cdaba16ec4a70b4" name="af1fbe2cfd4ac1e373cdaba16ec4a70b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1fbe2cfd4ac1e373cdaba16ec4a70b4">&#9670;&#160;</a></span>getTailDuplicateSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getTailDuplicateSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#a8ec1bf8d7b792ca9fac56f8514db18d2">CodeGenOptLevel</a></td>          <td class="paramname"><span class="paramname"><em>OptLevel</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the target-specific default value for tail duplication. </p>
<p>This value will be used if the tail-dup-placement-threshold argument is not provided. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02225">2225</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a8ec1bf8d7b792ca9fac56f8514db18d2a389a96d0d9b3feb46b8c9d941566a4ae">llvm::Aggressive</a>.</p>

</div>
</div>
<a id="a9acee94fe64ebb7dc672f6e5697fbe6b" name="a9acee94fe64ebb7dc672f6e5697fbe6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acee94fe64ebb7dc672f6e5697fbe6b">&#9670;&#160;</a></span>getTailMergeSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getTailMergeSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the target-specific default value for tail merging. </p>
<p>This value will be used if the tail-merge-size argument is not provided. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02231">2231</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="BranchFolding_8cpp_source.html#l00180">llvm::BranchFolder::OptimizeFunction()</a>.</p>

</div>
</div>
<a id="af6cbdb78a500dfae42d591bb8d00b557" name="af6cbdb78a500dfae42d591bb8d00b557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cbdb78a500dfae42d591bb8d00b557">&#9670;&#160;</a></span>getUndefInitOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getUndefInitOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>RegClassID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the opcode for the Pseudo <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> used to initialize the undef value. </p>
<p>If no <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> is available, this will fail compilation. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02271">2271</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="a4159fd0062dd97fe920f738c776a7356" name="a4159fd0062dd97fe920f738c776a7356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4159fd0062dd97fe920f738c776a7356">&#9670;&#160;</a></span>getUndefRegClearance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::getUndefRegClearance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>OpNum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum clearance before an instruction that reads an unused register. </p>
<p>For example, AVX instructions may copy part of a register operand into the unused high bits of the destination register.</p>
<p>vcvtsi2sdq rax, undef xmm0, xmm14</p>
<p>In the code above, vcvtsi2sdq copies xmm0[127:64] into xmm14 creating a false dependence on any previous write to xmm0.</p>
<p>This hook works similarly to getPartialRegUpdateClearance, except that it does not take an operand index. Instead sets <code>OpNum</code> to the index of the unused register. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01920">1920</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="ae698a81cf1a8b23582f2964f57581dc2" name="ae698a81cf1a8b23582f2964f57581dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae698a81cf1a8b23582f2964f57581dc2">&#9670;&#160;</a></span>hasCommutePreference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::hasCommutePreference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Commute</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the target has a preference on the operands order of the given machine instruction. </p>
<p>And specify if <code>Commute</code> is required to get the desired operands order. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00497">497</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a4993bfe73a55f4fcc5d02d09c410ddaf" name="a4993bfe73a55f4fcc5d02d09c410ddaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4993bfe73a55f4fcc5d02d09c410ddaf">&#9670;&#160;</a></span>hasHighOperandLatency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::hasHighOperandLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetSchedModel.html">TargetSchedModel</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SchedModel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>MRI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DefMI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DefIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UseMI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>UseIdx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute operand latency between a def of 'Reg' and a use in the current loop. </p>
<p>Return true if the target considered it 'high'. This is used by optimization passes such as machine LICM to determine whether it makes sense to hoist an instruction out even in a high register pressure situation. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01810">1810</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="ae3c237cad94f54f0d82a18a131709d41" name="ae3c237cad94f54f0d82a18a131709d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c237cad94f54f0d82a18a131709d41">&#9670;&#160;</a></span>hasLoadFromStackSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::hasLoadFromStackSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineMemOperand.html">MachineMemOperand</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Accesses</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the specified machine instruction has a load from a stack slot, return true along with the FrameIndices of the loaded stack slot and the machine mem operands containing the reference. </p>
<p>If not, return false. Unlike isLoadFromStackSlot, this returns true for any instructions that loads from the stack. This is just a hint, as some cases may be missed. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00360">360</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00682">llvm::isa_and_nonnull()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="SmallVector_8h_source.html#l00427">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>, and <a class="el" href="SmallVector_8h_source.html#l00092">llvm::SmallVectorBase&lt; Size_T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HexagonInstrInfo_8cpp_source.html#l00388">llvm::HexagonInstrInfo::hasLoadFromStackSlot()</a>.</p>

</div>
</div>
<a id="a0aa73253579dd1c4acde85953454e838" name="a0aa73253579dd1c4acde85953454e838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa73253579dd1c4acde85953454e838">&#9670;&#160;</a></span>hasLowDefLatency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::hasLowDefLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetSchedModel.html">TargetSchedModel</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SchedModel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DefMI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DefIdx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute operand latency of a def of 'Reg'. </p>
<p>Return true if the target considered it 'low'. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01515">1515</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="AArch64ExpandPseudoInsts_8cpp_source.html#l00111">DefMI</a>, <a class="el" href="TargetSchedule_8h_source.html#l00082">llvm::TargetSchedModel::getInstrItineraries()</a>, <a class="el" href="MCInstrItineraries_8h_source.html#l00168">llvm::InstrItineraryData::getOperandCycle()</a>, and <a class="el" href="MCInstrItineraries_8h_source.html#l00127">llvm::InstrItineraryData::isEmpty()</a>.</p>

</div>
</div>
<a id="a6034cfb230c4698caa60bdc3a9bf209b" name="a6034cfb230c4698caa60bdc3a9bf209b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6034cfb230c4698caa60bdc3a9bf209b">&#9670;&#160;</a></span>hasReassociableOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::hasReassociableOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Inst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true when \P Inst has reassociable operands in the same \P MBB. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00833">833</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineInstr_8h_source.html#l00579">llvm::MachineInstr::getOperand()</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l00310">llvm::MachineBasicBlock::getParent()</a>, <a class="el" href="MachineInstr_8h_source.html#l00346">llvm::MachineInstr::getParent()</a>, <a class="el" href="MachineOperand_8h_source.html#l00369">llvm::MachineOperand::getReg()</a>, <a class="el" href="MachineFunction_8h_source.html#l00727">llvm::MachineFunction::getRegInfo()</a>, <a class="el" href="MachineOperand_8h_source.html#l00329">llvm::MachineOperand::isReg()</a>, <a class="el" href="Register_8h_source.html#l00091">llvm::Register::isVirtual()</a>, <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>, and <a class="el" href="AArch64AdvSIMDScalarPass_8cpp_source.html#l00105">MRI</a>.</p>

<p class="reference">Referenced by <a class="el" href="RISCVInstrInfo_8cpp_source.html#l01839">llvm::RISCVInstrInfo::hasReassociableOperands()</a>, <a class="el" href="X86InstrInfo_8cpp_source.html#l09623">llvm::X86InstrInfo::hasReassociableOperands()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00857">hasReassociableSibling()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l00892">isReassociationCandidate()</a>.</p>

</div>
</div>
<a id="aea784a4f9e9aba7792c23484e2498e8d" name="aea784a4f9e9aba7792c23484e2498e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea784a4f9e9aba7792c23484e2498e8d">&#9670;&#160;</a></span>hasReassociableSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::hasReassociableSibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Inst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Commuted</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true when \P Inst has reassociable sibling. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00857">857</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8cpp_source.html#l00852">areOpcodesEqualOrInverse()</a>, <a class="el" href="MachineInstr_8h_source.html#l00569">llvm::MachineInstr::getOpcode()</a>, <a class="el" href="MachineInstr_8h_source.html#l00579">llvm::MachineInstr::getOperand()</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l00310">llvm::MachineBasicBlock::getParent()</a>, <a class="el" href="MachineInstr_8h_source.html#l00346">llvm::MachineInstr::getParent()</a>, <a class="el" href="MachineOperand_8h_source.html#l00369">llvm::MachineOperand::getReg()</a>, <a class="el" href="MachineFunction_8h_source.html#l00727">llvm::MachineFunction::getRegInfo()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00833">hasReassociableOperands()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01254">isAssociativeAndCommutative()</a>, <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>, <a class="el" href="AArch64AdvSIMDScalarPass_8cpp_source.html#l00105">MRI</a>, and <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RISCVInstrInfo_8cpp_source.html#l01873">llvm::RISCVInstrInfo::hasReassociableSibling()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l00892">isReassociationCandidate()</a>.</p>

</div>
</div>
<a id="a5df2834716ee814af9f2555897ecb932" name="a5df2834716ee814af9f2555897ecb932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df2834716ee814af9f2555897ecb932">&#9670;&#160;</a></span>hasStoreToStackSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::hasStoreToStackSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineMemOperand.html">MachineMemOperand</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Accesses</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the specified machine instruction has a store to a stack slot, return true along with the FrameIndices of the loaded stack slot and the machine mem operands containing the reference. </p>
<p>If not, return false. Unlike isStoreToStackSlot, this returns true for any instructions that stores to the stack. This is just a hint, as some cases may be missed. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00374">374</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00682">llvm::isa_and_nonnull()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="SmallVector_8h_source.html#l00427">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>, and <a class="el" href="SmallVector_8h_source.html#l00092">llvm::SmallVectorBase&lt; Size_T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HexagonInstrInfo_8cpp_source.html#l00406">llvm::HexagonInstrInfo::hasStoreToStackSlot()</a>.</p>

</div>
</div>
<a id="a762db1f75e789783b689f22cda71bad4" name="a762db1f75e789783b689f22cda71bad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762db1f75e789783b689f22cda71bad4">&#9670;&#160;</a></span>insertBranch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::insertBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>TBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>FBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DL</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>BytesAdded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert branch code into the end of the specified <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a>. </p>
<p>The operands to this method are the same as those returned by analyzeBranch. This is only invoked in cases where analyzeBranch returns success. It returns the number of instructions inserted. If <code>BytesAdded</code> is non-null, report the change in code size from the added instructions.</p>
<p>It is also invoked by tail merging to add unconditional branches in cases where analyzeBranch doesn't apply because there was no original branch to analyze. At least this much must be implemented, else tail merging needs to be disabled.</p>
<p>The CFG information in MBB.Predecessors and MBB.Successors must be valid before calling this function. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00721">721</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

<p class="reference">Referenced by <a class="el" href="FastISel_8cpp_source.html#l01681">llvm::FastISel::fastEmitBranch()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00729">insertUnconditionalBranch()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l00142">ReplaceTailWithBranchTo()</a>.</p>

</div>
</div>
<a id="a25b07e0819e160f78c33a67838dea35c" name="a25b07e0819e160f78c33a67838dea35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b07e0819e160f78c33a67838dea35c">&#9670;&#160;</a></span>insertIndirectBranch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::insertIndirectBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>NewDestBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>RestoreBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DL</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>BrOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1RegScavenger.html">RegScavenger</a> *</td>          <td class="paramname"><span class="paramname"><em>RS</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an unconditional indirect branch at the end of <code>MBB</code> to <code>NewDestBB</code>. </p>
<p>Optionally, insert the clobbered register restoring in <code>RestoreBB</code>. <code>BrOffset</code> indicates the offset of <code>NewDestBB</code> relative to the offset of the position to insert the new branch. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00615">615</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="a4ee57d5d6295dfeb44f3b55301b20020" name="a4ee57d5d6295dfeb44f3b55301b20020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee57d5d6295dfeb44f3b55301b20020">&#9670;&#160;</a></span>insertNoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TargetInstrInfo::insertNoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>MI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a noop into the instruction stream at the specified point. </p>
<p>insertNoop - Insert a noop into the instruction stream at the specified point. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00068">68</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

<p class="reference">Referenced by <a class="el" href="BasicBlockSections_8cpp_source.html#l00265">llvm::avoidZeroOffsetLandingPad()</a>, <a class="el" href="ScheduleDAGSDNodes_8cpp_source.html#l00852">llvm::ScheduleDAGSDNodes::EmitSchedule()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l00075">insertNoops()</a>.</p>

</div>
</div>
<a id="ab2c15ac4d0e9521ba7225f100f657639" name="ab2c15ac4d0e9521ba7225f100f657639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c15ac4d0e9521ba7225f100f657639">&#9670;&#160;</a></span>insertNoops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TargetInstrInfo::insertNoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Quantity</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert noops into the instruction stream at the specified point. </p>
<p>insertNoops - Insert noops into the instruction stream at the specified point. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00075">75</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8cpp_source.html#l00068">insertNoop()</a>, <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="ab00242d76e808398358fa1e46e9a6885" name="ab00242d76e808398358fa1e46e9a6885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00242d76e808398358fa1e46e9a6885">&#9670;&#160;</a></span>insertOutlinedCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> llvm::TargetInstrInfo::insertOutlinedCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Module.html">Module</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>It</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1outliner_1_1Candidate.html">outliner::Candidate</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a call to an outlined function into the program. </p>
<p>Returns an iterator to the spot where we inserted the call. This must be implemented by the target. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02152">2152</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="a57cd943142f3f93cebdab2134714793b" name="a57cd943142f3f93cebdab2134714793b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cd943142f3f93cebdab2134714793b">&#9670;&#160;</a></span>insertSelect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::insertSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>I</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DL</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>DstReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>TrueReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>FalseReg</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a select instruction into MBB before I that will copy TrueReg to DstReg when Cond is true, and FalseReg to DstReg when Cond is false. </p>
<p>This function can only be called after <a class="el" href="#ae0990ac346653cb1c820f391ffbf5ed5" title="Return true if it is possible to insert a select instruction that chooses between TrueReg and FalseRe...">canInsertSelect()</a> returned true. The condition in Cond comes from analyzeBranch, and it can be assumed that the same flags or registers required by Cond are available at the insertion point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MBB</td><td>Block where select instruction should be inserted. </td></tr>
    <tr><td class="paramname">I</td><td>Insertion point. </td></tr>
    <tr><td class="paramname">DL</td><td>Source location for debugging. </td></tr>
    <tr><td class="paramname">DstReg</td><td>Virtual register to be defined by select instruction. </td></tr>
    <tr><td class="paramname">Cond</td><td>Condition as computed by analyzeBranch. </td></tr>
    <tr><td class="paramname">TrueReg</td><td>Virtual register to copy when Cond is true. </td></tr>
    <tr><td class="paramname">FalseReg</td><td>Virtual register to copy when Cons is false. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00957">957</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="af382bec94f69d7c5fba1e67e62e6e6da" name="af382bec94f69d7c5fba1e67e62e6e6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af382bec94f69d7c5fba1e67e62e6e6da">&#9670;&#160;</a></span>insertUnconditionalBranch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::insertUnconditionalBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>DestBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DebugLoc.html">DebugLoc</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DL</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>BytesAdded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00729">729</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="ARMSLSHardening_8cpp_source.html#l00073">DL</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00721">insertBranch()</a>, and <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>.</p>

</div>
</div>
<a id="ae4ac5c3f21740cf8f3f63e50de016209" name="ae4ac5c3f21740cf8f3f63e50de016209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ac5c3f21740cf8f3f63e50de016209">&#9670;&#160;</a></span>isAddImmediate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; <a class="el" href="structllvm_1_1RegImmPair.html">RegImmPair</a> &gt; llvm::TargetInstrInfo::isAddImmediate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Reg</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the specific machine instruction is an instruction that adds an immediate value and a register, and stores the result in the given register <code>Reg</code>, return a pair of the source register and the offset which has been added. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01106">1106</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01548">describeLoadedValue()</a>.</p>

</div>
</div>
<a id="a9c5e9ccab2a323465af64b3661172af2" name="a9c5e9ccab2a323465af64b3661172af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5e9ccab2a323465af64b3661172af2">&#9670;&#160;</a></span>isAsCheapAsAMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isAsCheapAsAMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the instruction is as cheap as a move instruction. </p>
<p>Targets for different archs need to override this, and different micro-architectures can also be finely tuned inside. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00386">386</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

<p class="reference">Referenced by <a class="el" href="LiveRangeEdit_8cpp_source.html#l00158">llvm::LiveRangeEdit::canRematerializeAt()</a>.</p>

</div>
</div>
<a id="aa792b566fb2d8e29af95aea690e33201" name="aa792b566fb2d8e29af95aea690e33201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa792b566fb2d8e29af95aea690e33201">&#9670;&#160;</a></span>isAssociativeAndCommutative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isAssociativeAndCommutative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Inst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>Invert</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true when \P Inst is both associative and commutative. </p>
<p>If \P Invert is true, then the inverse of \P Inst operation must be tested. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01254">1254</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00954">getReassociationOpcodes()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00857">hasReassociableSibling()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l00892">isReassociationCandidate()</a>.</p>

</div>
</div>
<a id="a0138c08492e75b8b22f8fe0764b95853" name="a0138c08492e75b8b22f8fe0764b95853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0138c08492e75b8b22f8fe0764b95853">&#9670;&#160;</a></span>isBasicBlockPrologue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isBasicBlockPrologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>Reg</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1Register.html">Register</a>()</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the instruction is bound to the top of its basic block and no other instructions shall be inserted before it. </p>
<p>This can be implemented to prevent register allocator to insert spills for <code>Reg</code> before such instructions. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02054">2054</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a6073542a939859dd8831f4cf9d710393" name="a6073542a939859dd8831f4cf9d710393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6073542a939859dd8831f4cf9d710393">&#9670;&#160;</a></span>isBranchOffsetInRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isBranchOffsetInRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>BranchOpc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>BrOffset</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if a branch from an instruction with opcode <code>BranchOpc</code> bytes is capable of jumping to a position <code>BrOffset</code> bytes away. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00601">601</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="a236fc00ef404f232dcd8b88bbf3a2251" name="a236fc00ef404f232dcd8b88bbf3a2251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236fc00ef404f232dcd8b88bbf3a2251">&#9670;&#160;</a></span>isCoalescableExtInstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isCoalescableExtInstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SrcReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DstReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SubIdx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the instruction is a "coalescable" extension instruction. </p>
<p>That is, it's like a copy where it's legal for the source to overlap the destination. e.g. X86::MOVSX64rr32. If this returns true, then it's expected the pre-extension value is available as a subreg of the result register. This also returns the sub-register index in SubIdx. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00264">264</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="ace5bb5eb8d13b5726f90e7f38df45d60" name="ace5bb5eb8d13b5726f90e7f38df45d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5bb5eb8d13b5726f90e7f38df45d60">&#9670;&#160;</a></span>isCopyInstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structllvm_1_1DestSourcePair.html">DestSourcePair</a> &gt; llvm::TargetInstrInfo::isCopyInstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the specific machine instruction is a instruction that moves/copies value from one register to another register return destination and source registers as machine operands. </p>
<p>For COPY-instruction the method naturally returns destination and source registers as machine operands, for all other instructions the method calls target-dependent implementation. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01077">1077</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l01050">isCopyInstrImpl()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01548">describeLoadedValue()</a>, <a class="el" href="InstrEmitter_8cpp_source.html#l00788">llvm::InstrEmitter::EmitDbgInstrRef()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00634">foldMemoryOperand()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01086">isCopyLikeInstr()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01092">isFullCopyInstr()</a>, and <a class="el" href="SplitKit_8cpp_source.html#l01588">llvm::SplitAnalysis::shouldSplitSingleBlock()</a>.</p>

</div>
</div>
<a id="a7eb5f369839e0987506e72b0ffc1b982" name="a7eb5f369839e0987506e72b0ffc1b982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb5f369839e0987506e72b0ffc1b982">&#9670;&#160;</a></span>isCopyInstrImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; <a class="el" href="structllvm_1_1DestSourcePair.html">DestSourcePair</a> &gt; llvm::TargetInstrInfo::isCopyInstrImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target-dependent implementation for IsCopyInstr. </p>
<p>If the specific machine instruction is a instruction that moves/copies value from one register to another register return destination and source registers as machine operands. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01050">1050</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8h_source.html#l01077">isCopyInstr()</a>.</p>

</div>
</div>
<a id="a82dd4c26bf1be527376323f5c9889fbd" name="a82dd4c26bf1be527376323f5c9889fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dd4c26bf1be527376323f5c9889fbd">&#9670;&#160;</a></span>isCopyLikeInstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structllvm_1_1DestSourcePair.html">DestSourcePair</a> &gt; llvm::TargetInstrInfo::isCopyLikeInstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01086">1086</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l01077">isCopyInstr()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01055">isCopyLikeInstrImpl()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="a13cf72d93ee18d693c7a74f0c1307cea" name="a13cf72d93ee18d693c7a74f0c1307cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cf72d93ee18d693c7a74f0c1307cea">&#9670;&#160;</a></span>isCopyLikeInstrImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; <a class="el" href="structllvm_1_1DestSourcePair.html">DestSourcePair</a> &gt; llvm::TargetInstrInfo::isCopyLikeInstrImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01055">1055</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8h_source.html#l01086">isCopyLikeInstr()</a>.</p>

</div>
</div>
<a id="aa87a4a6ef69b65a33d072718a8e0e25e" name="aa87a4a6ef69b65a33d072718a8e0e25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87a4a6ef69b65a33d072718a8e0e25e">&#9670;&#160;</a></span>isExplicitTargetIndexDef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isExplicitTargetIndexDef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>Index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>Offset</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given <code>MI</code> defines a TargetIndex operand that can be tracked by their offset, can have values, and can have debug info associated with it. </p>
<p>If so, sets <code>Index</code> and <code>Offset</code> of the target index operand. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02250">2250</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a0ec0a63c3d6d45dd9fee9c1115816e0b" name="a0ec0a63c3d6d45dd9fee9c1115816e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec0a63c3d6d45dd9fee9c1115816e0b">&#9670;&#160;</a></span>isExtendLikelyToBeFolded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isExtendLikelyToBeFolded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ExtMI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MRI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the generic extension instruction <code>ExtMI</code>, returns true if this extension is a likely candidate for being folded into an another instruction. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02209">2209</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a524001439888743cdddb9b79c45911d9" name="a524001439888743cdddb9b79c45911d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524001439888743cdddb9b79c45911d9">&#9670;&#160;</a></span>isFrameInstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isFrameInstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the argument is a frame pseudo instruction. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00214">214</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l00211">getCallFrameDestroyOpcode()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00210">getCallFrameSetupOpcode()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8h_source.html#l00232">getFrameSize()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l01351">getSPAdjust()</a>.</p>

</div>
</div>
<a id="ac9cc48fa5e52de97bef32acbb6f76ddc" name="ac9cc48fa5e52de97bef32acbb6f76ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cc48fa5e52de97bef32acbb6f76ddc">&#9670;&#160;</a></span>isFrameSetup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isFrameSetup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the argument is a frame setup pseudo instruction. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00220">220</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l00210">getCallFrameSetupOpcode()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8h_source.html#l00241">getFrameTotalSize()</a>.</p>

</div>
</div>
<a id="a407338aee0ea958defdef5cb3993f1da" name="a407338aee0ea958defdef5cb3993f1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407338aee0ea958defdef5cb3993f1da">&#9670;&#160;</a></span>isFullCopyInstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isFullCopyInstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01092">1092</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="MachineOperand_8h_source.html#l00374">llvm::MachineOperand::getSubReg()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01077">isCopyInstr()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="a6fd9a0614742c8f6c8523b0c34b984ee" name="a6fd9a0614742c8f6c8523b0c34b984ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd9a0614742c8f6c8523b0c34b984ee">&#9670;&#160;</a></span>isFunctionSafeToOutlineFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isFunctionSafeToOutlineFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>OutlineFromLinkOnceODRs</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the function can safely be outlined from. </p>
<p>A function <code>MF</code> is considered safe for outlining if an outlined function produced from instructions in F will produce a program which produces the same output for any set of given inputs. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02178">2178</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="ae0b0cbf92a3dd0f5cab9d5d3067c2003" name="ae0b0cbf92a3dd0f5cab9d5d3067c2003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b0cbf92a3dd0f5cab9d5d3067c2003">&#9670;&#160;</a></span>isFunctionSafeToSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::isFunctionSafeToSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the function is a viable candidate for machine function splitting. </p>
<p>The criteria for if a function can be split may vary by target. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01528">1528</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineFunction_8h_source.html#l00683">llvm::MachineFunction::getFunction()</a>, <a class="el" href="Function_8cpp_source.html#l02088">llvm::Function::getSectionPrefix()</a>, and <a class="el" href="GlobalObject_8h_source.html#l00110">llvm::GlobalObject::hasSection()</a>.</p>

</div>
</div>
<a id="ae60fd4c7626ec53d75182d6f54743745" name="ae60fd4c7626ec53d75182d6f54743745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60fd4c7626ec53d75182d6f54743745">&#9670;&#160;</a></span>isGenericAtomicRMWOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isGenericAtomicRMWOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00126">126</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a82a499274493eca235e684f82ee54b70" name="a82a499274493eca235e684f82ee54b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a499274493eca235e684f82ee54b70">&#9670;&#160;</a></span>isGenericOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isGenericOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00122">122</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="aebbd8a676ca4d2926a87022815a5015d" name="aebbd8a676ca4d2926a87022815a5015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbd8a676ca4d2926a87022815a5015d">&#9670;&#160;</a></span>isHighLatencyDef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isHighLatencyDef </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>opc</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this opcode has high latency to its result. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01803">1803</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScheduleDAGSDNodes_8cpp_source.html#l00616">llvm::ScheduleDAGSDNodes::computeLatency()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l01489">defaultDefLatency()</a>.</p>

</div>
</div>
<a id="a6832cbbc9c9e128eed4484026c539781" name="a6832cbbc9c9e128eed4484026c539781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6832cbbc9c9e128eed4484026c539781">&#9670;&#160;</a></span>isIgnorableUse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isIgnorableUse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MO</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <code>MO</code> is a PhysReg use return if it can be ignored for the purpose of instruction rematerialization or sinking. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00152">152</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LiveRangeEdit_8cpp_source.html#l00106">llvm::LiveRangeEdit::allUsesAvailableAt()</a>.</p>

</div>
</div>
<a id="afa8e907121203db549a15f70f615ef50" name="afa8e907121203db549a15f70f615ef50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8e907121203db549a15f70f615ef50">&#9670;&#160;</a></span>isLegalToSplitMBBAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isLegalToSplitMBBAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>MBBI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if it's legal to split the given basic block at the specified instruction (i.e. </p>
<p>instruction would be the start of a new basic block). </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00845">845</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a6922ec50633977be02ab221c2de2adc1" name="a6922ec50633977be02ab221c2de2adc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6922ec50633977be02ab221c2de2adc1">&#9670;&#160;</a></span>isLoadFromStackSlot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1Register.html">Register</a> llvm::TargetInstrInfo::isLoadFromStackSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>FrameIndex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the specified machine instruction is a direct load from a stack slot, return the virtual or physical register number of the destination along with the FrameIndex of the loaded stack slot. </p>
<p>If not, return 0. This predicate must return 0 if the instruction has any side effects other than loading from the stack slot. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00274">274</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00729">foldMemoryOperand()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00283">isLoadFromStackSlot()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l01272">isReallyTriviallyReMaterializable()</a>.</p>

</div>
</div>
<a id="afb62c4d3c76506ef7a31dc75f98000db" name="afb62c4d3c76506ef7a31dc75f98000db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb62c4d3c76506ef7a31dc75f98000db">&#9670;&#160;</a></span>isLoadFromStackSlot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1Register.html">Register</a> llvm::TargetInstrInfo::isLoadFromStackSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>FrameIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MemBytes</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional extension of isLoadFromStackSlot that returns the number of bytes loaded from the stack. </p>
<p>This must be implemented if a backend supports partial stack slot spills/loads to further disambiguate what the load does. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00283">283</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l00274">isLoadFromStackSlot()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="a8dad862e186c4263edb6f7583754efcc" name="a8dad862e186c4263edb6f7583754efcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dad862e186c4263edb6f7583754efcc">&#9670;&#160;</a></span>isLoadFromStackSlotPostFE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1Register.html">Register</a> llvm::TargetInstrInfo::isLoadFromStackSlotPostFE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>FrameIndex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> for post-frame ptr elimination stack locations as well. </p>
<p>This uses a heuristic so it isn't reliable for correctness. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00292">292</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a952e245a616622682cd83b1291314660" name="a952e245a616622682cd83b1291314660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952e245a616622682cd83b1291314660">&#9670;&#160;</a></span>isMBBSafeToOutlineFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::isMBBSafeToOutlineFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Flags</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional target hook that returns true if <code>MBB</code> is safe to outline from, and returns any target-specific information in <code>Flags</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01889">1889</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineBasicBlock_8h_source.html#l00356">llvm::MachineBasicBlock::end()</a>, <a class="el" href="namespacellvm.html#a9eb4f5b98b70ee4fab9614ed58282c1fa7fb55ed0b7a30342ba6da306428cae04">llvm::First</a>, <a class="el" href="MachineBasicBlock_8cpp_source.html#l00265">llvm::MachineBasicBlock::getFirstNonDebugInstr()</a>, <a class="el" href="MachineBasicBlock_8cpp_source.html#l00271">llvm::MachineBasicBlock::getLastNonDebugInstr()</a>, <a class="el" href="namespacellvm.html#ac10d13c57a7adf4a1f140afd5321309bad55b30607c2a9a2616347d6edb789f6b">llvm::Last</a>, and <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>.</p>

<p class="reference">Referenced by <a class="el" href="RISCVInstrInfo_8cpp_source.html#l02815">llvm::RISCVInstrInfo::isMBBSafeToOutlineFrom()</a>.</p>

</div>
</div>
<a id="a726928467271e18f3d17b2942cd04984" name="a726928467271e18f3d17b2942cd04984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726928467271e18f3d17b2942cd04984">&#9670;&#160;</a></span>isMBBSafeToSplitToCold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isMBBSafeToSplitToCold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> can safely be split to the cold section. </p>
<p>On <a class="el" href="namespacellvm_1_1AArch64.html">AArch64</a>, certain instructions may cause a block to be unsafe to split to the cold section. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02196">2196</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="aaccc261e5cc19c2d41a1ab9fb361cde8" name="aaccc261e5cc19c2d41a1ab9fb361cde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaccc261e5cc19c2d41a1ab9fb361cde8">&#9670;&#160;</a></span>isPCRelRegisterOperandLegal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isPCRelRegisterOperandLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MO</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow targets to tell MachineVerifier whether a specific register <a class="el" href="classllvm_1_1MachineOperand.html" title="MachineOperand class - Representation of each machine instruction operand.">MachineOperand</a> can be used as part of PC-relative addressing. </p>
<p>PC-relative addressing modes in many CISC architectures contain (non-PC) registers as offsets or scaling values, which inherently tags the corresponding <a class="el" href="classllvm_1_1MachineOperand.html" title="MachineOperand class - Representation of each machine instruction operand.">MachineOperand</a> with OPERAND_PCREL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MO</td><td>The <a class="el" href="classllvm_1_1MachineOperand.html" title="MachineOperand class - Representation of each machine instruction operand.">MachineOperand</a> in question. MO.isReg() should always be true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this operand is allowed to be used PC-relatively. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01036">1036</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a1cb223b29cc4acffa9ffd03d134b2a1e" name="a1cb223b29cc4acffa9ffd03d134b2a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb223b29cc4acffa9ffd03d134b2a1e">&#9670;&#160;</a></span>isPostIncrement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isPostIncrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true for post-incremented instructions. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01590">1590</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="adf401885b0d39da5774814718bc889c8" name="adf401885b0d39da5774814718bc889c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf401885b0d39da5774814718bc889c8">&#9670;&#160;</a></span>isPredicable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isPredicable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the specified instruction can be predicated. </p>
<p>By default, this returns true for every instruction with a PredicateOperand. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01657">1657</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

<p class="reference">Referenced by <a class="el" href="R600InstrInfo_8cpp_source.html#l00849">llvm::R600InstrInfo::isPredicable()</a>.</p>

</div>
</div>
<a id="abda2e966ced4c77ce8a78e5e063e07cd" name="abda2e966ced4c77ce8a78e5e063e07cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda2e966ced4c77ce8a78e5e063e07cd">&#9670;&#160;</a></span>isPredicated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isPredicated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the instruction is already predicated. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01593">1593</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CriticalAntiDepBreaker_8cpp_source.html#l00437">llvm::CriticalAntiDepBreaker::BreakAntiDependencies()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01597">canPredicatePredicatedInstr()</a>, <a class="el" href="TargetSchedule_8cpp_source.html#l00274">llvm::TargetSchedModel::computeOutputLatency()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l01812">getOutliningType()</a>, <a class="el" href="RDFGraph_8cpp_source.html#l00589">llvm::rdf::TargetOperandInfo::isPreserving()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l00319">isUnpredicatedTerminator()</a>.</p>

</div>
</div>
<a id="ad5db14e4eee47b5fb139bf333d7f1516" name="ad5db14e4eee47b5fb139bf333d7f1516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5db14e4eee47b5fb139bf333d7f1516">&#9670;&#160;</a></span>isProfitableToDupForIfCvt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isProfitableToDupForIfCvt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumCycles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BranchProbability.html">BranchProbability</a></td>          <td class="paramname"><span class="paramname"><em>Probability</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if it's profitable for if-converter to duplicate instructions of specified accumulated instruction latencies in the specified MBB to enable if-conversion. </p>
<p>The probability of the instructions being executed is given by Probability, and Confidence is a measure of our confidence that it will be properly predicted. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00881">881</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a00b5a36b4d498deae0da42cab63b6b65" name="a00b5a36b4d498deae0da42cab63b6b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b5a36b4d498deae0da42cab63b6b65">&#9670;&#160;</a></span>isProfitableToIfCvt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isProfitableToIfCvt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumCycles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ExtraPredCycles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BranchProbability.html">BranchProbability</a></td>          <td class="paramname"><span class="paramname"><em>Probability</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if it's profitable to predicate instructions with accumulated instruction latency of "NumCycles" of the specified basic block, where the probability of the instructions being executed is given by Probability, and Confidence is a measure of our confidence that it will be properly predicted. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00855">855</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a558a9e2bb84251c5a3dc6fbc2abf6b62" name="a558a9e2bb84251c5a3dc6fbc2abf6b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558a9e2bb84251c5a3dc6fbc2abf6b62">&#9670;&#160;</a></span>isProfitableToIfCvt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isProfitableToIfCvt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>TMBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumTCycles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ExtraTCycles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>FMBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumFCycles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ExtraFCycles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BranchProbability.html">BranchProbability</a></td>          <td class="paramname"><span class="paramname"><em>Probability</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Second variant of isProfitableToIfCvt. </p>
<p>This one checks for the case where two basic blocks from true and false path of a if-then-else (diamond) are predicated on mutually exclusive predicates, where the probability of the true path being taken is given by Probability, and Confidence is a measure of our confidence that it will be properly predicted. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00867">867</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a4c46c756d842143ad24a09a2723be290" name="a4c46c756d842143ad24a09a2723be290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c46c756d842143ad24a09a2723be290">&#9670;&#160;</a></span>isProfitableToUnpredicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isProfitableToUnpredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>TMBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>FMBB</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if it's profitable to unpredicate one side of a 'diamond', i.e. </p>
<p>two sides of if-else predicated on mutually exclusive predicates. e.g. subeq r0, r1, #1 addne r0, r1, #1 =&gt; sub r0, r1, #1 addne r0, r1, #1</p>
<p>This may be profitable is conditional instructions are always executed. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00911">911</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="ab671544f7af287b25a5e612f6e919975" name="ab671544f7af287b25a5e612f6e919975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab671544f7af287b25a5e612f6e919975">&#9670;&#160;</a></span>isReallyTriviallyReMaterializable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::isReallyTriviallyReMaterializable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For instructions with opcodes for which the M_REMATERIALIZABLE flag is set, this hook lets the target specify whether the instruction is actually trivially rematerializable, taking into consideration its operands. </p>
<p>This predicate must return false if the instruction has any side effects other than producing a value, or if it requres any address registers that are not always available. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01272">1272</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineFunction_8h_source.html#l00733">llvm::MachineFunction::getFrameInfo()</a>, <a class="el" href="MachineFunction_8h_source.html#l00727">llvm::MachineFunction::getRegInfo()</a>, <a class="el" href="MachineFrameInfo_8h_source.html#l00720">llvm::MachineFrameInfo::isImmutableObjectIndex()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00274">isLoadFromStackSlot()</a>, <a class="el" href="Register_8h_source.html#l00091">llvm::Register::isVirtual()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, and <a class="el" href="AArch64AdvSIMDScalarPass_8cpp_source.html#l00105">MRI</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPCInstrInfo_8cpp_source.html#l01079">llvm::PPCInstrInfo::isReallyTriviallyReMaterializable()</a>, <a class="el" href="RISCVInstrInfo_8cpp_source.html#l00169">llvm::RISCVInstrInfo::isReallyTriviallyReMaterializable()</a>, <a class="el" href="SIInstrInfo_8cpp_source.html#l00124">llvm::SIInstrInfo::isReallyTriviallyReMaterializable()</a>, <a class="el" href="WebAssemblyInstrInfo_8cpp_source.html#l00042">llvm::WebAssemblyInstrInfo::isReallyTriviallyReMaterializable()</a>, <a class="el" href="X86InstrInfo_8cpp_source.html#l00773">llvm::X86InstrInfo::isReallyTriviallyReMaterializable()</a>, and <a class="el" href="TargetInstrInfo_8h_source.html#l00143">isTriviallyReMaterializable()</a>.</p>

</div>
</div>
<a id="ace9f804c4f1407df72588bb00db16deb" name="ace9f804c4f1407df72588bb00db16deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9f804c4f1407df72588bb00db16deb">&#9670;&#160;</a></span>isReassociationCandidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::isReassociationCandidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Inst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Commuted</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the input \P Inst is part of a chain of dependent ops that are suitable for reassociation, otherwise return false. </p>
<p>If the instruction's operands must be commuted to have a previous instruction of the same type define the first source operand, \P Commuted will be set to true. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00892">892</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineInstr_8h_source.html#l00346">llvm::MachineInstr::getParent()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00833">hasReassociableOperands()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00857">hasReassociableSibling()</a>, and <a class="el" href="TargetInstrInfo_8h_source.html#l01254">isAssociativeAndCommutative()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00921">getMachineCombinerPatterns()</a>.</p>

</div>
</div>
<a id="adf676347c6bf8157f319dac9e601f168" name="adf676347c6bf8157f319dac9e601f168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf676347c6bf8157f319dac9e601f168">&#9670;&#160;</a></span>isSafeToMoveRegClassDefs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isSafeToMoveRegClassDefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterClass.html">TargetRegisterClass</a> *</td>          <td class="paramname"><span class="paramname"><em>RC</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if it's safe to move a machine instruction that defines the specified register class. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01663">1663</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a104cb332d459987fabfe9d7073150287" name="a104cb332d459987fabfe9d7073150287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104cb332d459987fabfe9d7073150287">&#9670;&#160;</a></span>isSafeToSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isSafeToSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>SuccToSinkTo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm.html#aee433bfa58b17266f2cff728e02fba26">MachineCycleInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>CI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00156">156</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="ad071e937f4986e51fd3fd54b10888894" name="ad071e937f4986e51fd3fd54b10888894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad071e937f4986e51fd3fd54b10888894">&#9670;&#160;</a></span>isSchedulingBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::isSchedulingBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the given instruction should be considered a scheduling boundary. </p>
<p>isSchedulingBoundary - Test if the given instruction should be considered a scheduling boundary.</p>
<p>This primarily includes labels and terminators. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01375">1375</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetSubtargetInfo_8h_source.html#l00128">llvm::TargetSubtargetInfo::getRegisterInfo()</a>, <a class="el" href="TargetLowering_8h_source.html#l01998">llvm::TargetLoweringBase::getStackPointerRegisterToSaveRestore()</a>, <a class="el" href="MachineFunction_8h_source.html#l00717">llvm::MachineFunction::getSubtarget()</a>, <a class="el" href="TargetSubtargetInfo_8h_source.html#l00100">llvm::TargetSubtargetInfo::getTargetLowering()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, and <a class="el" href="MachineSink_8cpp_source.html#l01928">TRI</a>.</p>

<p class="reference">Referenced by <a class="el" href="WindowScheduler_8cpp_source.html#l00173">llvm::WindowScheduler::initialize()</a>, <a class="el" href="AArch64InstrInfo_8cpp_source.html#l01140">llvm::AArch64InstrInfo::isSchedulingBoundary()</a>, <a class="el" href="PPCInstrInfo_8cpp_source.html#l02160">llvm::PPCInstrInfo::isSchedulingBoundary()</a>, and <a class="el" href="X86InstrInfo_8cpp_source.html#l08826">llvm::X86InstrInfo::isSchedulingBoundary()</a>.</p>

</div>
</div>
<a id="aa51770f677efd652c55498dc472bec14" name="aa51770f677efd652c55498dc472bec14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51770f677efd652c55498dc472bec14">&#9670;&#160;</a></span>isStackSlotCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isStackSlotCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>DestFrameIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>SrcFrameIndex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the specified machine instruction is a copy of one stack slot to another and has no other effect. </p>
<p>Provide the identity of the two frame indices. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00348">348</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="aa095ffe13f7029e833f37e346f5fa5b0" name="aa095ffe13f7029e833f37e346f5fa5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa095ffe13f7029e833f37e346f5fa5b0">&#9670;&#160;</a></span>isStoreToStackSlot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1Register.html">Register</a> llvm::TargetInstrInfo::isStoreToStackSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>FrameIndex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the specified machine instruction is a direct store to a stack slot, return the virtual or physical register number of the source reg along with the FrameIndex of the loaded stack slot. </p>
<p>If not, return 0. This predicate must return 0 if the instruction has any side effects other than storing to the stack slot. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00312">312</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8h_source.html#l00321">isStoreToStackSlot()</a>.</p>

</div>
</div>
<a id="af4a5b1227d7622151c06029e84d67ade" name="af4a5b1227d7622151c06029e84d67ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a5b1227d7622151c06029e84d67ade">&#9670;&#160;</a></span>isStoreToStackSlot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1Register.html">Register</a> llvm::TargetInstrInfo::isStoreToStackSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>FrameIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MemBytes</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional extension of isStoreToStackSlot that returns the number of bytes stored to the stack. </p>
<p>This must be implemented if a backend supports partial stack slot spills/loads to further disambiguate what the store does. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00321">321</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l00312">isStoreToStackSlot()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="a8d4598ec7bb2753593259420bff01427" name="a8d4598ec7bb2753593259420bff01427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4598ec7bb2753593259420bff01427">&#9670;&#160;</a></span>isStoreToStackSlotPostFE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1Register.html">Register</a> llvm::TargetInstrInfo::isStoreToStackSlotPostFE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>FrameIndex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> for post-frame ptr elimination stack locations as well. </p>
<p>This uses a heuristic, so it isn't reliable for correctness. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00330">330</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a838a9048864ddaea932c974de0e8ce1a" name="a838a9048864ddaea932c974de0e8ce1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838a9048864ddaea932c974de0e8ce1a">&#9670;&#160;</a></span>isSubregFoldable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isSubregFoldable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespacellvm_1_1Check.html">Check</a> whether the target can fold a load that feeds a subreg operand (or a subreg operand that feeds a store). </p>
<p>For example, <a class="el" href="namespacellvm_1_1X86.html" title="Define some predicates that are used for node matching.">X86</a> may want to return true if it can fold movl (esp), eax subb, al, ... Into: subb (esp), ...</p>
<p>Ideally, we'd like the target implementation of <a class="el" href="#a6a733ae5364b0de2225af33223f383a5" title="Attempt to fold a load or store of the specified stack slot into the specified machine instruction fo...">foldMemoryOperand()</a> to reject subregs - but since this behavior used to be enforced in the target-independent code, moving this responsibility to the targets has the potential of causing nasty silent breakage in out-of-tree targets. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01177">1177</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a9d33681dd1899a420e4b30bf11f4b58e" name="a9d33681dd1899a420e4b30bf11f4b58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d33681dd1899a420e4b30bf11f4b58e">&#9670;&#160;</a></span>isTailCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isTailCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Inst</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code>Inst</code> is a tail call instruction. </p>
<p>Override this method on targets that do not properly set <a class="el" href="namespacellvm_1_1MCID.html#ab357441fcd1ea1f9b0d27c12700f6023a5416d9f1bd5f533efddadf17d713e469">MCID::Return</a> and <a class="el" href="namespacellvm_1_1MCID.html#ab357441fcd1ea1f9b0d27c12700f6023a463baf545246fea9718664d933ffe66f">MCID::Call</a> on tail call instructions." </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02046">2046</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="MachineInstr_8h_source.html#l00950">llvm::MachineInstr::isCall()</a>, and <a class="el" href="MachineInstr_8h_source.html#l00940">llvm::MachineInstr::isReturn()</a>.</p>

</div>
</div>
<a id="a321a2b25fab981c6d834e3d0df610921" name="a321a2b25fab981c6d834e3d0df610921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321a2b25fab981c6d834e3d0df610921">&#9670;&#160;</a></span>isThroughputPattern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::isThroughputPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Pattern</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true when a code sequence can improve throughput. </p>
<p>Return true when a code sequence can improve loop throughput.</p>
<p>It should be called only for instructions in loops. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classllvm_1_1Pattern.html">Pattern</a></td><td>- combiner pattern </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00944">944</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

</div>
</div>
<a id="a1d142d4718ca758481e0b49ad9d8ea97" name="a1d142d4718ca758481e0b49ad9d8ea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d142d4718ca758481e0b49ad9d8ea97">&#9670;&#160;</a></span>isTriviallyReMaterializable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isTriviallyReMaterializable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the instruction is trivially rematerializable, meaning it has no side effects and requires no operands that aren't always available. </p>
<p>This means the only allowed uses are constants and unallocatable physical registers so that the instructions result is independent of the place in the function. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00143">143</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8cpp_source.html#l01272">isReallyTriviallyReMaterializable()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegAllocScore_8cpp_source.html#l00073">llvm::calculateRegAllocScore()</a>, and <a class="el" href="LiveRangeEdit_8cpp_source.html#l00071">llvm::LiveRangeEdit::checkRematerializable()</a>.</p>

</div>
</div>
<a id="a49711da0a9e246f5960bf2816b0d8aa3" name="a49711da0a9e246f5960bf2816b0d8aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49711da0a9e246f5960bf2816b0d8aa3">&#9670;&#160;</a></span>isUnconditionalTailCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isUnconditionalTailCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if MI is an unconditional tail call. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01612">1612</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a4993b49c4db728d9669c0f6a08daae2e" name="a4993b49c4db728d9669c0f6a08daae2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4993b49c4db728d9669c0f6a08daae2e">&#9670;&#160;</a></span>isUnpredicatedTerminator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::isUnpredicatedTerminator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the instruction is a terminator instruction that has not been predicated. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00319">319</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l01593">isPredicated()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="a4bdf5a92f1195b3543b9412758c58106" name="a4bdf5a92f1195b3543b9412758c58106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdf5a92f1195b3543b9412758c58106">&#9670;&#160;</a></span>isUnspillableTerminator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isUnspillableTerminator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the given instruction is terminator that is unspillable, according to isUnspillableTerminatorImpl. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00372">372</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l01066">isUnspillableTerminatorImpl()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="ae47bacdac90d2744684f980e1ad40594" name="ae47bacdac90d2744684f980e1ad40594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47bacdac90d2744684f980e1ad40594">&#9670;&#160;</a></span>isUnspillableTerminatorImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isUnspillableTerminatorImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the given terminator MI is not expected to spill. </p>
<p>This sets the live interval as not spillable and adjusts phi node lowering to not introduce copies after the terminator. <a class="el" href="classllvm_1_1Use.html" title="A Use represents the edge between a Value definition and its users.">Use</a> with care, these are currently used for hardware loop intrinsics in very controlled situations, created prior to registry allocation in loops that only have single phi users for the terminators value. They may run out of registers if not used carefully. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01066">1066</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8h_source.html#l00372">isUnspillableTerminator()</a>.</p>

</div>
</div>
<a id="a0ba282dba26451dcfbbc938444595d7e" name="a0ba282dba26451dcfbbc938444595d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba282dba26451dcfbbc938444595d7e">&#9670;&#160;</a></span>isZeroCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::isZeroCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true for pseudo instructions that don't consume any machine resources in their current form. </p>
<p>These are common cases that the scheduler should consider free, rather than conservatively handling them as instructions with no itinerary. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01765">1765</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="WindowScheduler_8cpp_source.html#l00422">llvm::WindowScheduler::calculateMaxCycle()</a>, <a class="el" href="MachinePipeliner_8cpp_source.html#l03704">llvm::ResourceManager::calculateResMII()</a>, and <a class="el" href="ScoreboardHazardRecognizer_8cpp_source.html#l00171">llvm::ScoreboardHazardRecognizer::EmitInstruction()</a>.</p>

</div>
</div>
<a id="a1f37a2dbf11ae8af68936b0eeca620f6" name="a1f37a2dbf11ae8af68936b0eeca620f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f37a2dbf11ae8af68936b0eeca620f6">&#9670;&#160;</a></span>loadRegFromStackSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::loadRegFromStackSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>DestReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>FrameIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterClass.html">TargetRegisterClass</a> *</td>          <td class="paramname"><span class="paramname"><em>RC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>VReg</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load the specified register of the given register class from the specified stack frame index. </p>
<p>The load instruction is to be added to the given machine basic block before the specified machine instruction. If <code>DestReg</code> is being directly reloaded as part of assigning a virtual register, <code>VReg</code> is the register being assigned. This additional register argument is needed for certain targets when invoked from RegAllocFast to map the loaded physical register to its virtual register. A null register can be passed elsewhere. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01147">1147</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00634">foldMemoryOperand()</a>.</p>

</div>
</div>
<a id="a68b7b9c491045c788173e83be1ba5d2b" name="a68b7b9c491045c788173e83be1ba5d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b7b9c491045c788173e83be1ba5d2b">&#9670;&#160;</a></span>lowerCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TargetInstrInfo::lowerCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function defines the logic to lower COPY instruction to target specific instruction(s). </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00800">800</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l01020">copyPhysReg()</a>, <a class="el" href="MCInstrInfo_8h_source.html#l00063">llvm::MCInstrInfo::get()</a>, <a class="el" href="MachineOperand_8h_source.html#l00369">llvm::MachineOperand::getReg()</a>, <a class="el" href="MachineOperand_8h_source.html#l00399">llvm::MachineOperand::isKill()</a>, <a class="el" href="MachineOperand_8h_source.html#l00404">llvm::MachineOperand::isUndef()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00782">transferImplicitOperands()</a>, and <a class="el" href="MachineSink_8cpp_source.html#l01928">TRI</a>.</p>

</div>
</div>
<a id="a4253df7a10e437a01d42c223e196c0b8" name="a4253df7a10e437a01d42c223e196c0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4253df7a10e437a01d42c223e196c0b8">&#9670;&#160;</a></span>mergeOutliningCandidateAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TargetInstrInfo::mergeOutliningCandidateAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structllvm_1_1outliner_1_1Candidate.html">outliner::Candidate</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Candidates</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional target hook to create the LLVM IR attributes for the outlined function. </p>
<p>If overridden, the overriding function must call the default implementation. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01792">1792</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="Function_8cpp_source.html#l00629">llvm::Function::addFnAttr()</a>, <a class="el" href="STLExtras_8h_source.html#l01722">llvm::all_of()</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="Function_8cpp_source.html#l00745">llvm::Function::getFnAttribute()</a>, <a class="el" href="MachineFunction_8h_source.html#l00683">llvm::MachineFunction::getFunction()</a>, <a class="el" href="MachineOutliner_8h_source.html#l00143">llvm::outliner::Candidate::getMF()</a>, and <a class="el" href="Function_8cpp_source.html#l00719">llvm::Function::hasFnAttribute()</a>.</p>

</div>
</div>
<a id="a82b4dd0611f4e9b708e1940a945581e9" name="a82b4dd0611f4e9b708e1940a945581e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b4dd0611f4e9b708e1940a945581e9">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1TargetInstrInfo.html">TargetInstrInfo</a> &amp; llvm::TargetInstrInfo::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetInstrInfo.html">TargetInstrInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d95382897959324602ecb63f7392fda" name="a6d95382897959324602ecb63f7392fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d95382897959324602ecb63f7392fda">&#9670;&#160;</a></span>optimizeCompareInstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::optimizeCompareInstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>CmpInstr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>SrcReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>SrcReg2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>MRI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See if the comparison instruction can be converted into something more efficient. </p>
<p>E.g., on <a class="el" href="namespacellvm_1_1ARM.html" title="Define some predicates that are used for node matching.">ARM</a> most instructions can set the flags register, obviating the need for a separate CMP. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01721">1721</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a9414061830d845a2b79363614cf5b5db" name="a9414061830d845a2b79363614cf5b5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9414061830d845a2b79363614cf5b5db">&#9670;&#160;</a></span>optimizeCondBranch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::optimizeCondBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01727">1727</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a01961400ab1186ac9f849cf0e738447f" name="a01961400ab1186ac9f849cf0e738447f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01961400ab1186ac9f849cf0e738447f">&#9670;&#160;</a></span>optimizeLoadInstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * llvm::TargetInstrInfo::optimizeLoadInstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>MRI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>FoldAsLoadDefReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>DefMI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to remove the load by folding it to a register operand at the use. </p>
<p>We fold the load instructions if and only if the def and use are in the same BB. We only look at one load and see whether it can be folded into MI. FoldAsLoadDefReg is the virtual register defined by the load we are trying to fold. DefMI returns the machine instruction that defines FoldAsLoadDefReg, and the function returns the machine instruction generated due to folding. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01736">1736</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a31b099a7de1dfef1561ec6f7df09da47" name="a31b099a7de1dfef1561ec6f7df09da47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b099a7de1dfef1561ec6f7df09da47">&#9670;&#160;</a></span>optimizeSelect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * llvm::TargetInstrInfo::optimizeSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>NewMIs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>PreferFalse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a select instruction that was understood by analyzeSelect and returned Optimizable = true, attempt to optimize MI by merging it with one of its operands. </p>
<p>Returns NULL on failure.</p>
<p>When successful, returns the new select instruction. The client is responsible for deleting MI.</p>
<p>If both sides of the select can be optimized, PreferFalse is used to pick a side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MI</td><td>Optimizable select instruction. </td></tr>
    <tr><td class="paramname">NewMIs</td><td>Set that record all MIs in the basic block up to <code>MI</code>. Has to be updated with any newly created MI or deleted ones. </td></tr>
    <tr><td class="paramname">PreferFalse</td><td>Try to optimize FalseOp instead of TrueOp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optimized instruction or NULL. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01005">1005</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="a29513f18e551370b1b438f95403efc04" name="a29513f18e551370b1b438f95403efc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29513f18e551370b1b438f95403efc04">&#9670;&#160;</a></span>PredicateInstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::PredicateInstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Pred</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the instruction into a predicated instruction. </p>
<p>It returns true if the operation was successful. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00330">330</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="MipsDisassembler_8cpp_source.html#l00521">getReg()</a>, <a class="el" href="MachineOperand_8h_source.html#l00331">llvm::MachineOperand::isImm()</a>, <a class="el" href="MachineOperand_8h_source.html#l00337">llvm::MachineOperand::isMBB()</a>, <a class="el" href="MachineOperand_8h_source.html#l00329">llvm::MachineOperand::isReg()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="MCInstrDesc_8h_source.html#l00239">llvm::MCInstrDesc::operands()</a>, <a class="el" href="MachineOperand_8h_source.html#l00684">llvm::MachineOperand::setImm()</a>, <a class="el" href="MachineOperand_8h_source.html#l00727">llvm::MachineOperand::setMBB()</a>, and <a class="el" href="MachineOperand_8cpp_source.html#l00061">llvm::MachineOperand::setReg()</a>.</p>

</div>
</div>
<a id="ac0eb74bb20ce93168ed6fc663d997c30" name="ac0eb74bb20ce93168ed6fc663d997c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0eb74bb20ce93168ed6fc663d997c30">&#9670;&#160;</a></span>predictBranchSizeForIfCvt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::predictBranchSizeForIfCvt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an estimate for the code size reduction (in bytes) which will be caused by removing the given branch instruction during if-conversion. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00896">896</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8h_source.html#l00378">getInstSizeInBytes()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>.</p>

</div>
</div>
<a id="a45aa2763f52ee7bb3f41393d1d4ba079" name="a45aa2763f52ee7bb3f41393d1d4ba079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45aa2763f52ee7bb3f41393d1d4ba079">&#9670;&#160;</a></span>preservesZeroValueInReg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::preservesZeroValueInReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>NullValueReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if MI's Def is NullValueReg, and the MI does not change the Zero value. </p>
<p>i.e. cases such as rax = shr rax, X where NullValueReg = rax. Note that if the NullValueReg is non-zero, this function can return true even if becomes zero. Specifically cases such as NullValueReg = shl NullValueReg, 63. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01534">1534</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="ac66abaa28810e0bb35ab77012a3ea997" name="ac66abaa28810e0bb35ab77012a3ea997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66abaa28810e0bb35ab77012a3ea997">&#9670;&#160;</a></span>produceSameValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::produceSameValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineRegisterInfo.html">MachineRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>MRI</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if two machine instructions would produce identical values. </p>
<p>By default, this is only true when the two instructions are deemed identical except for defs. If this function is called when the IR is still in SSA form, the caller can pass the <a class="el" href="classllvm_1_1MachineRegisterInfo.html" title="MachineRegisterInfo - Keep track of information for virtual and physical registers,...">MachineRegisterInfo</a> for aggressive checks. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00428">428</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineInstr_8h_source.html#l01275">llvm::MachineInstr::IgnoreVRegDefs</a>, and <a class="el" href="MachineInstr_8cpp_source.html#l00649">llvm::MachineInstr::isIdenticalTo()</a>.</p>

</div>
</div>
<a id="ae5e0c947b38bdebad23286c7764b5249" name="ae5e0c947b38bdebad23286c7764b5249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e0c947b38bdebad23286c7764b5249">&#9670;&#160;</a></span>reassociateOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TargetInstrInfo::reassociateOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Prev</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InsInstrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>DelInstrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>OperandIndices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseMap.html">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InstrIdxForVirtReg</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to reassociate \P Root and \P Prev according to \P <a class="el" href="classllvm_1_1Pattern.html">Pattern</a> to reduce critical path length. </p>
<p>Attempt the reassociation transformation to reduce critical path length.</p>
<p>See the above comments before <a class="el" href="#a861381cad67866e249c6330631ac0742" title="Return true when there is potentially a faster code sequence for an instruction chain ending in Root.">getMachineCombinerPatterns()</a>. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01081">1081</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineInstrBuilder_8h_source.html#l00226">llvm::MachineInstrBuilder::add()</a>, <a class="el" href="MachineInstrBuilder_8h_source.html#l00099">llvm::MachineInstrBuilder::addReg()</a>, <a class="el" href="MachineInstr_8h_source.html#l00418">llvm::MachineInstr::clearFlag()</a>, <a class="el" href="MachineInstrBuilder_8h_source.html#l00334">llvm::MachineInstrBuilder::copyImplicitOps()</a>, <a class="el" href="MachineInstrBuilder_8h_source.html#l00046">llvm::RegState::Define</a>, <a class="el" href="MachineInstr_8h_source.html#l00691">llvm::MachineInstr::explicit_operands()</a>, <a class="el" href="MachineInstr_8h_source.html#l00391">llvm::MachineInstr::getFlags()</a>, <a class="el" href="MachineInstrBuilder_8h_source.html#l00091">llvm::MachineInstrBuilder::getInstr()</a>, <a class="el" href="TargetSubtargetInfo_8h_source.html#l00096">llvm::TargetSubtargetInfo::getInstrInfo()</a>, <a class="el" href="MachineInstrBuilder_8h_source.html#l00555">llvm::getKillRegState()</a>, <a class="el" href="MachineInstr_8cpp_source.html#l00747">llvm::MachineInstr::getMF()</a>, <a class="el" href="MachineInstr_8h_source.html#l00579">llvm::MachineInstr::getOperand()</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l00954">getReassociationOpcodes()</a>, <a class="el" href="MachineOperand_8h_source.html#l00369">llvm::MachineOperand::getReg()</a>, <a class="el" href="MachineInstr_8cpp_source.html#l00945">llvm::MachineInstr::getRegClassConstraint()</a>, <a class="el" href="MachineFunction_8h_source.html#l00727">llvm::MachineFunction::getRegInfo()</a>, <a class="el" href="TargetSubtargetInfo_8h_source.html#l00128">llvm::TargetSubtargetInfo::getRegisterInfo()</a>, <a class="el" href="MachineFunction_8h_source.html#l00717">llvm::MachineFunction::getSubtarget()</a>, <a class="el" href="DenseMap_8h_source.html#l00220">llvm::DenseMapBase&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt;::insert()</a>, <a class="el" href="MachineInstr_8h_source.html#l00109">llvm::MachineInstr::IsExact</a>, <a class="el" href="MachineOperand_8h_source.html#l00399">llvm::MachineOperand::isKill()</a>, <a class="el" href="Register_8h_source.html#l00091">llvm::Register::isVirtual()</a>, <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>, <a class="el" href="AArch64AdvSIMDScalarPass_8cpp_source.html#l00105">MRI</a>, <a class="el" href="TargetInstrInfo_8cpp_source.html#l01043">mustSwapOperands()</a>, <a class="el" href="MachineInstr_8h_source.html#l00107">llvm::MachineInstr::NoSWrap</a>, <a class="el" href="MachineInstr_8h_source.html#l00105">llvm::MachineInstr::NoUWrap</a>, <a class="el" href="MachineInstr_8h_source.html#l00545">llvm::MachineInstr::peekDebugInstrNum()</a>, <a class="el" href="SmallVector_8h_source.html#l00427">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00031">llvm::REASSOC_AX_BY</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00032">llvm::REASSOC_AX_YB</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00033">llvm::REASSOC_XA_BY</a>, <a class="el" href="MachineCombinerPattern_8h_source.html#l00034">llvm::REASSOC_XA_YB</a>, <a class="el" href="MachineInstr_8h_source.html#l00549">llvm::MachineInstr::setDebugInstrNum()</a>, <a class="el" href="MachineInstr_8h_source.html#l00409">llvm::MachineInstr::setFlags()</a>, <a class="el" href="MachineInstrBuilder_8h_source.html#l00320">llvm::MachineInstrBuilder::setPCSections()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l01328">setSpecialOperandAttr()</a>, <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>, <a class="el" href="HexagonCopyToCombine_8cpp_source.html#l00125">TII</a>, and <a class="el" href="MachineSink_8cpp_source.html#l01928">TRI</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01247">genAlternativeCodeSequence()</a>.</p>

</div>
</div>
<a id="a18927162b9131e79e1ee778c7ae4a4e2" name="a18927162b9131e79e1ee778c7ae4a4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18927162b9131e79e1ee778c7ae4a4e2">&#9670;&#160;</a></span>reduceLoopCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::reduceLoopCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>PreHeader</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> *</td>          <td class="paramname"><span class="paramname"><em>IndVar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Cmp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>PrevInsts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>MaxIter</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate code to reduce the loop iteration by one and check if the loop is finished. </p>
<p>Return the value/register of the new loop count. We need this function when peeling off one or more iterations of a loop. This function assumes the nth iteration is peeled first. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00828">828</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="aadcfe8906a95ad57f3f7a7d433f47204" name="aadcfe8906a95ad57f3f7a7d433f47204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcfe8906a95ad57f3f7a7d433f47204">&#9670;&#160;</a></span>reMaterialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TargetInstrInfo::reMaterialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>DestReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>SubIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-issue the specified 'original' instruction at the specific location targeting a new destination register. </p>
<p>The register in Orig-&gt;getOperand(0).<a class="el" href="MipsDisassembler_8cpp.html#a15b5b86944f6df97d2c3659d77f51f91">getReg()</a> will be substituted by DestReg:SubIdx. <a class="el" href="classllvm_1_1Any.html">Any</a> existing subreg index is preserved or composed with SubIdx. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00418">418</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineBasicBlock_8h_source.html#l00310">llvm::MachineBasicBlock::getParent()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="MachineBasicBlock_8cpp_source.html#l01454">llvm::MachineBasicBlock::insert()</a>, <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, and <a class="el" href="MachineSink_8cpp_source.html#l01928">TRI</a>.</p>

<p class="reference">Referenced by <a class="el" href="SIInstrInfo_8cpp_source.html#l02560">llvm::SIInstrInfo::reMaterialize()</a>, and <a class="el" href="LiveRangeEdit_8cpp_source.html#l00182">llvm::LiveRangeEdit::rematerializeAt()</a>.</p>

</div>
</div>
<a id="a0317b8d1d0eb9aaf9af9d636f5f66e8d" name="a0317b8d1d0eb9aaf9af9d636f5f66e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0317b8d1d0eb9aaf9af9d636f5f66e8d">&#9670;&#160;</a></span>removeBranch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::removeBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>BytesRemoved</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the branching code at the end of the specific MBB. </p>
<p>This is only invoked in cases where analyzeBranch returns success. It returns the number of instructions that were removed. If <code>BytesRemoved</code> is non-null, report the change in code size from the removed instructions. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00703">703</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="abee18da5b03753cdb0cd484b2a4e2c35" name="abee18da5b03753cdb0cd484b2a4e2c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee18da5b03753cdb0cd484b2a4e2c35">&#9670;&#160;</a></span>replaceBranchWithTailCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::replaceBranchWithTailCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>TailCall</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the conditional branch in MBB with a conditional tail call. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01623">1623</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="a26e9655e762686aff18772a15139df27" name="a26e9655e762686aff18772a15139df27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e9655e762686aff18772a15139df27">&#9670;&#160;</a></span>ReplaceTailWithBranchTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TargetInstrInfo::ReplaceTailWithBranchTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>Tail</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>NewDest</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the instruction OldInst and everything after it, replacing it with an unconditional branch to NewDest. </p>
<p>ReplaceTailWithBranchTo - Delete the instruction OldInst and everything after it, replacing it with an unconditional branch to NewDest.</p>
<p>This is used by the tail merging pass. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l00142">142</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MachineBasicBlock_8cpp_source.html#l00796">llvm::MachineBasicBlock::addSuccessor()</a>, <a class="el" href="ARMSLSHardening_8cpp_source.html#l00073">DL</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l00356">llvm::MachineBasicBlock::end()</a>, <a class="el" href="MachineBasicBlock_8cpp_source.html#l01441">llvm::MachineBasicBlock::erase()</a>, <a class="el" href="MachineFunction_8cpp_source.html#l00900">llvm::MachineFunction::eraseCallSiteInfo()</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l00310">llvm::MachineBasicBlock::getParent()</a>, <a class="el" href="TargetInstrInfo_8h_source.html#l00721">insertBranch()</a>, <a class="el" href="ARMSLSHardening_8cpp_source.html#l00071">MBB</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00113">MI</a>, <a class="el" href="MachineBasicBlock_8cpp_source.html#l00834">llvm::MachineBasicBlock::removeSuccessor()</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l00418">llvm::MachineBasicBlock::succ_begin()</a>, <a class="el" href="MachineBasicBlock_8h_source.html#l00433">llvm::MachineBasicBlock::succ_empty()</a>, and <a class="el" href="CallingConv_8h_source.html#l00076">llvm::CallingConv::Tail</a>.</p>

<p class="reference">Referenced by <a class="el" href="Thumb2InstrInfo_8cpp_source.html#l00063">llvm::Thumb2InstrInfo::ReplaceTailWithBranchTo()</a>.</p>

</div>
</div>
<a id="a013a36a3a8a5acbdb9bcf1d3c6fede83" name="a013a36a3a8a5acbdb9bcf1d3c6fede83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013a36a3a8a5acbdb9bcf1d3c6fede83">&#9670;&#160;</a></span>reverseBranchCondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::reverseBranchCondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Cond</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the branch condition of the specified condition list, returning false on success and true if it cannot be reversed. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01573">1573</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="adbcfa8a45f569feb4562cff3567163ef" name="adbcfa8a45f569feb4562cff3567163ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcfa8a45f569feb4562cff3567163ef">&#9670;&#160;</a></span>setExecutionDomain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::setExecutionDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Domain</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the opcode of MI to execute in Domain. </p>
<p>The bit (1 &lt;&lt; Domain) must be set in the mask returned from getExecutionDomain(MI). </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01858">1858</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a0b63f89d9653388354a58218932dc2f8" name="a0b63f89d9653388354a58218932dc2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b63f89d9653388354a58218932dc2f8">&#9670;&#160;</a></span>setSpecialOperandAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::setSpecialOperandAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OldMI1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OldMI2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>NewMI1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>NewMI2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an architecture-specific helper function of reassociateOps. </p>
<p>Set special operand attributes for new instructions after reassociation. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01328">1328</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l01081">reassociateOps()</a>.</p>

</div>
</div>
<a id="a6c56f769334913401fe67e9e123b3d59" name="a6c56f769334913401fe67e9e123b3d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c56f769334913401fe67e9e123b3d59">&#9670;&#160;</a></span>shouldClusterMemOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::shouldClusterMemOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>BaseOps1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Offset1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>OffsetIsScalable1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>BaseOps2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Offset2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>OffsetIsScalable2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ClusterSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumBytes</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the two given memory operations should be scheduled adjacent. </p>
<p>Note that you have to add: DAG-&gt;addMutation(createLoadClusterDAGMutation(DAG-&gt;TII, DAG-&gt;TRI)); or DAG-&gt;addMutation(createStoreClusterDAGMutation(DAG-&gt;TII, DAG-&gt;TRI)); to <a class="el" href="classllvm_1_1TargetPassConfig.html#a76f0f9b7aba8cb8682c8b60f24cce1ae" title="Create an instance of ScheduleDAGInstrs to be run within the standard MachineScheduler pass for this ...">TargetPassConfig::createMachineScheduler()</a> to have an effect.</p>
<p><code>BaseOps1</code> and <code>BaseOps2</code> are memory operands of two memory operations. <code>Offset1</code> and <code>Offset2</code> are the byte offsets for the memory operations. <code>OffsetIsScalable1</code> and <code>OffsetIsScalable2</code> indicate if the offset is scaled by a runtime quantity. <code>ClusterSize</code> is the number of operations in the resulting load/store cluster if this hook returns true. <code>NumBytes</code> is the number of bytes that will be loaded from all the clustered loads if this hook returns true. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01561">1561</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="aefc848c0953b9a49b09c0ef3a577a34f" name="aefc848c0953b9a49b09c0ef3a577a34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc848c0953b9a49b09c0ef3a577a34f">&#9670;&#160;</a></span>shouldHoist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::shouldHoist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineLoop.html">MachineLoop</a> *</td>          <td class="paramname"><span class="paramname"><em>FromLoop</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return false if the instruction should not be hoisted by MachineLICM. </p>
<p>MachineLICM determines on its own whether the instruction is safe to hoist; this gives the target a hook to extend this assessment and prevent an instruction being hoisted from a given loop for target specific reasons. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00403">403</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a2de90c613673f0815ee6aa406f67390a" name="a2de90c613673f0815ee6aa406f67390a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de90c613673f0815ee6aa406f67390a">&#9670;&#160;</a></span>shouldOutlineFromFunctionByDefault()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::shouldOutlineFromFunctionByDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the function should be outlined from by default. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l02185">2185</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a3b8cfc1d0bd78872b33f4669f9a18927" name="a3b8cfc1d0bd78872b33f4669f9a18927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8cfc1d0bd78872b33f4669f9a18927">&#9670;&#160;</a></span>shouldReduceRegisterPressure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::shouldReduceRegisterPressure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1RegisterClassInfo.html">RegisterClassInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>RegClassInfo</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if target supports reassociation of instructions in machine combiner pass to reduce register pressure for a given BB. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01226">1226</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a7613f5f7e38ac5338a58172dd6429370" name="a7613f5f7e38ac5338a58172dd6429370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7613f5f7e38ac5338a58172dd6429370">&#9670;&#160;</a></span>shouldScheduleLoadsNear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::shouldScheduleLoadsNear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>Load1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>Load2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Offset1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Offset2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumLoads</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a used by the pre-regalloc scheduler to determine (in conjunction with areLoadsFromSameBasePtr) if two loads should be scheduled together. </p>
<p>On some targets if two loads are loading from addresses in the same cache line, it's better if they are scheduled together. This function takes two integers that represent the load offsets from the common base address. It returns true if it decides it's desirable to schedule the two loads together. "NumLoads" is the number of loads that have already been scheduled after Load1. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01458">1458</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="ad9b2151fcd1d9e2cec1689aec6e5ed8a" name="ad9b2151fcd1d9e2cec1689aec6e5ed8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b2151fcd1d9e2cec1689aec6e5ed8a">&#9670;&#160;</a></span>shouldSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::shouldSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the instruction should be sunk by MachineSink. </p>
<p>MachineSink determines on its own whether the instruction is safe to sink; this gives the target a hook to override the default behavior with regards to which instructions should be sunk. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00395">395</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a417192487f0e7d3a21af7c885de3152c" name="a417192487f0e7d3a21af7c885de3152c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417192487f0e7d3a21af7c885de3152c">&#9670;&#160;</a></span>storeRegToStackSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void llvm::TargetInstrInfo::storeRegToStackSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html">MachineBasicBlock</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MBB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineBasicBlock.html#ae34c996b58df9b9ce6695a0c8b70c533">MachineBasicBlock::iterator</a></td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>SrcReg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isKill</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>FrameIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterClass.html">TargetRegisterClass</a> *</td>          <td class="paramname"><span class="paramname"><em>RC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1TargetRegisterInfo.html">TargetRegisterInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TRI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Register.html">Register</a></td>          <td class="paramname"><span class="paramname"><em>VReg</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the specified register of the given register class to the specified stack frame index. </p>
<p>The store instruction is to be added to the given machine basic block before the specified machine instruction. If isKill is true, the register operand is the last use and must be marked kill. If <code>SrcReg</code> is being directly spilled as part of assigning a virtual register, <code>VReg</code> is the register being assigned. This additional register argument is needed for certain targets when invoked from RegAllocFast to map the spilled physical register to its virtual register. A null register can be passed elsewhere. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01129">1129</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00634">foldMemoryOperand()</a>.</p>

</div>
</div>
<a id="a51ba312c2d730acd131fccc2cc787498" name="a51ba312c2d730acd131fccc2cc787498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ba312c2d730acd131fccc2cc787498">&#9670;&#160;</a></span>SubsumesPredicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::SubsumesPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Pred1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1MachineOperand.html">MachineOperand</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Pred2</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the first specified predicate subsumes the second, e.g. </p>
<p>GE subsumes GT. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01636">1636</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="aa44220d7a83b114a21ca2d23ffed03b2" name="aa44220d7a83b114a21ca2d23ffed03b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44220d7a83b114a21ca2d23ffed03b2">&#9670;&#160;</a></span>unfoldMemoryOperand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::unfoldMemoryOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineFunction.html">MachineFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MF</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>UnfoldLoad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>UnfoldStore</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>NewMIs</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unfoldMemoryOperand - Separate a single instruction which folded a load or a store or a load and a store into two or more instruction. </p>
<p>If this is possible, returns true as well as the new instructions by reference. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01417">1417</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="af7a82bf89bd98729150cebde60be9dfd" name="af7a82bf89bd98729150cebde60be9dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a82bf89bd98729150cebde60be9dfd">&#9670;&#160;</a></span>unfoldMemoryOperand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::unfoldMemoryOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SelectionDAG.html">SelectionDAG</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DAG</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>NewNodes</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01423">1423</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="a4cb5569c23b5e1ed52164d9ec0496c05" name="a4cb5569c23b5e1ed52164d9ec0496c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb5569c23b5e1ed52164d9ec0496c05">&#9670;&#160;</a></span>useMachineCombiner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::useMachineCombiner </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true when a target supports MachineCombiner. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01333">1333</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<a id="af286c176e38f876d4f56a34cb9ee319a" name="af286c176e38f876d4f56a34cb9ee319a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af286c176e38f876d4f56a34cb9ee319a">&#9670;&#160;</a></span>usePreRAHazardRecognizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetInstrInfo::usePreRAHazardRecognizer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a global flag for disabling the PreRA hazard recognizer that targets may choose to honor. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8cpp_source.html#l01398">1398</a> of file <a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetInstrInfo_8cpp.html#aeb921abaab57f35917a459316dc1b8b0">DisableHazardRecognizer</a>.</p>

</div>
</div>
<a id="a490afb5ecb8232428c7ce7b87ef24b43" name="a490afb5ecb8232428c7ce7b87ef24b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490afb5ecb8232428c7ce7b87ef24b43">&#9670;&#160;</a></span>verifyInstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::TargetInstrInfo::verifyInstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1MachineInstr.html">MachineInstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>MI</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ErrInfo</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform target-specific instruction verification. </p>

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l01825">1825</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae73e2be2b66dc9e4f2f90d56076d7ea9" name="ae73e2be2b66dc9e4f2f90d56076d7ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73e2be2b66dc9e4f2f90d56076d7ea9">&#9670;&#160;</a></span>CommuteAnyOperandIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classunsigned.html">unsigned</a> llvm::TargetInstrInfo::CommuteAnyOperandIndex = ~0U</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetInstrInfo_8h_source.html#l00450">450</a> of file <a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetInstrInfo_8cpp_source.html#l00249">commuteInstruction()</a>, and <a class="el" href="TargetInstrInfo_8cpp_source.html#l00264">fixCommutedOpIndices()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/llvm/CodeGen/<a class="el" href="TargetInstrInfo_8h_source.html">TargetInstrInfo.h</a></li>
<li>lib/CodeGen/<a class="el" href="TargetInstrInfo_8cpp_source.html">TargetInstrInfo.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Nov 1 2024 14:00:10 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
