<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Transforms/Utils/CallPromotionUtils.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;19.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a72932e0778af28115095468f6286ff8.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_f75c00afeb315f44d76556a7c675e6e8.html">Utils</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">CallPromotionUtils.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="CallPromotionUtils_8h_source.html">llvm/Transforms/Utils/CallPromotionUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="STLExtras_8h_source.html">llvm/ADT/STLExtras.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Loads_8h_source.html">llvm/Analysis/Loads.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeMetadataUtils_8h_source.html">llvm/Analysis/TypeMetadataUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AttributeMask_8h_source.html">llvm/IR/AttributeMask.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Constant_8h_source.html">llvm/IR/Constant.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IRBuilder_8h_source.html">llvm/IR/IRBuilder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Instructions_8h_source.html">llvm/IR/Instructions.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Module_8h_source.html">llvm/IR/Module.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BasicBlockUtils_8h_source.html">llvm/Transforms/Utils/BasicBlockUtils.h</a>&quot;</code><br />
</div>
<p><a href="CallPromotionUtils_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;call-promotion-utils&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a51ff57d75f102e980e39535df6ff00bb" id="r_a51ff57d75f102e980e39535df6ff00bb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51ff57d75f102e980e39535df6ff00bb">fixupPHINodeForNormalDest</a> (<a class="el" href="classllvm_1_1InvokeInst.html">InvokeInst</a> *Invoke, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *OrigBlock, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *MergeBlock)</td></tr>
<tr class="memdesc:a51ff57d75f102e980e39535df6ff00bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix-up phi nodes in an invoke instruction's normal destination.  <br /></td></tr>
<tr class="separator:a51ff57d75f102e980e39535df6ff00bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b92d3bbd9b21b61a2afbb73c10c3b0" id="r_a59b92d3bbd9b21b61a2afbb73c10c3b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59b92d3bbd9b21b61a2afbb73c10c3b0">fixupPHINodeForUnwindDest</a> (<a class="el" href="classllvm_1_1InvokeInst.html">InvokeInst</a> *Invoke, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *OrigBlock, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *ThenBlock, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *ElseBlock)</td></tr>
<tr class="memdesc:a59b92d3bbd9b21b61a2afbb73c10c3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix-up phi nodes in an invoke instruction's unwind destination.  <br /></td></tr>
<tr class="separator:a59b92d3bbd9b21b61a2afbb73c10c3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf3ba57973320bd702d3b12b0b8fa8c" id="r_abdf3ba57973320bd702d3b12b0b8fa8c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdf3ba57973320bd702d3b12b0b8fa8c">createRetPHINode</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *OrigInst, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *NewInst, <a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *MergeBlock, <a class="el" href="classllvm_1_1IRBuilder.html">IRBuilder</a>&lt;&gt; &amp;Builder)</td></tr>
<tr class="memdesc:abdf3ba57973320bd702d3b12b0b8fa8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a phi node for the returned value of a call or invoke instruction.  <br /></td></tr>
<tr class="separator:abdf3ba57973320bd702d3b12b0b8fa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9ae0be5e6bcad90cdf141962a117f3" id="r_a8c9ae0be5e6bcad90cdf141962a117f3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c9ae0be5e6bcad90cdf141962a117f3">createRetBitCast</a> (<a class="el" href="classllvm_1_1CallBase.html">CallBase</a> &amp;CB, <a class="el" href="classllvm_1_1Type.html">Type</a> *RetTy, <a class="el" href="classllvm_1_1CastInst.html">CastInst</a> **RetBitCast)</td></tr>
<tr class="memdesc:a8c9ae0be5e6bcad90cdf141962a117f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a call or invoke instruction to the given type.  <br /></td></tr>
<tr class="separator:a8c9ae0be5e6bcad90cdf141962a117f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabc735841282ccafdf43b7c165b030e" id="r_aaabc735841282ccafdf43b7c165b030e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1CallBase.html">CallBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaabc735841282ccafdf43b7c165b030e">versionCallSiteWithCond</a> (<a class="el" href="classllvm_1_1CallBase.html">CallBase</a> &amp;CB, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>, <a class="el" href="classllvm_1_1MDNode.html">MDNode</a> *BranchWeights)</td></tr>
<tr class="memdesc:aaabc735841282ccafdf43b7c165b030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate and clone the given call site.  <br /></td></tr>
<tr class="separator:aaabc735841282ccafdf43b7c165b030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;call-promotion-utils&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CallPromotionUtils_8cpp_source.html#l00027">27</a> of file <a class="el" href="CallPromotionUtils_8cpp_source.html">CallPromotionUtils.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8c9ae0be5e6bcad90cdf141962a117f3" name="a8c9ae0be5e6bcad90cdf141962a117f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9ae0be5e6bcad90cdf141962a117f3">&#9670;&#160;</a></span>createRetBitCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void createRetBitCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CallBase.html">CallBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>CB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>RetTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CastInst.html">CastInst</a> **</td>          <td class="paramname"><span class="paramname"><em>RetBitCast</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a call or invoke instruction to the given type. </p>
<p>When promoting a call site, the return type of the call site might not match that of the callee. If this is the case, we have to cast the returned value to the correct type. The location of the cast depends on if we have a call or invoke instruction.</p>
<p>For example, if the call instruction below requires a bitcast after promotion:</p>
<p>orig_bb: t0 = call i32 @func() ...</p>
<p>The bitcast is placed after the call instruction:</p>
<p>orig_bb: ; Uses of the original return value are replaced by uses of the bitcast. t0 = call i32 @func() t1 = bitcast i32 t0 to ... ...</p>
<p>A similar transformation is performed for invoke instructions. However, since invokes are terminating, a new block is created for the bitcast. For example, if the invoke instruction below requires a bitcast after promotion:</p>
<p>orig_bb: t0 = invoke i32 @func() to label normal_dst unwind label unwind_dst</p>
<p>The edge between the original block and the invoke's normal destination is split, and the bitcast is placed there:</p>
<p>orig_bb: t0 = invoke i32 @func() to label split_bb unwind label unwind_dst</p>
<p>split_bb: ; Uses of the original return value are replaced by uses of the bitcast. t1 = bitcast i32 t0 to ... br label normal_dst </p>

<p class="definition">Definition at line <a class="el" href="CallPromotionUtils_8cpp_source.html#l00166">166</a> of file <a class="el" href="CallPromotionUtils_8cpp_source.html">CallPromotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="BasicBlock_8h_source.html#l00438">llvm::BasicBlock::begin()</a>, <a class="el" href="Instructions_8cpp_source.html#l03047">llvm::CastInst::CreateBitOrPointerCast()</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="ilist__node_8h_source.html#l00132">llvm::ilist_node_impl&lt; OptionsT &gt;::getIterator()</a>, <a class="el" href="User_8cpp_source.html#l00021">llvm::User::replaceUsesOfWith()</a>, <a class="el" href="BasicBlockUtils_8cpp_source.html#l00761">llvm::SplitEdge()</a>, and <a class="el" href="Value_8h_source.html#l00421">llvm::Value::users()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CallPromotionUtils_8cpp_source.html#l00481">llvm::promoteCall()</a>.</p>

</div>
</div>
<a id="abdf3ba57973320bd702d3b12b0b8fa8c" name="abdf3ba57973320bd702d3b12b0b8fa8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf3ba57973320bd702d3b12b0b8fa8c">&#9670;&#160;</a></span>createRetPHINode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void createRetPHINode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>OrigInst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>NewInst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>MergeBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IRBuilder.html">IRBuilder</a>&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a phi node for the returned value of a call or invoke instruction. </p>
<p>After versioning a call or invoke instruction that returns a value, we have to merge the value of the original and new instructions. We do this by creating a phi node and replacing uses of the original instruction with this phi node.</p>
<p>For example, if <code>OrigInst</code> is defined in "else_bb" and <code>NewInst</code> is defined in "then_bb", we create the following phi node:</p>
<p>; Uses of the original instruction are replaced by uses of the phi node. t0 = phi i32 [ orig_inst, else_bb ], [ new_inst, then_bb ], </p>

<p class="definition">Definition at line <a class="el" href="CallPromotionUtils_8cpp_source.html#l00111">111</a> of file <a class="el" href="CallPromotionUtils_8cpp_source.html">CallPromotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="BasicBlock_8h_source.html#l00438">llvm::BasicBlock::begin()</a>, <a class="el" href="ilist__node_8h_source.html#l00032">llvm::ilist_detail::node_parent_access&lt; NodeTy, ParentTy &gt;::getParent()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="Type_8h_source.html#l00140">llvm::Type::isVoidTy()</a>, <a class="el" href="Value_8h_source.html#l00344">llvm::Value::use_empty()</a>, and <a class="el" href="Value_8h_source.html#l00421">llvm::Value::users()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CallPromotionUtils_8cpp_source.html#l00285">versionCallSiteWithCond()</a>.</p>

</div>
</div>
<a id="a51ff57d75f102e980e39535df6ff00bb" name="a51ff57d75f102e980e39535df6ff00bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ff57d75f102e980e39535df6ff00bb">&#9670;&#160;</a></span>fixupPHINodeForNormalDest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fixupPHINodeForNormalDest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InvokeInst.html">InvokeInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Invoke</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>OrigBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>MergeBlock</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fix-up phi nodes in an invoke instruction's normal destination. </p>
<p>After versioning an invoke instruction, values coming from the original block will now be coming from the "merge" block. For example, in the code below:</p>
<p>then_bb: t0 = invoke i32 ptr() to label merge_bb unwind label unwind_dst</p>
<p>else_bb: t1 = invoke i32 ptr() to label merge_bb unwind label unwind_dst</p>
<p>merge_bb: t2 = phi i32 [ t0, then_bb ], [ t1, else_bb ] br normal_dst</p>
<p>normal_dst: t3 = phi i32 [ x, orig_bb ], ...</p>
<p>"orig_bb" is no longer a predecessor of "normal_dst", so the phi nodes in "normal_dst" must be fixed to refer to "merge_bb":</p>
<p>normal_dst: t3 = phi i32 [ x, merge_bb ], ... </p>

<p class="definition">Definition at line <a class="el" href="CallPromotionUtils_8cpp_source.html#l00054">54</a> of file <a class="el" href="CallPromotionUtils_8cpp_source.html">CallPromotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8h_source.html#l03659">llvm::InvokeInst::getNormalDest()</a>, and <a class="el" href="BasicBlock_8h_source.html#l00507">llvm::BasicBlock::phis()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CallPromotionUtils_8cpp_source.html#l00285">versionCallSiteWithCond()</a>.</p>

</div>
</div>
<a id="a59b92d3bbd9b21b61a2afbb73c10c3b0" name="a59b92d3bbd9b21b61a2afbb73c10c3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b92d3bbd9b21b61a2afbb73c10c3b0">&#9670;&#160;</a></span>fixupPHINodeForUnwindDest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fixupPHINodeForUnwindDest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InvokeInst.html">InvokeInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Invoke</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>OrigBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>ThenBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *</td>          <td class="paramname"><span class="paramname"><em>ElseBlock</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fix-up phi nodes in an invoke instruction's unwind destination. </p>
<p>After versioning an invoke instruction, values coming from the original block will now be coming from either the "then" block or the "else" block. For example, in the code below:</p>
<p>then_bb: t0 = invoke i32 ptr() to label merge_bb unwind label unwind_dst</p>
<p>else_bb: t1 = invoke i32 ptr() to label merge_bb unwind label unwind_dst</p>
<p>unwind_dst: t3 = phi i32 [ x, orig_bb ], ...</p>
<p>"orig_bb" is no longer a predecessor of "unwind_dst", so the phi nodes in "unwind_dst" must be fixed to refer to "then_bb" and "else_bb":</p>
<p>unwind_dst: t3 = phi i32 [ x, then_bb ], [ x, else_bb ], ... </p>

<p class="definition">Definition at line <a class="el" href="CallPromotionUtils_8cpp_source.html#l00085">85</a> of file <a class="el" href="CallPromotionUtils_8cpp_source.html">CallPromotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8h_source.html#l03662">llvm::InvokeInst::getUnwindDest()</a>, and <a class="el" href="BasicBlock_8h_source.html#l00507">llvm::BasicBlock::phis()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CallPromotionUtils_8cpp_source.html#l00285">versionCallSiteWithCond()</a>.</p>

</div>
</div>
<a id="aaabc735841282ccafdf43b7c165b030e" name="aaabc735841282ccafdf43b7c165b030e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabc735841282ccafdf43b7c165b030e">&#9670;&#160;</a></span>versionCallSiteWithCond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1CallBase.html">CallBase</a> &amp; versionCallSiteWithCond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CallBase.html">CallBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>CB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MDNode.html">MDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>BranchWeights</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate and clone the given call site. </p>
<p>This function creates an if-then-else structure at the location of the call site. The "if" condition is specified by <code>Cond</code>. The original call site is moved into the "else" block, and a clone of the call site is placed in the "then" block. The cloned instruction is returned.</p>
<p>For example, the call instruction below:</p>
<p>orig_bb: t0 = call i32 ptr() ...</p>
<p>Is replace by the following:</p>
<p>orig_bb: cond = Cond br i1 cond, then_bb, else_bb</p>
<p>then_bb: ; The clone of the original call instruction is placed in the "then" ; block. It is not yet promoted. t1 = call i32 ptr() br merge_bb</p>
<p>else_bb: ; The original call instruction is moved to the "else" block. t0 = call i32 ptr() br merge_bb</p>
<p>merge_bb: ; Uses of the original call instruction are replaced by uses of the phi ; node. t2 = phi i32 [ t0, else_bb ], [ t1, then_bb ] ...</p>
<p>A similar transformation is performed for invoke instructions. However, since invokes are terminating, more work is required. For example, the invoke instruction below:</p>
<p>orig_bb: t0 = invoke ptr() to label normal_dst unwind label unwind_dst</p>
<p>Is replace by the following:</p>
<p>orig_bb: cond = Cond br i1 cond, then_bb, else_bb</p>
<p>then_bb: ; The clone of the original invoke instruction is placed in the "then" ; block, and its normal destination is set to the "merge" block. It is ; not yet promoted. t1 = invoke i32 ptr() to label merge_bb unwind label unwind_dst</p>
<p>else_bb: ; The original invoke instruction is moved into the "else" block, and ; its normal destination is set to the "merge" block. t0 = invoke i32 ptr() to label merge_bb unwind label unwind_dst</p>
<p>merge_bb: ; Uses of the original invoke instruction are replaced by uses of the ; phi node, and the merge block branches to the normal destination. t2 = phi i32 [ t0, else_bb ], [ t1, then_bb ] br normal_dst</p>
<p>An indirect musttail call is processed slightly differently in that:</p><ol type="1">
<li>No merge block needed for the orginal and the cloned callsite, since either one ends the flow. No phi node is needed either.</li>
<li>The return statement following the original call site is duplicated too and placed immediately after the cloned call site per the IR convention.</li>
</ol>
<p>For example, the musttail call instruction below:</p>
<p>orig_bb: t0 = musttail call i32 ptr() ...</p>
<p>Is replaced by the following:</p>
<p>cond_bb: cond = Cond br i1 cond, then_bb, orig_bb</p>
<p>then_bb: ; The clone of the original call instruction is placed in the "then" ; block. It is not yet promoted. t1 = musttail call i32 ptr() ret t1</p>
<p>orig_bb: ; The original call instruction stays in its original block. t0 = musttail call i32 ptr() ret t0 </p>

<p class="definition">Definition at line <a class="el" href="CallPromotionUtils_8cpp_source.html#l00285">285</a> of file <a class="el" href="CallPromotionUtils_8cpp_source.html">CallPromotionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Casting_8h_source.html#l00565">llvm::cast()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l01299">llvm::Instruction::clone()</a>, <a class="el" href="RISCVRedundantCopyElimination_8cpp_source.html#l00075">Cond</a>, <a class="el" href="CallPromotionUtils_8cpp_source.html#l00111">createRetPHINode()</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="Casting_8h_source.html#l00759">llvm::dyn_cast_or_null()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00092">llvm::Instruction::eraseFromParent()</a>, <a class="el" href="CallPromotionUtils_8cpp_source.html#l00054">fixupPHINodeForNormalDest()</a>, <a class="el" href="CallPromotionUtils_8cpp_source.html#l00085">fixupPHINodeForUnwindDest()</a>, <a class="el" href="ilist__node_8h_source.html#l00353">llvm::ilist_node_with_parent&lt; NodeTy, ParentTy, Options &gt;::getNextNode()</a>, <a class="el" href="ilist__node_8h_source.html#l00032">llvm::ilist_detail::node_parent_access&lt; NodeTy, ParentTy &gt;::getParent()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00097">llvm::Instruction::insertBefore()</a>, <a class="el" href="Instructions_8cpp_source.html#l00340">llvm::CallBase::isMustTailCall()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00167">llvm::Instruction::moveBefore()</a>, <a class="el" href="InstrProf_8h_source.html#l00141">llvm::Next</a>, <a class="el" href="Value_8cpp_source.html#l00377">llvm::Value::setName()</a>, <a class="el" href="BasicBlockUtils_8cpp_source.html#l01608">llvm::SplitBlockAndInsertIfThen()</a>, and <a class="el" href="BasicBlockUtils_8cpp_source.html#l01634">llvm::SplitBlockAndInsertIfThenElse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CallPromotionUtils_8cpp_source.html#l00575">llvm::promoteCallWithVTableCmp()</a>, and <a class="el" href="CallPromotionUtils_8cpp_source.html#l00381">llvm::versionCallSite()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Nov 1 2024 13:46:55 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
