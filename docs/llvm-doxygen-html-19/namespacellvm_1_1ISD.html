<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: llvm::ISD Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;19.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacellvm.html">llvm</a></li><li class="navelem"><a class="el" href="namespacellvm_1_1ISD.html">ISD</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">llvm::ISD Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespacellvm_1_1ISD.html" title="ISD namespace - This namespace contains an enum which represents all of the SelectionDAG node types a...">ISD</a> namespace - This namespace contains an enum which represents all of the <a class="el" href="classllvm_1_1SelectionDAG.html" title="This is used to represent a portion of an LLVM function in a low-level Data Dependence DAG representa...">SelectionDAG</a> node types and value types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1ISD_1_1GlobalISel.html">GlobalISel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1ISD_1_1ArgFlagsTy.html">ArgFlagsTy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1ISD_1_1InputArg.html">InputArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structllvm_1_1ISD_1_1InputArg.html" title="InputArg - This struct carries flags and type information about a single incoming (formal) argument o...">InputArg</a> - This struct carries flags and type information about a single incoming (formal) argument or incoming (from the perspective of the caller) return value virtual register.  <a href="structllvm_1_1ISD_1_1InputArg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1ISD_1_1OutputArg.html">OutputArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structllvm_1_1ISD_1_1OutputArg.html" title="OutputArg - This struct carries flags and a value for a single outgoing (actual) argument or outgoing...">OutputArg</a> - This struct carries flags and a value for a single outgoing (actual) argument or outgoing (from the perspective of the caller) return value virtual register.  <a href="structllvm_1_1ISD_1_1OutputArg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a22ea9cec080dd5f4f47ba234c2f59110" id="r_a22ea9cec080dd5f4f47ba234c2f59110"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110">NodeType</a> { <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a062083eb3ff8c441c73d3bf42ca09bba">DELETED_NODE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a926013f6dca240eca95aca66c8d3e74b">EntryToken</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad469508535ce2082a1ab1f0e429187b8">TokenFactor</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aee4f13218bdbb5c5697f7e786618ecb2">AssertSext</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110af23301e60475124fd80a2cb51f6ba863">AssertZext</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a8005dc9efe12e770682b4b5200dad30b">AssertAlign</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a8472e46f9e4db168c5610ecdfb05dbaf">BasicBlock</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a40d4f41a75df8e16bc5dbe62d62465b8">VALUETYPE</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aa366e6b1653ab1cedbeeaef9afecedd7">CONDCODE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a419e8283a58d2b1b86591fa7f18ccfd9">Register</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7e54881d7b0838c37485e4c79d215d07">RegisterMask</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aac2f0a84dd2aa5ee4c3f1385e9565f5e">Constant</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a1be4c8da7c68a4c683de1a98b5cc5b9d">ConstantFP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a30316f8f9985260c49d7c26bc70a6cad">GlobalAddress</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a49f1172c7014cc4fa3570792e6834e2c">GlobalTLSAddress</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a4b437632fd9b97dd36010d85eb363efe">FrameIndex</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a0c70100db6ddc0b37b56feb242145cf4">JumpTable</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aa8cad208c3cb96b33b5d8544590325b1">ConstantPool</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad88f843bce966361c7fd2cd022e6528a">ExternalSymbol</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ae98378a8672947382d343d75a5df3003">BlockAddress</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a8df1b84ea64ad5048f27873205c8ab89">PtrAuthGlobalAddress</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aaef4ead62e1835b863820f6c818c36ac">GLOBAL_OFFSET_TABLE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110abdb38c8daa8c1ab881007062d113cef3">FRAMEADDR</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a2dfacb29792dd59f2cfbe529206265bc">RETURNADDR</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a591c03cc284124ff624856ce485ebc17">ADDROFRETURNADDR</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110add9a41fa65a9675200d73710a82b880e">SPONENTRY</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a9d483820471b07a73225bf33986fd110">LOCAL_RECOVER</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a92fceabd268d62ef2c95799a102b8abf">READ_REGISTER</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a61a1595d03afe86764ad7625d358608e">WRITE_REGISTER</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a228deacdfba1bd2d5a3663b19609f945">FRAME_TO_ARGS_OFFSET</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110abad932e63381a4671b5db19a3404c82e">EH_DWARF_CFA</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a4edf35e2383003ff20057e5a45012a55">EH_RETURN</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ae5a57fe9fd413df909ab121ca1a813c7">EH_SJLJ_SETJMP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a122a450e069003dc86859ef47ab6e278">EH_SJLJ_LONGJMP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a2e0f3a93e85a46b2ebac7330c2a0c581">EH_SJLJ_SETUP_DISPATCH</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac479e53ca98903b1028ec80e12fb0af8">TargetConstant</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a95cd714ab601765342e2ec9f6ba2cb34">TargetConstantFP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a87b8176af163ee944af127081d24f4a2">TargetGlobalAddress</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110afc9ad7857b7faf49dcde3dcf434e22a6">TargetGlobalTLSAddress</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aa84894f4966964ef9fc79f9515a6c875">TargetFrameIndex</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a603c0651ff8c3a929c5e1d8b9a8f14cb">TargetJumpTable</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a038a7f124b4118456a27a739c03650bf">TargetConstantPool</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a59b314018a929255951f01f8daaae72f">TargetExternalSymbol</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a1b7eba375863a0e80549eb1a782c5683">TargetBlockAddress</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aabb68e91001557f73ff8af63eb8d5883">MCSymbol</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a606393d2a8329de83a61d6f6447d1035">TargetIndex</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac771b9cda3b889242d457cc4d9b2159c">INTRINSIC_WO_CHAIN</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110afc09e0bddd693dcf9923e4df42473bd9">INTRINSIC_W_CHAIN</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a2df96794a99f5d3b4415c4a84e616140">INTRINSIC_VOID</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a93bc27ca4d9e211c54b0d9efb660f080">CopyToReg</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a84c47705bcf7271413738ae8bf3871e6">CopyFromReg</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7c6d8f265e9e16e5debdb9a536b55d3d">UNDEF</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad3b50b6d74957b19afb85ac29f66afef">FREEZE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7e6dca8262a3de788d1bab4ba184d675">EXTRACT_ELEMENT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a41bd84b853e2c03fb1af1f4ca9ebdcaf">BUILD_PAIR</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a01c94937492f3ac3fb1e0be8eb0b9ef1">MERGE_VALUES</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a269996b43a1f3e1d1f84a70fd4387535">ADD</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a9fa617e5567c3c2638938f7b9ddc3f1c">SUB</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad8aec9273962cf78d087090c11a1dd1c">MUL</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a1f61c2422057e10403b2f6003543c300">SDIV</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a15637879021fa7d5226045c0668a99a8">UDIV</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a124ba0f5b2887879212c74a68bc230a3">SREM</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad1657dbc1957901a6d9cd224efbc0f28">UREM</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a1354c6f8508d6cd697dc89a5d9a52dfd">SMUL_LOHI</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a79c959df09509d7ff66d9b04bc40d18d">UMUL_LOHI</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a3a874f66e1efe5be79552bbe7ee3121a">SDIVREM</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a3a257ffa49107e2db978e8a6e2688ada">UDIVREM</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110acc20c926003b2af97ba08689176e7130">CARRY_FALSE</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a20084f62caecb0db80ad71bdabda73c2">ADDC</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a2ab6db512a611d1ef4ff8069e2bbfd0d">SUBC</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad116e32876f2275acf60ffb1651c9256">ADDE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac9246c101c0cc9232e37b3941194bb13">SUBE</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ab0f1e3ed26108fec69eb97209c0e39bf">UADDO_CARRY</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac81ebcd59d629d8680e50ffba9855255">USUBO_CARRY</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110af9eda6a77c3228cd36537469a7425133">SADDO_CARRY</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a139dc5419039d94496e69dbb264251b5">SSUBO_CARRY</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a863ec6ebb75bf89cfea14da646d77e92">SADDO</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a1ddf36330110b4abea43fe390bea9ef9">UADDO</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a6efe16ea597cfd8eeac26516fc992ee7">SSUBO</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a4ffc75d65231b55461c0ba4f36a3e500">USUBO</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aa35d0a58fdded3d225d512a60aea0951">SMULO</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7800622851751b8ae318b41f4096830e">UMULO</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110af1b946afff631cee7aa6de570bef7785">SADDSAT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a5e433873c201ad85c30e42da1ae05977">UADDSAT</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a77984d86d70df1f3229da7a5119652a9">SSUBSAT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a89166b38f12c0bd3e8a61d8f1a5a8bc8">USUBSAT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aa30a145a99902daca036d039378abca2">SSHLSAT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a5ae4b108d3f627b66f3b1e5da51f4587">USHLSAT</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a1a7f3f523e22ac3df6332e625289a7e6">SMULFIX</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a293cdca810c396f99a2bd63b017dd943">UMULFIX</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a26a7dd56cd899cec0a1f6d2443f91db4">SMULFIXSAT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aaab3219acc86e3b3a199effbb69aa07a">UMULFIXSAT</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a470242ff0d0c1f979101aa369a3a410e">SDIVFIX</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aaa5af2aa3cc2e31b44b69d43e13235be">UDIVFIX</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aadc85d973be8149bbaa5f372aa1faf3e">SDIVFIXSAT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a5c5ebc516cae422508ee0c062ef6b593">UDIVFIXSAT</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a32ec12017722f5b42a295fe5eb0b0bdf">FADD</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a2852a5b6baa80b1589a46737210a8cad">FSUB</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a9ab5860c97a00c4627a08cab7b0c8178">FMUL</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110abc6c09c7af98236460f0b020eb3be94e">FDIV</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110abdd7bbb76dac7962dda6e116e33699da">FREM</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad11fa7fd2a91d210ecbdf09d56cd9f42">STRICT_FADD</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad6192a54cb1dfeca8173749cc735269a">STRICT_FSUB</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a4b912b6be299d30d75b876e939d16fd6">STRICT_FMUL</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a4151e13f7626f6d790d58c0fa444f32e">STRICT_FDIV</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aacf4034f48b7e32a9e20bfedbb5502bd">STRICT_FREM</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a26ff7f7547f66e1a4f6d5e7efe4b2f59">STRICT_FMA</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a476844aad24870fab3d132b5fe6b1f37">STRICT_FSQRT</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a65a342694a17f4a1db771dbc36d31cc9">STRICT_FPOW</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7acf26c84b90a50efe9898bc9bcd8d18">STRICT_FPOWI</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110addd63c6d866c8a8020a0cc4de467b285">STRICT_FLDEXP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a06c721642eadaa31c37384b39fe11387">STRICT_FSIN</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ae2047d551dd66943aa285b4c7eab0766">STRICT_FCOS</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad8ae8131038d9b94abd2880812bf5b0e">STRICT_FTAN</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a548c5ee9bfffd516c18b0844d8916d98">STRICT_FASIN</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110afc1699b53cce73a1a89fa9190db8f2f8">STRICT_FACOS</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a5fc35989024437e6878d228dce85b34d">STRICT_FATAN</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a9b07fb8cd5a1230b0f736489ddd9eebc">STRICT_FSINH</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac9090021eb9a063125475a3d2f380af2">STRICT_FCOSH</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a244401fe9aee94da72b7f0fb6b095a45">STRICT_FTANH</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aba2dfbb2100ec6aee6e5b52bc713c26a">STRICT_FEXP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad5d3bf9997ecfea792abc058e7d39e72">STRICT_FEXP2</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad795680a8d2d37bdede6696d72f41c35">STRICT_FLOG</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad227f160898f13eeb05150f03de8d40b">STRICT_FLOG10</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a409f18d3c3acb29ab844e9942441cc4b">STRICT_FLOG2</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110af57a22f2843a1c3a79d17350945ede58">STRICT_FRINT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ae463c3e40819d6e9de30d7d858867ef4">STRICT_FNEARBYINT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a92f7a0e4dfe860ff938d463d84270ba3">STRICT_FMAXNUM</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a98f18e85e4e6421f5c859680602a4c1f">STRICT_FMINNUM</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a1fb1e48394636004fd75f5916f0d730f">STRICT_FCEIL</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ab74cbb3933c5f5d2cc90d299836c05cc">STRICT_FFLOOR</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ab0953e80e4e94f6ded9680e64c5df5cc">STRICT_FROUND</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ab7d5c27c800b79a02a1492f1965af72f">STRICT_FROUNDEVEN</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a883c1084962f12018ca0fe3e1222fa7d">STRICT_FTRUNC</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a6bd04c8da718875a071107ede0f362d6">STRICT_LROUND</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110adef1eba7d8c2a0db4a94d7327d217c90">STRICT_LLROUND</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aa7fc883444df66de315a684ecf5f5e2d">STRICT_LRINT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad4892124e4817d9807dcf39808016bc4">STRICT_LLRINT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a917038ef7ae3264e336457da0f75e95b">STRICT_FMAXIMUM</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a3093a04e2918e155f32d435e2f974e88">STRICT_FMINIMUM</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac2618c1a69fa9d62427a5a6dc43e24ed">STRICT_FP_TO_SINT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110abf955b4b70f63865e022c329d1775579">STRICT_FP_TO_UINT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ab38d2af541b99492acf69c041c98bcb6">STRICT_SINT_TO_FP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a56735332b7dc26b4e164035831fb40ab">STRICT_UINT_TO_FP</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac2273d9cd04ba6e4a7c1a4b28ab1aaba">STRICT_FP_ROUND</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac47e026e409ff39f319cbb3b096863e6">STRICT_FP_EXTEND</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a0466b21bfb4f3596e41380d8e2d1956f">STRICT_FSETCC</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a3c8d07d668872f2176fb34724cd799c4">STRICT_FSETCCS</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a40b296b7db128b2d63f81a95efc5a311">FPTRUNC_ROUND</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a293ca68b3b2ce80eef991de822822254">FMA</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a2415bea72c995bb9cf9f85bbbf90bcd7">FMAD</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aeffc3319657e213a530ce583603f7221">FCOPYSIGN</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a130b6a6d409367c8a61dd14dfa39785c">FGETSIGN</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a74a787311d3ab9a17ee0acde7b6a6b14">FCANONICALIZE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a76b6d3008e806ea613323ff316ef72c3">IS_FPCLASS</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aff6f73b624fecca7dbe94259f9437e32">BUILD_VECTOR</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad3bc7c2d379fbfdc2f8eaca038690ec9">INSERT_VECTOR_ELT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a9329e79f62e9ab9b41cfbcafd314bcbd">EXTRACT_VECTOR_ELT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a320898056eadc3254fc601e1362eb9f5">CONCAT_VECTORS</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a1617abaedbb1d902bb3a5b3136684f9c">INSERT_SUBVECTOR</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a9070de8a5c5b71851732c4c54e2ffedf">EXTRACT_SUBVECTOR</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110af5b978686fa3409a40ce3abe447db653">VECTOR_DEINTERLEAVE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7314e9c42c2c93e3786adfd12aee39d7">VECTOR_INTERLEAVE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aad7728df1343db6f976857aaa2e945ee">VECTOR_REVERSE</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a8d8773b28111d8898663d4a0f6223d68">VECTOR_SHUFFLE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad55a17543ef86f6d46aebb45028a9067">VECTOR_SPLICE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a576080a08ef1bbab0308eac9d5838f75">SCALAR_TO_VECTOR</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7f864031b6fb691b1525cbea92542ef1">SPLAT_VECTOR</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad358f0823a936bde7edd419ab1058bd4">SPLAT_VECTOR_PARTS</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a73ec2109e5056d5cb07dad24ddd848c3">STEP_VECTOR</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110adb06c311948bd9fb944ab3c433138181">VECTOR_COMPRESS</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a8a80d3b085af08f0dce1724207ef99b5">MULHU</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aa2a7c3eccf06b41e4275bbeadb46d22e">MULHS</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110acc5444f2e2933b551e3afbdd93a9bfc8">AVGFLOORS</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a5096628a43b16ff34ace64193ded1c93">AVGFLOORU</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a55a4b1d94ca6176bcb5449196d67e798">AVGCEILS</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a8489c40b1b3f92b0c4fc98d06099c441">AVGCEILU</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110af798622367e75c5536666dbfec5d5ea3">ABDS</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aff129f5ab4fbc8279e7aaacb45f840b1">ABDU</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aaac895215ecbb3c411c957c8beb39b70">SMIN</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110af3b59179b6fcbc89463181015ace8e9b">SMAX</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a17126302da6199930e55e841ca1b082d">UMIN</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110af675e759c0ffff8d48ea14a60fe3517b">UMAX</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac9cda41d5b1ac3a0babb77b881b506eb">SCMP</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a482ae65625bd4d6059f7259b88ac4dbc">UCMP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac513a7da1bf74fb3e3c594da8534f2d2">AND</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7415ab9f2172c59a2ee7c7a02afa56a4">OR</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a92febb83e6ba116eb7aae8e7e3f70cc1">XOR</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a35c1cf0dd553444732dba8e8b9be0f6b">ABS</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a8cc94e03dea594863073a02f5bb94997">SHL</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a4a055321c361a0f6ee77ed764730ffc1">SRA</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a3c6553c8acebe1b57c211ee45e2d8f98">SRL</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ae8f8f81d8e8d7a557d67622c05786f1d">ROTL</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a19cd524269b035941434cce28b585715">ROTR</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a822b0d02b601898e2d6db5b39e12cc8a">FSHL</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a874350de5b4f6b8f4db13940e17ed81b">FSHR</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a19328c462764af5f4699fb1698dad994">BSWAP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a6da41a113af0909470baea7486b3386b">CTTZ</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110add33c0ae9a63902e573fc1f92fc33f1c">CTLZ</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a991d07d163bd4d9984cf1ef36e92c214">CTPOP</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aeea401cc0b7fa5aa6f4d3a0612140e1d">BITREVERSE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aa47439d20ce0879ea68ca293e018b4f5">PARITY</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a601e66a26efd05520f7cb26aef3af340">CTTZ_ZERO_UNDEF</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a0340c8d57d1dcebc43a00412989583d3">CTLZ_ZERO_UNDEF</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a78d0f198115bfe3331ab7cfcf7a40a97">SELECT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ab0b7d2c769fd0fbaab3c4a2fc8e7ea0c">VSELECT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a99ad6b342b7457df56b91d24e66016b3">SELECT_CC</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a0158ee47dfa868be5d28e2cbef70d5d0">SETCC</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a6bb33e400f29724907dc27ced04e9038">SETCCCARRY</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aeb80f9832dad739ee9c6deaa3110d98f">SHL_PARTS</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a78139be59781ad05e1698eb95c58e0b1">SRA_PARTS</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a9ed8e1dc0db59ab2a071da53ee794759">SRL_PARTS</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a5183f3d72924bc7c77ba8d3f5de9f602">SIGN_EXTEND</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a93fdf85eff945f1a668b4915a051453e">ZERO_EXTEND</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a27d5d8ef82302b739ba3ca8be1a5513d">ANY_EXTEND</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ae690127648393001a7d5b93dc23da7b3">TRUNCATE</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a315004656a75a3c3a9d7294f105a8da2">SINT_TO_FP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a169032eecd015d4eeb869c457202a6c8">UINT_TO_FP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aaa59dd5ec37f21905436b354c0292d9e">SIGN_EXTEND_INREG</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aaa275bf149ab5df1067cfb721936ecbc">ANY_EXTEND_VECTOR_INREG</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a3893859b5caa079593b9bf91b96e05fb">SIGN_EXTEND_VECTOR_INREG</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110adf7f4fc30c272a1987e075d7470df84c">ZERO_EXTEND_VECTOR_INREG</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac3f8f8d8437c64b2e2e9f978e2707210">FP_TO_SINT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a71640703ec096a8b07111e85cfff6987">FP_TO_UINT</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ae4a4e2126c6db34e2dfd71b6bd0408ee">FP_TO_SINT_SAT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a98661814400e72a77f5ed4e088c06937">FP_TO_UINT_SAT</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110adaf9a3cb5c2ef5eb713bd6bf4ae23aeb">FP_ROUND</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a89f3afc3fa907ff83759c6c76d97a973">GET_ROUNDING</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a041c4b27006496ee8d8bcdf72e248632">CONVERGENCECTRL_ANCHOR</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a5a787d44a3bcbc803d314896056d9569">CONVERGENCECTRL_ENTRY</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110adef60c4df07ee437cd2714f7b18f93f2">CONVERGENCECTRL_LOOP</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a509e81081ec1935d3f4f0df758c60e0f">CONVERGENCECTRL_GLUE</a>
, <br />
&#160;&#160;<a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ae243ce466d350b1aca774a6ae9aea81c">EXPERIMENTAL_VECTOR_HISTOGRAM</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110addc63b0e91a7c2b397e7908052d8caf9">CLEAR_CACHE</a>
, <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a477ef80c70c7359199eace0e5d3133b1">BUILTIN_OP_END</a>
<br />
 }</td></tr>
<tr class="memdesc:a22ea9cec080dd5f4f47ba234c2f59110"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISD::NodeType enum - This enum defines the target-independent operators for a SelectionDAG.  <a href="#a22ea9cec080dd5f4f47ba234c2f59110">More...</a><br /></td></tr>
<tr class="separator:a22ea9cec080dd5f4f47ba234c2f59110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee7ecb577fcade34eb16ccb7f503e31" id="r_abee7ecb577fcade34eb16ccb7f503e31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abee7ecb577fcade34eb16ccb7f503e31">MemIndexedMode</a> { <br />
&#160;&#160;<a class="el" href="#abee7ecb577fcade34eb16ccb7f503e31ade1c53e7b8a373e22ec53ff7bcbace9f">UNINDEXED</a> = 0
, <a class="el" href="#abee7ecb577fcade34eb16ccb7f503e31ab5bb854fadd42503c849c4a48d7f3d90">PRE_INC</a>
, <a class="el" href="#abee7ecb577fcade34eb16ccb7f503e31a57c3822f99653c422d5a21206adc6e42">PRE_DEC</a>
, <a class="el" href="#abee7ecb577fcade34eb16ccb7f503e31a866c29237765ff291c9503abbdca60e1">POST_INC</a>
, <br />
&#160;&#160;<a class="el" href="#abee7ecb577fcade34eb16ccb7f503e31a10a4094c81c0b9cd5e82e53b48932203">POST_DEC</a>
<br />
 }</td></tr>
<tr class="memdesc:abee7ecb577fcade34eb16ccb7f503e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">MemIndexedMode enum - This enum defines the load / store indexed addressing modes.  <a href="#abee7ecb577fcade34eb16ccb7f503e31">More...</a><br /></td></tr>
<tr class="separator:abee7ecb577fcade34eb16ccb7f503e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30bf48cd2a89f80c9c608adcabc53e3" id="r_aa30bf48cd2a89f80c9c608adcabc53e3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa30bf48cd2a89f80c9c608adcabc53e3">MemIndexType</a> { <a class="el" href="#aa30bf48cd2a89f80c9c608adcabc53e3a0173acb50fe8c4337c23a98baab3f4db">SIGNED_SCALED</a> = 0
, <a class="el" href="#aa30bf48cd2a89f80c9c608adcabc53e3af3218635b665db9e7e1d97e015f14e3a">UNSIGNED_SCALED</a>
 }</td></tr>
<tr class="memdesc:aa30bf48cd2a89f80c9c608adcabc53e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">MemIndexType enum - This enum defines how to interpret MGATHER/SCATTER's index parameter when calculating addresses.  <a href="#aa30bf48cd2a89f80c9c608adcabc53e3">More...</a><br /></td></tr>
<tr class="separator:aa30bf48cd2a89f80c9c608adcabc53e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d48171b87ca51ff54c10a436bac4d7" id="r_ad4d48171b87ca51ff54c10a436bac4d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4d48171b87ca51ff54c10a436bac4d7">LoadExtType</a> { <a class="el" href="#ad4d48171b87ca51ff54c10a436bac4d7a6aacde2c67988b43a261a7f7ceac4be3">NON_EXTLOAD</a> = 0
, <a class="el" href="#ad4d48171b87ca51ff54c10a436bac4d7afab3fffd153f7d7770fed81272e4b78f">EXTLOAD</a>
, <a class="el" href="#ad4d48171b87ca51ff54c10a436bac4d7a6c61b6125c7901c549f90ee0e443a770">SEXTLOAD</a>
, <a class="el" href="#ad4d48171b87ca51ff54c10a436bac4d7a8d89c7da4444d9ec11667aa369abc5f7">ZEXTLOAD</a>
 }</td></tr>
<tr class="memdesc:ad4d48171b87ca51ff54c10a436bac4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">LoadExtType enum - This enum defines the three variants of LOADEXT (load with extension).  <a href="#ad4d48171b87ca51ff54c10a436bac4d7">More...</a><br /></td></tr>
<tr class="separator:ad4d48171b87ca51ff54c10a436bac4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c3cf58d6d631af6a172457304d3d07" id="r_ac3c3cf58d6d631af6a172457304d3d07"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> { <br />
&#160;&#160;<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07ae258b87332b47d96bdf47e4cd915f9ea">SETFALSE</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a08c31033acfb9d6f0bc4a8a82cc26862">SETOEQ</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a31d1e24e08b255d6aa290d67d16ce2c9">SETOGT</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07ac7bb30d4918c1ee9dd208083154e109f">SETOGE</a>
, <br />
&#160;&#160;<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a20257a4d3833cf88afd42caeaed70dde">SETOLT</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a1febf3bac2f3d7d98ec19f1ff5c385ea">SETOLE</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a57c68bf7ef20bd558854a24d5b0c1e72">SETONE</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a71f916390487bb109d9968c72553eaf4">SETO</a>
, <br />
&#160;&#160;<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a48a334bbe606d5e82c9cd84eaa127b50">SETUO</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a0deb50cd2f3f8e4a94eef4cdf769b848">SETUEQ</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a292be4a9782030bfad637581d25a5897">SETUGT</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a9dff1dcbac65852b71473818c11869b1">SETUGE</a>
, <br />
&#160;&#160;<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a473200f06bdd611fdbed43d908b84305">SETULT</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07ac538f0b432df970cbaaf6b81d777c6a7">SETULE</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a0d1546187d4d526fcbdd43183689075e">SETUNE</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a8e273eab0623ea5713aa5bcbdac2b16b">SETTRUE</a>
, <br />
&#160;&#160;<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a66792a566255872c951cb6b8f9cb0541">SETFALSE2</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07ae2e6a5e32087b9f65bd51585a6a5afb4">SETEQ</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a5ad12b466e3a5900d0c307b301465d25">SETGT</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a7f47862de23f7210f88ccf98ae1efbe4">SETGE</a>
, <br />
&#160;&#160;<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a6f05a09edb671910f85f8665981cbde9">SETLT</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07ab49f81c2ecbbff3d0fbe55dd46353774">SETLE</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a2887cc8b39915a25180f4bca0026a15e">SETNE</a>
, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07a1a575d029fd38d929229ac39e573e8fc">SETTRUE2</a>
, <br />
&#160;&#160;<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07aeded54fe1be320194e9ff0f5825df0e5">SETCC_INVALID</a>
<br />
 }</td></tr>
<tr class="memdesc:ac3c3cf58d6d631af6a172457304d3d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISD::CondCode enum - These are ordered carefully to make the bitfields below work out, when considering SETFALSE (something that never exists dynamically) as 0.  <a href="#ac3c3cf58d6d631af6a172457304d3d07">More...</a><br /></td></tr>
<tr class="separator:ac3c3cf58d6d631af6a172457304d3d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6b220b2107d211a5db501de58981e214" id="r_a6b220b2107d211a5db501de58981e214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b220b2107d211a5db501de58981e214">isBitwiseLogicOp</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode)</td></tr>
<tr class="memdesc:a6b220b2107d211a5db501de58981e214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this is bitwise logic opcode.  <br /></td></tr>
<tr class="separator:a6b220b2107d211a5db501de58981e214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace75a0fc6736a8bf8b8187083078354d" id="r_ace75a0fc6736a8bf8b8187083078354d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110">NodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace75a0fc6736a8bf8b8187083078354d">getVecReduceBaseOpcode</a> (<a class="el" href="classunsigned.html">unsigned</a> VecReduceOpcode)</td></tr>
<tr class="memdesc:ace75a0fc6736a8bf8b8187083078354d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get underlying scalar opcode for VECREDUCE opcode.  <br /></td></tr>
<tr class="separator:ace75a0fc6736a8bf8b8187083078354d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1c239da7e4526d3140443b3bf6f8d7" id="r_aed1c239da7e4526d3140443b3bf6f8d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed1c239da7e4526d3140443b3bf6f8d7">isVPOpcode</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode)</td></tr>
<tr class="memdesc:aed1c239da7e4526d3140443b3bf6f8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this is a vector-predicated Opcode.  <br /></td></tr>
<tr class="separator:aed1c239da7e4526d3140443b3bf6f8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec28aae630b390b75abfebf79bce788" id="r_a5ec28aae630b390b75abfebf79bce788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ec28aae630b390b75abfebf79bce788">isVPBinaryOp</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode)</td></tr>
<tr class="memdesc:a5ec28aae630b390b75abfebf79bce788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this is a vector-predicated binary operation opcode.  <br /></td></tr>
<tr class="separator:a5ec28aae630b390b75abfebf79bce788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d0f87095c6d1ece5c444d0e030083d" id="r_ab7d0f87095c6d1ece5c444d0e030083d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7d0f87095c6d1ece5c444d0e030083d">isVPReduction</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode)</td></tr>
<tr class="memdesc:ab7d0f87095c6d1ece5c444d0e030083d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this is a vector-predicated reduction opcode.  <br /></td></tr>
<tr class="separator:ab7d0f87095c6d1ece5c444d0e030083d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7437e83b31f58ab47107029f63bd70b0" id="r_a7437e83b31f58ab47107029f63bd70b0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7437e83b31f58ab47107029f63bd70b0">getVPMaskIdx</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode)</td></tr>
<tr class="memdesc:a7437e83b31f58ab47107029f63bd70b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operand position of the vector mask.  <br /></td></tr>
<tr class="separator:a7437e83b31f58ab47107029f63bd70b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d086c45b7e89dc21157d97b9fc150a5" id="r_a8d086c45b7e89dc21157d97b9fc150a5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d086c45b7e89dc21157d97b9fc150a5">getVPExplicitVectorLengthIdx</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode)</td></tr>
<tr class="memdesc:a8d086c45b7e89dc21157d97b9fc150a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operand position of the explicit vector length parameter.  <br /></td></tr>
<tr class="separator:a8d086c45b7e89dc21157d97b9fc150a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67022d78a6d8ee4377558da9ff259b8b" id="r_a67022d78a6d8ee4377558da9ff259b8b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67022d78a6d8ee4377558da9ff259b8b">getBaseOpcodeForVP</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classbool.html">bool</a> hasFPExcept)</td></tr>
<tr class="memdesc:a67022d78a6d8ee4377558da9ff259b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate this VP Opcode to its corresponding non-VP Opcode.  <br /></td></tr>
<tr class="separator:a67022d78a6d8ee4377558da9ff259b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e29f855114c8d578b8d3acc09abe71a" id="r_a2e29f855114c8d578b8d3acc09abe71a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e29f855114c8d578b8d3acc09abe71a">getVPForBaseOpcode</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode)</td></tr>
<tr class="memdesc:a2e29f855114c8d578b8d3acc09abe71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate this non-VP Opcode to its corresponding VP Opcode.  <br /></td></tr>
<tr class="separator:a2e29f855114c8d578b8d3acc09abe71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247f22e450c54c4a1c680641cb7546e7" id="r_a247f22e450c54c4a1c680641cb7546e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a247f22e450c54c4a1c680641cb7546e7">isIndexTypeSigned</a> (<a class="el" href="#aa30bf48cd2a89f80c9c608adcabc53e3">MemIndexType</a> IndexType)</td></tr>
<tr class="separator:a247f22e450c54c4a1c680641cb7546e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdb5c9abf8403d4dbf0d8ae59d89916" id="r_a2fdb5c9abf8403d4dbf0d8ae59d89916"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110">NodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fdb5c9abf8403d4dbf0d8ae59d89916">getExtForLoadExtType</a> (<a class="el" href="classbool.html">bool</a> IsFP, <a class="el" href="#ad4d48171b87ca51ff54c10a436bac4d7">LoadExtType</a>)</td></tr>
<tr class="separator:a2fdb5c9abf8403d4dbf0d8ae59d89916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae86ddfa346964171caa61f29d46294b" id="r_aae86ddfa346964171caa61f29d46294b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae86ddfa346964171caa61f29d46294b">isSignedIntSetCC</a> (<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> Code)</td></tr>
<tr class="memdesc:aae86ddfa346964171caa61f29d46294b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a setcc instruction that performs a signed comparison when used with integer operands.  <br /></td></tr>
<tr class="separator:aae86ddfa346964171caa61f29d46294b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb237925346ec53b00d3c82a42311318" id="r_adb237925346ec53b00d3c82a42311318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb237925346ec53b00d3c82a42311318">isUnsignedIntSetCC</a> (<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> Code)</td></tr>
<tr class="memdesc:adb237925346ec53b00d3c82a42311318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a setcc instruction that performs an unsigned comparison when used with integer operands.  <br /></td></tr>
<tr class="separator:adb237925346ec53b00d3c82a42311318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda64d97fb7fe554744b7a68c304c224" id="r_afda64d97fb7fe554744b7a68c304c224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afda64d97fb7fe554744b7a68c304c224">isIntEqualitySetCC</a> (<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> Code)</td></tr>
<tr class="memdesc:afda64d97fb7fe554744b7a68c304c224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a setcc instruction that performs an equality comparison when used with integer operands.  <br /></td></tr>
<tr class="separator:afda64d97fb7fe554744b7a68c304c224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47810790d5bd808946ba55b160e513e7" id="r_a47810790d5bd808946ba55b160e513e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47810790d5bd808946ba55b160e513e7">isFPEqualitySetCC</a> (<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> Code)</td></tr>
<tr class="memdesc:a47810790d5bd808946ba55b160e513e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a setcc instruction that performs an equality comparison when used with floating point operands.  <br /></td></tr>
<tr class="separator:a47810790d5bd808946ba55b160e513e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaea873272c138c801dae8542b1be46" id="r_a6eaea873272c138c801dae8542b1be46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eaea873272c138c801dae8542b1be46">isTrueWhenEqual</a> (<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> <a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>)</td></tr>
<tr class="memdesc:a6eaea873272c138c801dae8542b1be46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified condition returns true if the two operands to the condition are equal.  <br /></td></tr>
<tr class="separator:a6eaea873272c138c801dae8542b1be46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfab76369f71a9f62a02815c5aa0777" id="r_a7cfab76369f71a9f62a02815c5aa0777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cfab76369f71a9f62a02815c5aa0777">getUnorderedFlavor</a> (<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> <a class="el" href="RISCVRedundantCopyElimination_8cpp.html#a193847098793cdbab306803186676899">Cond</a>)</td></tr>
<tr class="memdesc:a7cfab76369f71a9f62a02815c5aa0777"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns 0 if the condition is always false if an operand is a NaN, 1 if the condition is always true if the operand is a NaN, and 2 if the condition is undefined if the operand is a NaN.  <br /></td></tr>
<tr class="separator:a7cfab76369f71a9f62a02815c5aa0777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbc38db5c4f3ef878ab19245d3f381d" id="r_a5fbc38db5c4f3ef878ab19245d3f381d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fbc38db5c4f3ef878ab19245d3f381d">getSetCCInverse</a> (<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> <a class="el" href="PPCReduceCRLogicals_8cpp.html#a5b2aa9d3f9f3a7b2d123fef7c5328b8f">Operation</a>, <a class="el" href="structllvm_1_1EVT.html">EVT</a> <a class="el" href="classllvm_1_1Type.html">Type</a>)</td></tr>
<tr class="memdesc:a5fbc38db5c4f3ef878ab19245d3f381d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the operation corresponding to !(X op Y), where 'op' is a valid SetCC operation.  <br /></td></tr>
<tr class="separator:a5fbc38db5c4f3ef878ab19245d3f381d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a72af46491472b765d836f2b5b62592" id="r_a4a72af46491472b765d836f2b5b62592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a72af46491472b765d836f2b5b62592">isExtOpcode</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode)</td></tr>
<tr class="separator:a4a72af46491472b765d836f2b5b62592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256306086883f189bdc13ed15c2f7800" id="r_a256306086883f189bdc13ed15c2f7800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a256306086883f189bdc13ed15c2f7800">isExtVecInRegOpcode</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode)</td></tr>
<tr class="separator:a256306086883f189bdc13ed15c2f7800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc23aed232ccdeadbd8648c349236a6" id="r_a9cc23aed232ccdeadbd8648c349236a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cc23aed232ccdeadbd8648c349236a6">getSetCCSwappedOperands</a> (<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> <a class="el" href="PPCReduceCRLogicals_8cpp.html#a5b2aa9d3f9f3a7b2d123fef7c5328b8f">Operation</a>)</td></tr>
<tr class="memdesc:a9cc23aed232ccdeadbd8648c349236a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the operation corresponding to (Y op X) when given the operation for (X op Y).  <br /></td></tr>
<tr class="separator:a9cc23aed232ccdeadbd8648c349236a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bf9aaeb72d421a1ef57a1a1e6fac92" id="r_af1bf9aaeb72d421a1ef57a1a1e6fac92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1bf9aaeb72d421a1ef57a1a1e6fac92">getSetCCOrOperation</a> (<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> Op1, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> Op2, <a class="el" href="structllvm_1_1EVT.html">EVT</a> <a class="el" href="classllvm_1_1Type.html">Type</a>)</td></tr>
<tr class="memdesc:af1bf9aaeb72d421a1ef57a1a1e6fac92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of a logical OR between different comparisons of identical values: ((X op1 Y) | (X op2 Y)).  <br /></td></tr>
<tr class="separator:af1bf9aaeb72d421a1ef57a1a1e6fac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06081b690c5f0c0be1e6c520585c2b5c" id="r_a06081b690c5f0c0be1e6c520585c2b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06081b690c5f0c0be1e6c520585c2b5c">getSetCCAndOperation</a> (<a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> Op1, <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a> Op2, <a class="el" href="structllvm_1_1EVT.html">EVT</a> <a class="el" href="classllvm_1_1Type.html">Type</a>)</td></tr>
<tr class="memdesc:a06081b690c5f0c0be1e6c520585c2b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of a logical AND between different comparisons of identical values: ((X op1 Y) &amp; (X op2 Y)).  <br /></td></tr>
<tr class="separator:a06081b690c5f0c0be1e6c520585c2b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb64237a88493be2c913b0a51630a0f" id="r_aafb64237a88493be2c913b0a51630a0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafb64237a88493be2c913b0a51630a0f">isConstantSplatVector</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;SplatValue)</td></tr>
<tr class="memdesc:aafb64237a88493be2c913b0a51630a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classNode.html">Node</a> predicates.  <br /></td></tr>
<tr class="separator:aafb64237a88493be2c913b0a51630a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b1839785665aed1d6e91dd72764713" id="r_a08b1839785665aed1d6e91dd72764713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08b1839785665aed1d6e91dd72764713">isConstantSplatVectorAllOnes</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classbool.html">bool</a> BuildVectorOnly=false)</td></tr>
<tr class="memdesc:a08b1839785665aed1d6e91dd72764713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified node is a BUILD_VECTOR or SPLAT_VECTOR where all of the elements are ~0 or undef.  <br /></td></tr>
<tr class="separator:a08b1839785665aed1d6e91dd72764713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531723c97a9c44056fc4996bde57229e" id="r_a531723c97a9c44056fc4996bde57229e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a531723c97a9c44056fc4996bde57229e">isConstantSplatVectorAllZeros</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classbool.html">bool</a> BuildVectorOnly=false)</td></tr>
<tr class="memdesc:a531723c97a9c44056fc4996bde57229e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified node is a BUILD_VECTOR or SPLAT_VECTOR where all of the elements are 0 or undef.  <br /></td></tr>
<tr class="separator:a531723c97a9c44056fc4996bde57229e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78d4df51ca05e4fb1630a01e07de434" id="r_ac78d4df51ca05e4fb1630a01e07de434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac78d4df51ca05e4fb1630a01e07de434">isBuildVectorAllOnes</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:ac78d4df51ca05e4fb1630a01e07de434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified node is a BUILD_VECTOR where all of the elements are ~0 or undef.  <br /></td></tr>
<tr class="separator:ac78d4df51ca05e4fb1630a01e07de434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac3e239cbdfe15a8e9bad4f8e1e3a95" id="r_aaac3e239cbdfe15a8e9bad4f8e1e3a95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaac3e239cbdfe15a8e9bad4f8e1e3a95">isBuildVectorAllZeros</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:aaac3e239cbdfe15a8e9bad4f8e1e3a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified node is a BUILD_VECTOR where all of the elements are 0 or undef.  <br /></td></tr>
<tr class="separator:aaac3e239cbdfe15a8e9bad4f8e1e3a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f37af786c5ba90887c1b4ec137a066c" id="r_a2f37af786c5ba90887c1b4ec137a066c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f37af786c5ba90887c1b4ec137a066c">isBuildVectorOfConstantSDNodes</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:a2f37af786c5ba90887c1b4ec137a066c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified node is a BUILD_VECTOR node of all <a class="el" href="classllvm_1_1ConstantSDNode.html">ConstantSDNode</a> or undef.  <br /></td></tr>
<tr class="separator:a2f37af786c5ba90887c1b4ec137a066c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3a86e6cdc4fe3dbd4e618c2f7a64c2" id="r_abf3a86e6cdc4fe3dbd4e618c2f7a64c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf3a86e6cdc4fe3dbd4e618c2f7a64c2">isBuildVectorOfConstantFPSDNodes</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:abf3a86e6cdc4fe3dbd4e618c2f7a64c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified node is a BUILD_VECTOR node of all <a class="el" href="classllvm_1_1ConstantFPSDNode.html">ConstantFPSDNode</a> or undef.  <br /></td></tr>
<tr class="separator:abf3a86e6cdc4fe3dbd4e618c2f7a64c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570c0c51d118ee761eb55fc0d2d910f4" id="r_a570c0c51d118ee761eb55fc0d2d910f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a570c0c51d118ee761eb55fc0d2d910f4">isVectorShrinkable</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classunsigned.html">unsigned</a> NewEltSize, <a class="el" href="classbool.html">bool</a> <a class="el" href="NVPTXISelLowering_8cpp.html#ae1a90b5d85643644483b2ca70da4d13faed3fa7a5efe80dad3ea3d86cc14be246">Signed</a>)</td></tr>
<tr class="memdesc:a570c0c51d118ee761eb55fc0d2d910f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified node is a vector where all elements can be truncated to the specified element size without a loss in meaning.  <br /></td></tr>
<tr class="separator:a570c0c51d118ee761eb55fc0d2d910f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933d79e63e855d7c90bf161355c008ec" id="r_a933d79e63e855d7c90bf161355c008ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a933d79e63e855d7c90bf161355c008ec">allOperandsUndef</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:a933d79e63e855d7c90bf161355c008ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the node has at least one operand and all operands of the specified node are <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7c6d8f265e9e16e5debdb9a536b55d3d" title="UNDEF - An undefined node.">ISD::UNDEF</a>.  <br /></td></tr>
<tr class="separator:a933d79e63e855d7c90bf161355c008ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938294d45605337641e10c207def0988" id="r_a938294d45605337641e10c207def0988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a938294d45605337641e10c207def0988">isFreezeUndef</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:a938294d45605337641e10c207def0988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified node is <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad3b50b6d74957b19afb85ac29f66afef">FREEZE(UNDEF)</a>.  <br /></td></tr>
<tr class="separator:a938294d45605337641e10c207def0988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaaeadcd82b42fc0d385a6247bf7bb52" id="r_afaaeadcd82b42fc0d385a6247bf7bb52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaaeadcd82b42fc0d385a6247bf7bb52">isNormalLoad</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:afaaeadcd82b42fc0d385a6247bf7bb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified node is a non-extending and unindexed load.  <br /></td></tr>
<tr class="separator:afaaeadcd82b42fc0d385a6247bf7bb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15623094a1ed0cd7163dc786e44c87c9" id="r_a15623094a1ed0cd7163dc786e44c87c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15623094a1ed0cd7163dc786e44c87c9">isNON_EXTLoad</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:a15623094a1ed0cd7163dc786e44c87c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified node is a non-extending load.  <br /></td></tr>
<tr class="separator:a15623094a1ed0cd7163dc786e44c87c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910795e8d77c1545da0683c0e1cb81ee" id="r_a910795e8d77c1545da0683c0e1cb81ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a910795e8d77c1545da0683c0e1cb81ee">isEXTLoad</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:a910795e8d77c1545da0683c0e1cb81ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified node is a EXTLOAD.  <br /></td></tr>
<tr class="separator:a910795e8d77c1545da0683c0e1cb81ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac174dc465cbe0e04a0f5e41c0a422124" id="r_ac174dc465cbe0e04a0f5e41c0a422124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac174dc465cbe0e04a0f5e41c0a422124">isSEXTLoad</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:ac174dc465cbe0e04a0f5e41c0a422124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified node is a SEXTLOAD.  <br /></td></tr>
<tr class="separator:ac174dc465cbe0e04a0f5e41c0a422124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35edacef22fcaed7a8681fa573476131" id="r_a35edacef22fcaed7a8681fa573476131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35edacef22fcaed7a8681fa573476131">isZEXTLoad</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:a35edacef22fcaed7a8681fa573476131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified node is a ZEXTLOAD.  <br /></td></tr>
<tr class="separator:a35edacef22fcaed7a8681fa573476131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da84980dd2ee06405d74303cfb90485" id="r_a7da84980dd2ee06405d74303cfb90485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7da84980dd2ee06405d74303cfb90485">isUNINDEXEDLoad</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:a7da84980dd2ee06405d74303cfb90485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified node is an unindexed load.  <br /></td></tr>
<tr class="separator:a7da84980dd2ee06405d74303cfb90485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308088c2d65f8f3955f5fb0f6aca7ccc" id="r_a308088c2d65f8f3955f5fb0f6aca7ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a308088c2d65f8f3955f5fb0f6aca7ccc">isNormalStore</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:a308088c2d65f8f3955f5fb0f6aca7ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified node is a non-truncating and unindexed store.  <br /></td></tr>
<tr class="separator:a308088c2d65f8f3955f5fb0f6aca7ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c74add1b228292dae9d97d63b6f27b" id="r_ab5c74add1b228292dae9d97d63b6f27b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5c74add1b228292dae9d97d63b6f27b">isUNINDEXEDStore</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:ab5c74add1b228292dae9d97d63b6f27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified node is an unindexed store.  <br /></td></tr>
<tr class="separator:ab5c74add1b228292dae9d97d63b6f27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bffdefad1ad0a43b40eaa2a2cded351" id="r_a5bffdefad1ad0a43b40eaa2a2cded351"><td class="memTemplParams" colspan="2">template&lt;typename ConstNodeType &gt; </td></tr>
<tr class="memitem:a5bffdefad1ad0a43b40eaa2a2cded351"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5bffdefad1ad0a43b40eaa2a2cded351">matchUnaryPredicateImpl</a> (<a class="el" href="classllvm_1_1SDValue.html">SDValue</a> <a class="el" href="namespacellvm.html#ab471937b9a227e70c7fe8bd9604014d6">Op</a>, std::function&lt; <a class="el" href="classbool.html">bool</a>(ConstNodeType *)&gt; <a class="el" href="namespacellvm.html#a313a633eb3049b90e931206183e1251ea6da89265a9a8b0b28eb4946bb2ec0c6d">Match</a>, <a class="el" href="classbool.html">bool</a> AllowUndefs=false)</td></tr>
<tr class="memdesc:a5bffdefad1ad0a43b40eaa2a2cded351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to match a unary predicate against a scalar/splat constant or every element of a constant BUILD_VECTOR.  <br /></td></tr>
<tr class="separator:a5bffdefad1ad0a43b40eaa2a2cded351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309c11edf22da984f95cf9ba7a699c11" id="r_a309c11edf22da984f95cf9ba7a699c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a309c11edf22da984f95cf9ba7a699c11">matchUnaryPredicate</a> (<a class="el" href="classllvm_1_1SDValue.html">SDValue</a> <a class="el" href="namespacellvm.html#ab471937b9a227e70c7fe8bd9604014d6">Op</a>, std::function&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1ConstantSDNode.html">ConstantSDNode</a> *)&gt; <a class="el" href="namespacellvm.html#a313a633eb3049b90e931206183e1251ea6da89265a9a8b0b28eb4946bb2ec0c6d">Match</a>, <a class="el" href="classbool.html">bool</a> AllowUndefs=false)</td></tr>
<tr class="memdesc:a309c11edf22da984f95cf9ba7a699c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook for matching <a class="el" href="classllvm_1_1ConstantSDNode.html">ConstantSDNode</a> predicate.  <br /></td></tr>
<tr class="separator:a309c11edf22da984f95cf9ba7a699c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425d6f0e5036ca26fdd80efcaae21589" id="r_a425d6f0e5036ca26fdd80efcaae21589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a425d6f0e5036ca26fdd80efcaae21589">matchUnaryFpPredicate</a> (<a class="el" href="classllvm_1_1SDValue.html">SDValue</a> <a class="el" href="namespacellvm.html#ab471937b9a227e70c7fe8bd9604014d6">Op</a>, std::function&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1ConstantFPSDNode.html">ConstantFPSDNode</a> *)&gt; <a class="el" href="namespacellvm.html#a313a633eb3049b90e931206183e1251ea6da89265a9a8b0b28eb4946bb2ec0c6d">Match</a>, <a class="el" href="classbool.html">bool</a> AllowUndefs=false)</td></tr>
<tr class="memdesc:a425d6f0e5036ca26fdd80efcaae21589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook for matching <a class="el" href="classllvm_1_1ConstantFPSDNode.html">ConstantFPSDNode</a> predicate.  <br /></td></tr>
<tr class="separator:a425d6f0e5036ca26fdd80efcaae21589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab283a383171c46fb4445cb64eb6b687a" id="r_ab283a383171c46fb4445cb64eb6b687a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab283a383171c46fb4445cb64eb6b687a">matchBinaryPredicate</a> (<a class="el" href="classllvm_1_1SDValue.html">SDValue</a> <a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1SDValue.html">SDValue</a> <a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, std::function&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1ConstantSDNode.html">ConstantSDNode</a> *, <a class="el" href="classllvm_1_1ConstantSDNode.html">ConstantSDNode</a> *)&gt; <a class="el" href="namespacellvm.html#a313a633eb3049b90e931206183e1251ea6da89265a9a8b0b28eb4946bb2ec0c6d">Match</a>, <a class="el" href="classbool.html">bool</a> AllowUndefs=false, <a class="el" href="classbool.html">bool</a> AllowTypeMismatch=false)</td></tr>
<tr class="memdesc:ab283a383171c46fb4445cb64eb6b687a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to match a binary predicate against a pair of scalar/splat constants or every element of a pair of constant BUILD_VECTORs.  <br /></td></tr>
<tr class="separator:ab283a383171c46fb4445cb64eb6b687a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d58a0ced655af200989177b8e029f2d" id="r_a2d58a0ced655af200989177b8e029f2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d58a0ced655af200989177b8e029f2d">isOverflowIntrOpRes</a> (<a class="el" href="classllvm_1_1SDValue.html">SDValue</a> <a class="el" href="namespacellvm.html#ab471937b9a227e70c7fe8bd9604014d6">Op</a>)</td></tr>
<tr class="memdesc:a2d58a0ced655af200989177b8e029f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified value is the overflow result from one of the overflow intrinsic nodes.  <br /></td></tr>
<tr class="separator:a2d58a0ced655af200989177b8e029f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac12e5034984d1e706d2a8b89dc3e9394" id="r_ac12e5034984d1e706d2a8b89dc3e9394"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac12e5034984d1e706d2a8b89dc3e9394">FIRST_TARGET_STRICTFP_OPCODE</a> = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a477ef80c70c7359199eace0e5d3133b1">BUILTIN_OP_END</a> + 400</td></tr>
<tr class="memdesc:ac12e5034984d1e706d2a8b89dc3e9394"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIRST_TARGET_STRICTFP_OPCODE - Target-specific pre-isel operations which cannot raise FP exceptions should be less than this value.  <br /></td></tr>
<tr class="separator:ac12e5034984d1e706d2a8b89dc3e9394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b8a748b427bf9338f626f438cf91c" id="r_a492b8a748b427bf9338f626f438cf91c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a492b8a748b427bf9338f626f438cf91c">FIRST_TARGET_MEMORY_OPCODE</a> = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a477ef80c70c7359199eace0e5d3133b1">BUILTIN_OP_END</a> + 500</td></tr>
<tr class="memdesc:a492b8a748b427bf9338f626f438cf91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIRST_TARGET_MEMORY_OPCODE - Target-specific pre-isel operations which do not reference a specific memory location should be less than this value.  <br /></td></tr>
<tr class="separator:a492b8a748b427bf9338f626f438cf91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0010333b4e1424ce473b508d802bbbd" id="r_ae0010333b4e1424ce473b508d802bbbd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0010333b4e1424ce473b508d802bbbd">LAST_INDEXED_MODE</a> = <a class="el" href="#abee7ecb577fcade34eb16ccb7f503e31a10a4094c81c0b9cd5e82e53b48932203">POST_DEC</a> + 1</td></tr>
<tr class="separator:ae0010333b4e1424ce473b508d802bbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769bfb423d42986a688a04035ce40cf7" id="r_a769bfb423d42986a688a04035ce40cf7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a769bfb423d42986a688a04035ce40cf7">LAST_MEM_INDEX_TYPE</a> = <a class="el" href="#aa30bf48cd2a89f80c9c608adcabc53e3af3218635b665db9e7e1d97e015f14e3a">UNSIGNED_SCALED</a> + 1</td></tr>
<tr class="separator:a769bfb423d42986a688a04035ce40cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53490a5ced1d50808fe962a298c315cd" id="r_a53490a5ced1d50808fe962a298c315cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53490a5ced1d50808fe962a298c315cd">LAST_LOADEXT_TYPE</a> = <a class="el" href="#ad4d48171b87ca51ff54c10a436bac4d7a8d89c7da4444d9ec11667aa369abc5f7">ZEXTLOAD</a> + 1</td></tr>
<tr class="separator:a53490a5ced1d50808fe962a298c315cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespacellvm_1_1ISD.html" title="ISD namespace - This namespace contains an enum which represents all of the SelectionDAG node types a...">ISD</a> namespace - This namespace contains an enum which represents all of the <a class="el" href="classllvm_1_1SelectionDAG.html" title="This is used to represent a portion of an LLVM function in a low-level Data Dependence DAG representa...">SelectionDAG</a> node types and value types. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac3c3cf58d6d631af6a172457304d3d07" name="ac3c3cf58d6d631af6a172457304d3d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c3cf58d6d631af6a172457304d3d07">&#9670;&#160;</a></span>CondCode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">llvm::ISD::CondCode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07" title="ISD::CondCode enum - These are ordered carefully to make the bitfields below work out,...">ISD::CondCode</a> enum - These are ordered carefully to make the bitfields below work out, when considering SETFALSE (something that never exists dynamically) as 0. </p>
<p>"U" -&gt; Unsigned (for integer operands) or Unordered (for floating point), "L" -&gt; Less than, "G" -&gt; Greater than, "E" -&gt; Equal to. If the "N" column is 1, the result of the comparison is undefined if the input is a NAN.</p>
<p>All of these (except for the 'always folded ops') should be handled for floating point. For integer, only the SETEQ,SETNE,SETLT,SETLE,SETGT, SETGE,SETULT,SETULE,SETUGT, and SETUGE opcodes are used.</p>
<p>Note that these are laid out in a specific order to allow bit-twiddling to transform conditions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07ae258b87332b47d96bdf47e4cd915f9ea" name="ac3c3cf58d6d631af6a172457304d3d07ae258b87332b47d96bdf47e4cd915f9ea"></a>SETFALSE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a08c31033acfb9d6f0bc4a8a82cc26862" name="ac3c3cf58d6d631af6a172457304d3d07a08c31033acfb9d6f0bc4a8a82cc26862"></a>SETOEQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a31d1e24e08b255d6aa290d67d16ce2c9" name="ac3c3cf58d6d631af6a172457304d3d07a31d1e24e08b255d6aa290d67d16ce2c9"></a>SETOGT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07ac7bb30d4918c1ee9dd208083154e109f" name="ac3c3cf58d6d631af6a172457304d3d07ac7bb30d4918c1ee9dd208083154e109f"></a>SETOGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a20257a4d3833cf88afd42caeaed70dde" name="ac3c3cf58d6d631af6a172457304d3d07a20257a4d3833cf88afd42caeaed70dde"></a>SETOLT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a1febf3bac2f3d7d98ec19f1ff5c385ea" name="ac3c3cf58d6d631af6a172457304d3d07a1febf3bac2f3d7d98ec19f1ff5c385ea"></a>SETOLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a57c68bf7ef20bd558854a24d5b0c1e72" name="ac3c3cf58d6d631af6a172457304d3d07a57c68bf7ef20bd558854a24d5b0c1e72"></a>SETONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a71f916390487bb109d9968c72553eaf4" name="ac3c3cf58d6d631af6a172457304d3d07a71f916390487bb109d9968c72553eaf4"></a>SETO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a48a334bbe606d5e82c9cd84eaa127b50" name="ac3c3cf58d6d631af6a172457304d3d07a48a334bbe606d5e82c9cd84eaa127b50"></a>SETUO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a0deb50cd2f3f8e4a94eef4cdf769b848" name="ac3c3cf58d6d631af6a172457304d3d07a0deb50cd2f3f8e4a94eef4cdf769b848"></a>SETUEQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a292be4a9782030bfad637581d25a5897" name="ac3c3cf58d6d631af6a172457304d3d07a292be4a9782030bfad637581d25a5897"></a>SETUGT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a9dff1dcbac65852b71473818c11869b1" name="ac3c3cf58d6d631af6a172457304d3d07a9dff1dcbac65852b71473818c11869b1"></a>SETUGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a473200f06bdd611fdbed43d908b84305" name="ac3c3cf58d6d631af6a172457304d3d07a473200f06bdd611fdbed43d908b84305"></a>SETULT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07ac538f0b432df970cbaaf6b81d777c6a7" name="ac3c3cf58d6d631af6a172457304d3d07ac538f0b432df970cbaaf6b81d777c6a7"></a>SETULE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a0d1546187d4d526fcbdd43183689075e" name="ac3c3cf58d6d631af6a172457304d3d07a0d1546187d4d526fcbdd43183689075e"></a>SETUNE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a8e273eab0623ea5713aa5bcbdac2b16b" name="ac3c3cf58d6d631af6a172457304d3d07a8e273eab0623ea5713aa5bcbdac2b16b"></a>SETTRUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a66792a566255872c951cb6b8f9cb0541" name="ac3c3cf58d6d631af6a172457304d3d07a66792a566255872c951cb6b8f9cb0541"></a>SETFALSE2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07ae2e6a5e32087b9f65bd51585a6a5afb4" name="ac3c3cf58d6d631af6a172457304d3d07ae2e6a5e32087b9f65bd51585a6a5afb4"></a>SETEQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a5ad12b466e3a5900d0c307b301465d25" name="ac3c3cf58d6d631af6a172457304d3d07a5ad12b466e3a5900d0c307b301465d25"></a>SETGT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a7f47862de23f7210f88ccf98ae1efbe4" name="ac3c3cf58d6d631af6a172457304d3d07a7f47862de23f7210f88ccf98ae1efbe4"></a>SETGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a6f05a09edb671910f85f8665981cbde9" name="ac3c3cf58d6d631af6a172457304d3d07a6f05a09edb671910f85f8665981cbde9"></a>SETLT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07ab49f81c2ecbbff3d0fbe55dd46353774" name="ac3c3cf58d6d631af6a172457304d3d07ab49f81c2ecbbff3d0fbe55dd46353774"></a>SETLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a2887cc8b39915a25180f4bca0026a15e" name="ac3c3cf58d6d631af6a172457304d3d07a2887cc8b39915a25180f4bca0026a15e"></a>SETNE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07a1a575d029fd38d929229ac39e573e8fc" name="ac3c3cf58d6d631af6a172457304d3d07a1a575d029fd38d929229ac39e573e8fc"></a>SETTRUE2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac3c3cf58d6d631af6a172457304d3d07aeded54fe1be320194e9ff0f5825df0e5" name="ac3c3cf58d6d631af6a172457304d3d07aeded54fe1be320194e9ff0f5825df0e5"></a>SETCC_INVALID&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01574">1574</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

</div>
</div>
<a id="ad4d48171b87ca51ff54c10a436bac4d7" name="ad4d48171b87ca51ff54c10a436bac4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d48171b87ca51ff54c10a436bac4d7">&#9670;&#160;</a></span>LoadExtType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad4d48171b87ca51ff54c10a436bac4d7">llvm::ISD::LoadExtType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LoadExtType enum - This enum defines the three variants of LOADEXT (load with extension). </p>
<p>SEXTLOAD loads the integer operand and sign extends it to a larger integer result type. ZEXTLOAD loads the integer operand and zero extends it to a larger integer result type. EXTLOAD is used for two things: floating point extending loads and integer extending loads [the top bits are undefined]. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad4d48171b87ca51ff54c10a436bac4d7a6aacde2c67988b43a261a7f7ceac4be3" name="ad4d48171b87ca51ff54c10a436bac4d7a6aacde2c67988b43a261a7f7ceac4be3"></a>NON_EXTLOAD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4d48171b87ca51ff54c10a436bac4d7afab3fffd153f7d7770fed81272e4b78f" name="ad4d48171b87ca51ff54c10a436bac4d7afab3fffd153f7d7770fed81272e4b78f"></a>EXTLOAD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4d48171b87ca51ff54c10a436bac4d7a6c61b6125c7901c549f90ee0e443a770" name="ad4d48171b87ca51ff54c10a436bac4d7a6c61b6125c7901c549f90ee0e443a770"></a>SEXTLOAD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4d48171b87ca51ff54c10a436bac4d7a8d89c7da4444d9ec11667aa369abc5f7" name="ad4d48171b87ca51ff54c10a436bac4d7a8d89c7da4444d9ec11667aa369abc5f7"></a>ZEXTLOAD&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01554">1554</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

</div>
</div>
<a id="abee7ecb577fcade34eb16ccb7f503e31" name="abee7ecb577fcade34eb16ccb7f503e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee7ecb577fcade34eb16ccb7f503e31">&#9670;&#160;</a></span>MemIndexedMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#abee7ecb577fcade34eb16ccb7f503e31">llvm::ISD::MemIndexedMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MemIndexedMode enum - This enum defines the load / store indexed addressing modes. </p>
<p>UNINDEXED "Normal" load / store. The effective address is already computed and is available in the base pointer. The offset operand is always undefined. In addition to producing a chain, an unindexed load produces one value (result of the load); an unindexed store does not produce a value.</p>
<p>PRE_INC Similar to the unindexed mode where the effective address is PRE_DEC the value of the base pointer add / subtract the offset. It considers the computation as being folded into the load / store operation (i.e. the load / store does the address computation as well as performing the memory transaction). The base operand is always undefined. In addition to producing a chain, pre-indexed load produces two values (result of the load and the result of the address computation); a pre-indexed store produces one value (result of the address computation).</p>
<p>POST_INC The effective address is the value of the base pointer. The POST_DEC value of the offset operand is then added to / subtracted from the base after memory transaction. In addition to producing a chain, post-indexed load produces two values (the result of the load and the result of the base +/- offset computation); a post-indexed store produces one value (the the result of the base +/- offset computation). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abee7ecb577fcade34eb16ccb7f503e31ade1c53e7b8a373e22ec53ff7bcbace9f" name="abee7ecb577fcade34eb16ccb7f503e31ade1c53e7b8a373e22ec53ff7bcbace9f"></a>UNINDEXED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abee7ecb577fcade34eb16ccb7f503e31ab5bb854fadd42503c849c4a48d7f3d90" name="abee7ecb577fcade34eb16ccb7f503e31ab5bb854fadd42503c849c4a48d7f3d90"></a>PRE_INC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abee7ecb577fcade34eb16ccb7f503e31a57c3822f99653c422d5a21206adc6e42" name="abee7ecb577fcade34eb16ccb7f503e31a57c3822f99653c422d5a21206adc6e42"></a>PRE_DEC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abee7ecb577fcade34eb16ccb7f503e31a866c29237765ff291c9503abbdca60e1" name="abee7ecb577fcade34eb16ccb7f503e31a866c29237765ff291c9503abbdca60e1"></a>POST_INC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abee7ecb577fcade34eb16ccb7f503e31a10a4094c81c0b9cd5e82e53b48932203" name="abee7ecb577fcade34eb16ccb7f503e31a10a4094c81c0b9cd5e82e53b48932203"></a>POST_DEC&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01523">1523</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

</div>
</div>
<a id="aa30bf48cd2a89f80c9c608adcabc53e3" name="aa30bf48cd2a89f80c9c608adcabc53e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30bf48cd2a89f80c9c608adcabc53e3">&#9670;&#160;</a></span>MemIndexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aa30bf48cd2a89f80c9c608adcabc53e3">llvm::ISD::MemIndexType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MemIndexType enum - This enum defines how to interpret MGATHER/SCATTER's index parameter when calculating addresses. </p>
<p>SIGNED_SCALED Addr = Base + ((signed)Index * Scale) UNSIGNED_SCALED Addr = Base + ((unsigned)Index * Scale)</p>
<p>NOTE: The value of Scale is typically only known to the node owning the IndexType, with a value of 1 the equivalent of being unscaled. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa30bf48cd2a89f80c9c608adcabc53e3a0173acb50fe8c4337c23a98baab3f4db" name="aa30bf48cd2a89f80c9c608adcabc53e3a0173acb50fe8c4337c23a98baab3f4db"></a>SIGNED_SCALED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa30bf48cd2a89f80c9c608adcabc53e3af3218635b665db9e7e1d97e015f14e3a" name="aa30bf48cd2a89f80c9c608adcabc53e3af3218635b665db9e7e1d97e015f14e3a"></a>UNSIGNED_SCALED&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01536">1536</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

</div>
</div>
<a id="a22ea9cec080dd5f4f47ba234c2f59110" name="a22ea9cec080dd5f4f47ba234c2f59110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ea9cec080dd5f4f47ba234c2f59110">&#9670;&#160;</a></span>NodeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110">llvm::ISD::NodeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110" title="ISD::NodeType enum - This enum defines the target-independent operators for a SelectionDAG.">ISD::NodeType</a> enum - This enum defines the target-independent operators for a <a class="el" href="classllvm_1_1SelectionDAG.html" title="This is used to represent a portion of an LLVM function in a low-level Data Dependence DAG representa...">SelectionDAG</a>. </p>
<p>Targets may also define target-dependent operator codes for SDNodes. For example, on x86, these are the enum values in the <a class="el" href="namespacellvm_1_1X86ISD.html">X86ISD</a> namespace. Targets should aim to use target-independent operators to model their instruction sets as much as possible, and only use target-dependent operators when they have special requirements.</p>
<p>Finally, during and after selection proper, SNodes may use special operator codes that correspond directly with <a class="el" href="classllvm_1_1MachineInstr.html" title="Representation of each machine instruction.">MachineInstr</a> opcodes. These are used to represent selected instructions. See the isMachineOpcode() and getMachineOpcode() member functions of <a class="el" href="classllvm_1_1SDNode.html" title="Represents one node in the SelectionDAG.">SDNode</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a062083eb3ff8c441c73d3bf42ca09bba" name="a22ea9cec080dd5f4f47ba234c2f59110a062083eb3ff8c441c73d3bf42ca09bba"></a>DELETED_NODE&#160;</td><td class="fielddoc"><p>DELETED_NODE - This is an illegal value that is used to catch errors. </p>
<p>This opcode is not a legal opcode for any node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a926013f6dca240eca95aca66c8d3e74b" name="a22ea9cec080dd5f4f47ba234c2f59110a926013f6dca240eca95aca66c8d3e74b"></a>EntryToken&#160;</td><td class="fielddoc"><p>EntryToken - This is the marker used to indicate the start of a region. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad469508535ce2082a1ab1f0e429187b8" name="a22ea9cec080dd5f4f47ba234c2f59110ad469508535ce2082a1ab1f0e429187b8"></a>TokenFactor&#160;</td><td class="fielddoc"><p>TokenFactor - This node takes multiple tokens as input and produces a single token result. </p>
<p>This is used to represent the fact that the operand operators are independent of each other. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aee4f13218bdbb5c5697f7e786618ecb2" name="a22ea9cec080dd5f4f47ba234c2f59110aee4f13218bdbb5c5697f7e786618ecb2"></a>AssertSext&#160;</td><td class="fielddoc"><p>AssertSext, AssertZext - These nodes record if a register contains a value that has already been zero or sign extended from a narrower type. </p>
<p>These nodes take two operands. The first is the node that has already been extended, and the second is a value type node indicating the width of the extension. NOTE: In case of the source value (or any vector element value) is poisoned the assertion will not be true for that value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110af23301e60475124fd80a2cb51f6ba863" name="a22ea9cec080dd5f4f47ba234c2f59110af23301e60475124fd80a2cb51f6ba863"></a>AssertZext&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a8005dc9efe12e770682b4b5200dad30b" name="a22ea9cec080dd5f4f47ba234c2f59110a8005dc9efe12e770682b4b5200dad30b"></a>AssertAlign&#160;</td><td class="fielddoc"><p>AssertAlign - These nodes record if a register contains a value that has a known alignment and the trailing bits are known to be zero. </p>
<p>NOTE: In case of the source value (or any vector element value) is poisoned the assertion will not be true for that value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a8472e46f9e4db168c5610ecdfb05dbaf" name="a22ea9cec080dd5f4f47ba234c2f59110a8472e46f9e4db168c5610ecdfb05dbaf"></a>BasicBlock&#160;</td><td class="fielddoc"><p>Various leaf nodes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a40d4f41a75df8e16bc5dbe62d62465b8" name="a22ea9cec080dd5f4f47ba234c2f59110a40d4f41a75df8e16bc5dbe62d62465b8"></a>VALUETYPE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aa366e6b1653ab1cedbeeaef9afecedd7" name="a22ea9cec080dd5f4f47ba234c2f59110aa366e6b1653ab1cedbeeaef9afecedd7"></a>CONDCODE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a419e8283a58d2b1b86591fa7f18ccfd9" name="a22ea9cec080dd5f4f47ba234c2f59110a419e8283a58d2b1b86591fa7f18ccfd9"></a>Register&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a7e54881d7b0838c37485e4c79d215d07" name="a22ea9cec080dd5f4f47ba234c2f59110a7e54881d7b0838c37485e4c79d215d07"></a>RegisterMask&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aac2f0a84dd2aa5ee4c3f1385e9565f5e" name="a22ea9cec080dd5f4f47ba234c2f59110aac2f0a84dd2aa5ee4c3f1385e9565f5e"></a>Constant&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a1be4c8da7c68a4c683de1a98b5cc5b9d" name="a22ea9cec080dd5f4f47ba234c2f59110a1be4c8da7c68a4c683de1a98b5cc5b9d"></a>ConstantFP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a30316f8f9985260c49d7c26bc70a6cad" name="a22ea9cec080dd5f4f47ba234c2f59110a30316f8f9985260c49d7c26bc70a6cad"></a>GlobalAddress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a49f1172c7014cc4fa3570792e6834e2c" name="a22ea9cec080dd5f4f47ba234c2f59110a49f1172c7014cc4fa3570792e6834e2c"></a>GlobalTLSAddress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a4b437632fd9b97dd36010d85eb363efe" name="a22ea9cec080dd5f4f47ba234c2f59110a4b437632fd9b97dd36010d85eb363efe"></a>FrameIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a0c70100db6ddc0b37b56feb242145cf4" name="a22ea9cec080dd5f4f47ba234c2f59110a0c70100db6ddc0b37b56feb242145cf4"></a>JumpTable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aa8cad208c3cb96b33b5d8544590325b1" name="a22ea9cec080dd5f4f47ba234c2f59110aa8cad208c3cb96b33b5d8544590325b1"></a>ConstantPool&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad88f843bce966361c7fd2cd022e6528a" name="a22ea9cec080dd5f4f47ba234c2f59110ad88f843bce966361c7fd2cd022e6528a"></a>ExternalSymbol&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ae98378a8672947382d343d75a5df3003" name="a22ea9cec080dd5f4f47ba234c2f59110ae98378a8672947382d343d75a5df3003"></a>BlockAddress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a8df1b84ea64ad5048f27873205c8ab89" name="a22ea9cec080dd5f4f47ba234c2f59110a8df1b84ea64ad5048f27873205c8ab89"></a>PtrAuthGlobalAddress&#160;</td><td class="fielddoc"><p>A ptrauth constant. </p>
<p>ptr, key, addr-disc, disc Note that the addr-disc can be a non-constant value, to allow representing a constant global address signed using address-diversification, in code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aaef4ead62e1835b863820f6c818c36ac" name="a22ea9cec080dd5f4f47ba234c2f59110aaef4ead62e1835b863820f6c818c36ac"></a>GLOBAL_OFFSET_TABLE&#160;</td><td class="fielddoc"><p>The address of the GOT. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110abdb38c8daa8c1ab881007062d113cef3" name="a22ea9cec080dd5f4f47ba234c2f59110abdb38c8daa8c1ab881007062d113cef3"></a>FRAMEADDR&#160;</td><td class="fielddoc"><p>FRAMEADDR, RETURNADDR - These nodes represent llvm.frameaddress and llvm.returnaddress on the DAG. </p>
<p>These nodes take one operand, the index of the frame or return address to return. An index of zero corresponds to the current function's frame or return address, an index of one to the parent's frame or return address, and so on. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a2dfacb29792dd59f2cfbe529206265bc" name="a22ea9cec080dd5f4f47ba234c2f59110a2dfacb29792dd59f2cfbe529206265bc"></a>RETURNADDR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a591c03cc284124ff624856ce485ebc17" name="a22ea9cec080dd5f4f47ba234c2f59110a591c03cc284124ff624856ce485ebc17"></a>ADDROFRETURNADDR&#160;</td><td class="fielddoc"><p>ADDROFRETURNADDR - Represents the llvm.addressofreturnaddress intrinsic. </p>
<p>This node takes no operand, returns a target-specific pointer to the place in the stack frame where the return address of the current function is stored. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110add9a41fa65a9675200d73710a82b880e" name="a22ea9cec080dd5f4f47ba234c2f59110add9a41fa65a9675200d73710a82b880e"></a>SPONENTRY&#160;</td><td class="fielddoc"><p>SPONENTRY - Represents the llvm.sponentry intrinsic. </p>
<p>Takes no argument and returns the stack pointer value at the entry of the current function calling this intrinsic. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a9d483820471b07a73225bf33986fd110" name="a22ea9cec080dd5f4f47ba234c2f59110a9d483820471b07a73225bf33986fd110"></a>LOCAL_RECOVER&#160;</td><td class="fielddoc"><p>LOCAL_RECOVER - Represents the llvm.localrecover intrinsic. </p>
<p>Materializes the offset from the local object pointer of another function to a particular local object passed to llvm.localescape. The operand is the <a class="el" href="classllvm_1_1MCSymbol.html" title="MCSymbol - Instances of this class represent a symbol name in the MC file, and MCSymbols are created ...">MCSymbol</a> label used to represent this offset, since typically the offset is not known until after code generation of the parent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a92fceabd268d62ef2c95799a102b8abf" name="a22ea9cec080dd5f4f47ba234c2f59110a92fceabd268d62ef2c95799a102b8abf"></a>READ_REGISTER&#160;</td><td class="fielddoc"><p>READ_REGISTER, WRITE_REGISTER - This node represents llvm.register on the DAG, which implements the named register global variables extension. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a61a1595d03afe86764ad7625d358608e" name="a22ea9cec080dd5f4f47ba234c2f59110a61a1595d03afe86764ad7625d358608e"></a>WRITE_REGISTER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a228deacdfba1bd2d5a3663b19609f945" name="a22ea9cec080dd5f4f47ba234c2f59110a228deacdfba1bd2d5a3663b19609f945"></a>FRAME_TO_ARGS_OFFSET&#160;</td><td class="fielddoc"><p>FRAME_TO_ARGS_OFFSET - This node represents offset from frame pointer to first (possible) on-stack argument. </p>
<p>This is needed for correct stack adjustment during unwind. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110abad932e63381a4671b5db19a3404c82e" name="a22ea9cec080dd5f4f47ba234c2f59110abad932e63381a4671b5db19a3404c82e"></a>EH_DWARF_CFA&#160;</td><td class="fielddoc"><p>EH_DWARF_CFA - This node represents the pointer to the DWARF Canonical Frame Address (CFA), generally the value of the stack pointer at the call site in the previous frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a4edf35e2383003ff20057e5a45012a55" name="a22ea9cec080dd5f4f47ba234c2f59110a4edf35e2383003ff20057e5a45012a55"></a>EH_RETURN&#160;</td><td class="fielddoc"><p>OUTCHAIN = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a4edf35e2383003ff20057e5a45012a55" title="OUTCHAIN = EH_RETURN(INCHAIN, OFFSET, HANDLER) - This node represents &#39;eh_return&#39; gcc dwarf builtin,...">EH_RETURN(INCHAIN, OFFSET, HANDLER)</a> - This node represents 'eh_return' gcc dwarf builtin, which is used to return from exception. </p>
<p>The general meaning is: adjust stack by OFFSET and pass execution to HANDLER. Many platform-related details also :) </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ae5a57fe9fd413df909ab121ca1a813c7" name="a22ea9cec080dd5f4f47ba234c2f59110ae5a57fe9fd413df909ab121ca1a813c7"></a>EH_SJLJ_SETJMP&#160;</td><td class="fielddoc"><p>RESULT, OUTCHAIN = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ae5a57fe9fd413df909ab121ca1a813c7" title="RESULT, OUTCHAIN = EH_SJLJ_SETJMP(INCHAIN, buffer) This corresponds to the eh.sjlj....">EH_SJLJ_SETJMP(INCHAIN, buffer)</a> This corresponds to the eh.sjlj.setjmp intrinsic. </p>
<p>It takes an input chain and a pointer to the jump buffer as inputs and returns an outchain. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a122a450e069003dc86859ef47ab6e278" name="a22ea9cec080dd5f4f47ba234c2f59110a122a450e069003dc86859ef47ab6e278"></a>EH_SJLJ_LONGJMP&#160;</td><td class="fielddoc"><p>OUTCHAIN = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a122a450e069003dc86859ef47ab6e278" title="OUTCHAIN = EH_SJLJ_LONGJMP(INCHAIN, buffer) This corresponds to the eh.sjlj.longjmp intrinsic.">EH_SJLJ_LONGJMP(INCHAIN, buffer)</a> This corresponds to the eh.sjlj.longjmp intrinsic. </p>
<p>It takes an input chain and a pointer to the jump buffer as inputs and returns an outchain. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a2e0f3a93e85a46b2ebac7330c2a0c581" name="a22ea9cec080dd5f4f47ba234c2f59110a2e0f3a93e85a46b2ebac7330c2a0c581"></a>EH_SJLJ_SETUP_DISPATCH&#160;</td><td class="fielddoc"><p>OUTCHAIN = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a2e0f3a93e85a46b2ebac7330c2a0c581" title="OUTCHAIN = EH_SJLJ_SETUP_DISPATCH(INCHAIN) The target initializes the dispatch table here.">EH_SJLJ_SETUP_DISPATCH(INCHAIN)</a> The target initializes the dispatch table here. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ac479e53ca98903b1028ec80e12fb0af8" name="a22ea9cec080dd5f4f47ba234c2f59110ac479e53ca98903b1028ec80e12fb0af8"></a>TargetConstant&#160;</td><td class="fielddoc"><p>TargetConstant* - Like Constant*, but the DAG does not do any folding, simplification, or lowering of the constant. </p>
<p>They are used for constants which are known to fit in the immediate fields of their users, or for carrying magic numbers which are not values which need to be materialized in registers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a95cd714ab601765342e2ec9f6ba2cb34" name="a22ea9cec080dd5f4f47ba234c2f59110a95cd714ab601765342e2ec9f6ba2cb34"></a>TargetConstantFP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a87b8176af163ee944af127081d24f4a2" name="a22ea9cec080dd5f4f47ba234c2f59110a87b8176af163ee944af127081d24f4a2"></a>TargetGlobalAddress&#160;</td><td class="fielddoc"><p>TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or anything else with this node, and this is valid in the target-specific dag, turning into a GlobalAddress operand. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110afc9ad7857b7faf49dcde3dcf434e22a6" name="a22ea9cec080dd5f4f47ba234c2f59110afc9ad7857b7faf49dcde3dcf434e22a6"></a>TargetGlobalTLSAddress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aa84894f4966964ef9fc79f9515a6c875" name="a22ea9cec080dd5f4f47ba234c2f59110aa84894f4966964ef9fc79f9515a6c875"></a>TargetFrameIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a603c0651ff8c3a929c5e1d8b9a8f14cb" name="a22ea9cec080dd5f4f47ba234c2f59110a603c0651ff8c3a929c5e1d8b9a8f14cb"></a>TargetJumpTable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a038a7f124b4118456a27a739c03650bf" name="a22ea9cec080dd5f4f47ba234c2f59110a038a7f124b4118456a27a739c03650bf"></a>TargetConstantPool&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a59b314018a929255951f01f8daaae72f" name="a22ea9cec080dd5f4f47ba234c2f59110a59b314018a929255951f01f8daaae72f"></a>TargetExternalSymbol&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a1b7eba375863a0e80549eb1a782c5683" name="a22ea9cec080dd5f4f47ba234c2f59110a1b7eba375863a0e80549eb1a782c5683"></a>TargetBlockAddress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aabb68e91001557f73ff8af63eb8d5883" name="a22ea9cec080dd5f4f47ba234c2f59110aabb68e91001557f73ff8af63eb8d5883"></a>MCSymbol&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a606393d2a8329de83a61d6f6447d1035" name="a22ea9cec080dd5f4f47ba234c2f59110a606393d2a8329de83a61d6f6447d1035"></a>TargetIndex&#160;</td><td class="fielddoc"><p>TargetIndex - Like a constant pool entry, but with completely target-dependent semantics. </p>
<p>Holds target flags, a 32-bit index, and a 64-bit index. Targets can use this however they like. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ac771b9cda3b889242d457cc4d9b2159c" name="a22ea9cec080dd5f4f47ba234c2f59110ac771b9cda3b889242d457cc4d9b2159c"></a>INTRINSIC_WO_CHAIN&#160;</td><td class="fielddoc"><p>RESULT = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac771b9cda3b889242d457cc4d9b2159c" title="RESULT = INTRINSIC_WO_CHAIN(INTRINSICID, arg1, arg2, ...) This node represents a target intrinsic fun...">INTRINSIC_WO_CHAIN(INTRINSICID, arg1, arg2, ...)</a> This node represents a target intrinsic function with no side effects. </p>
<p>The first operand is the ID number of the intrinsic from the <a class="el" href="namespacellvm_1_1Intrinsic.html" title="This namespace contains an enum with a value for every intrinsic/builtin function known by LLVM.">llvm::Intrinsic</a> namespace. The operands to the intrinsic follow. The node returns the result of the intrinsic. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110afc09e0bddd693dcf9923e4df42473bd9" name="a22ea9cec080dd5f4f47ba234c2f59110afc09e0bddd693dcf9923e4df42473bd9"></a>INTRINSIC_W_CHAIN&#160;</td><td class="fielddoc"><p>RESULT,OUTCHAIN = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110afc09e0bddd693dcf9923e4df42473bd9" title="RESULT,OUTCHAIN = INTRINSIC_W_CHAIN(INCHAIN, INTRINSICID, arg1, ...) This node represents a target in...">INTRINSIC_W_CHAIN(INCHAIN, INTRINSICID, arg1, ...)</a> This node represents a target intrinsic function with side effects that returns a result. </p>
<p>The first operand is a chain pointer. The second is the ID number of the intrinsic from the <a class="el" href="namespacellvm_1_1Intrinsic.html" title="This namespace contains an enum with a value for every intrinsic/builtin function known by LLVM.">llvm::Intrinsic</a> namespace. The operands to the intrinsic follow. The node has two results, the result of the intrinsic and an output chain. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a2df96794a99f5d3b4415c4a84e616140" name="a22ea9cec080dd5f4f47ba234c2f59110a2df96794a99f5d3b4415c4a84e616140"></a>INTRINSIC_VOID&#160;</td><td class="fielddoc"><p>OUTCHAIN = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a2df96794a99f5d3b4415c4a84e616140" title="OUTCHAIN = INTRINSIC_VOID(INCHAIN, INTRINSICID, arg1, arg2, ...) This node represents a target intrin...">INTRINSIC_VOID(INCHAIN, INTRINSICID, arg1, arg2, ...)</a> This node represents a target intrinsic function with side effects that does not return a result. </p>
<p>The first operand is a chain pointer. The second is the ID number of the intrinsic from the <a class="el" href="namespacellvm_1_1Intrinsic.html" title="This namespace contains an enum with a value for every intrinsic/builtin function known by LLVM.">llvm::Intrinsic</a> namespace. The operands to the intrinsic follow. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a93bc27ca4d9e211c54b0d9efb660f080" name="a22ea9cec080dd5f4f47ba234c2f59110a93bc27ca4d9e211c54b0d9efb660f080"></a>CopyToReg&#160;</td><td class="fielddoc"><p>CopyToReg - This node has three operands: a chain, a register number to set to this value, and a value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a84c47705bcf7271413738ae8bf3871e6" name="a22ea9cec080dd5f4f47ba234c2f59110a84c47705bcf7271413738ae8bf3871e6"></a>CopyFromReg&#160;</td><td class="fielddoc"><p>CopyFromReg - This node indicates that the input value is a virtual or physical register that is defined outside of the scope of this <a class="el" href="classllvm_1_1SelectionDAG.html" title="This is used to represent a portion of an LLVM function in a low-level Data Dependence DAG representa...">SelectionDAG</a>. </p>
<p>The register is available from the <a class="el" href="classllvm_1_1RegisterSDNode.html">RegisterSDNode</a> object. Note that CopyFromReg is considered as also freezing the value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a7c6d8f265e9e16e5debdb9a536b55d3d" name="a22ea9cec080dd5f4f47ba234c2f59110a7c6d8f265e9e16e5debdb9a536b55d3d"></a>UNDEF&#160;</td><td class="fielddoc"><p>UNDEF - An undefined node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad3b50b6d74957b19afb85ac29f66afef" name="a22ea9cec080dd5f4f47ba234c2f59110ad3b50b6d74957b19afb85ac29f66afef"></a>FREEZE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a7e6dca8262a3de788d1bab4ba184d675" name="a22ea9cec080dd5f4f47ba234c2f59110a7e6dca8262a3de788d1bab4ba184d675"></a>EXTRACT_ELEMENT&#160;</td><td class="fielddoc"><p>EXTRACT_ELEMENT - This is used to get the lower or upper (determined by a <a class="el" href="classllvm_1_1Constant.html" title="This is an important base class in LLVM.">Constant</a>, which is required to be operand #1) half of the integer or float value specified as operand #0. </p>
<p>This is only for use before legalization, for values that will be broken into multiple registers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a41bd84b853e2c03fb1af1f4ca9ebdcaf" name="a22ea9cec080dd5f4f47ba234c2f59110a41bd84b853e2c03fb1af1f4ca9ebdcaf"></a>BUILD_PAIR&#160;</td><td class="fielddoc"><p>BUILD_PAIR - This is the opposite of EXTRACT_ELEMENT in some ways. </p>
<p>Given two values of the same integer value type, this produces a value twice as big. Like EXTRACT_ELEMENT, this can only be used before legalization. The lower part of the composite value should be in element 0 and the upper part should be in element 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a01c94937492f3ac3fb1e0be8eb0b9ef1" name="a22ea9cec080dd5f4f47ba234c2f59110a01c94937492f3ac3fb1e0be8eb0b9ef1"></a>MERGE_VALUES&#160;</td><td class="fielddoc"><p>MERGE_VALUES - This node takes multiple discrete operands and returns them all as its individual results. </p>
<p>This nodes has exactly the same number of inputs and outputs. This node is useful for some pieces of the code generator that want to think about a single node with multiple results, not multiple nodes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a269996b43a1f3e1d1f84a70fd4387535" name="a22ea9cec080dd5f4f47ba234c2f59110a269996b43a1f3e1d1f84a70fd4387535"></a>ADD&#160;</td><td class="fielddoc"><p>Simple integer binary arithmetic operators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a9fa617e5567c3c2638938f7b9ddc3f1c" name="a22ea9cec080dd5f4f47ba234c2f59110a9fa617e5567c3c2638938f7b9ddc3f1c"></a>SUB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad8aec9273962cf78d087090c11a1dd1c" name="a22ea9cec080dd5f4f47ba234c2f59110ad8aec9273962cf78d087090c11a1dd1c"></a>MUL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a1f61c2422057e10403b2f6003543c300" name="a22ea9cec080dd5f4f47ba234c2f59110a1f61c2422057e10403b2f6003543c300"></a>SDIV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a15637879021fa7d5226045c0668a99a8" name="a22ea9cec080dd5f4f47ba234c2f59110a15637879021fa7d5226045c0668a99a8"></a>UDIV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a124ba0f5b2887879212c74a68bc230a3" name="a22ea9cec080dd5f4f47ba234c2f59110a124ba0f5b2887879212c74a68bc230a3"></a>SREM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad1657dbc1957901a6d9cd224efbc0f28" name="a22ea9cec080dd5f4f47ba234c2f59110ad1657dbc1957901a6d9cd224efbc0f28"></a>UREM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a1354c6f8508d6cd697dc89a5d9a52dfd" name="a22ea9cec080dd5f4f47ba234c2f59110a1354c6f8508d6cd697dc89a5d9a52dfd"></a>SMUL_LOHI&#160;</td><td class="fielddoc"><p>SMUL_LOHI/UMUL_LOHI - Multiply two integers of type iN, producing a signed/unsigned value of type i[2*N], and return the full value as two results, each of type iN. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a79c959df09509d7ff66d9b04bc40d18d" name="a22ea9cec080dd5f4f47ba234c2f59110a79c959df09509d7ff66d9b04bc40d18d"></a>UMUL_LOHI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a3a874f66e1efe5be79552bbe7ee3121a" name="a22ea9cec080dd5f4f47ba234c2f59110a3a874f66e1efe5be79552bbe7ee3121a"></a>SDIVREM&#160;</td><td class="fielddoc"><p>SDIVREM/UDIVREM - Divide two integers and produce both a quotient and remainder result. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a3a257ffa49107e2db978e8a6e2688ada" name="a22ea9cec080dd5f4f47ba234c2f59110a3a257ffa49107e2db978e8a6e2688ada"></a>UDIVREM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110acc20c926003b2af97ba08689176e7130" name="a22ea9cec080dd5f4f47ba234c2f59110acc20c926003b2af97ba08689176e7130"></a>CARRY_FALSE&#160;</td><td class="fielddoc"><p>CARRY_FALSE - This node is used when folding other nodes, like ADDC/SUBC, which indicate the carry result is always false. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a20084f62caecb0db80ad71bdabda73c2" name="a22ea9cec080dd5f4f47ba234c2f59110a20084f62caecb0db80ad71bdabda73c2"></a>ADDC&#160;</td><td class="fielddoc"><p>Carry-setting nodes for multiple precision addition and subtraction. </p>
<p>These nodes take two operands of the same value type, and produce two results. The first result is the normal add or sub result, the second result is the carry flag result. FIXME: These nodes are deprecated in favor of UADDO_CARRY and USUBO_CARRY. They are kept around for now to provide a smooth transition path toward the use of UADDO_CARRY/USUBO_CARRY and will eventually be removed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a2ab6db512a611d1ef4ff8069e2bbfd0d" name="a22ea9cec080dd5f4f47ba234c2f59110a2ab6db512a611d1ef4ff8069e2bbfd0d"></a>SUBC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad116e32876f2275acf60ffb1651c9256" name="a22ea9cec080dd5f4f47ba234c2f59110ad116e32876f2275acf60ffb1651c9256"></a>ADDE&#160;</td><td class="fielddoc"><p>Carry-using nodes for multiple precision addition and subtraction. </p>
<p>These nodes take three operands: The first two are the normal lhs and rhs to the add or sub, and the third is the input carry flag. These nodes produce two results; the normal result of the add or sub, and the output carry flag. These nodes both read and write a carry flag to allow them to them to be chained together for add and sub of arbitrarily large values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ac9246c101c0cc9232e37b3941194bb13" name="a22ea9cec080dd5f4f47ba234c2f59110ac9246c101c0cc9232e37b3941194bb13"></a>SUBE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ab0f1e3ed26108fec69eb97209c0e39bf" name="a22ea9cec080dd5f4f47ba234c2f59110ab0f1e3ed26108fec69eb97209c0e39bf"></a>UADDO_CARRY&#160;</td><td class="fielddoc"><p>Carry-using nodes for multiple precision addition and subtraction. </p>
<p>These nodes take three operands: The first two are the normal lhs and rhs to the add or sub, and the third is a boolean value that is 1 if and only if there is an incoming carry/borrow. These nodes produce two results: the normal result of the add or sub, and a boolean value that is 1 if and only if there is an outgoing carry/borrow.</p>
<p>Care must be taken if these opcodes are lowered to hardware instructions that use the inverse logic &ndash; 0 if and only if there is an incoming/outgoing carry/borrow. In such cases, you must preserve the semantics of these opcodes by inverting the incoming carry/borrow, feeding it to the add/sub hardware instruction, and then inverting the outgoing carry/borrow.</p>
<p>The use of these opcodes is preferable to adde/sube if the target supports it, as the carry is a regular value rather than a glue, which allows further optimisation.</p>
<p>These opcodes are different from [US]{ADD,SUB}O in that U{ADD,SUB}O_CARRY consume and produce a carry/borrow, whereas [US]{ADD,SUB}O produce an overflow. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ac81ebcd59d629d8680e50ffba9855255" name="a22ea9cec080dd5f4f47ba234c2f59110ac81ebcd59d629d8680e50ffba9855255"></a>USUBO_CARRY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110af9eda6a77c3228cd36537469a7425133" name="a22ea9cec080dd5f4f47ba234c2f59110af9eda6a77c3228cd36537469a7425133"></a>SADDO_CARRY&#160;</td><td class="fielddoc"><p>Carry-using overflow-aware nodes for multiple precision addition and subtraction. </p>
<p>These nodes take three operands: The first two are normal lhs and rhs to the add or sub, and the third is a boolean indicating if there is an incoming carry. They produce two results: the normal result of the add or sub, and a boolean that indicates if an overflow occurred (<em>not</em> flag, because it may be a store to memory, etc.). If the type of the boolean is not i1 then the high bits conform to getBooleanContents. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a139dc5419039d94496e69dbb264251b5" name="a22ea9cec080dd5f4f47ba234c2f59110a139dc5419039d94496e69dbb264251b5"></a>SSUBO_CARRY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a863ec6ebb75bf89cfea14da646d77e92" name="a22ea9cec080dd5f4f47ba234c2f59110a863ec6ebb75bf89cfea14da646d77e92"></a>SADDO&#160;</td><td class="fielddoc"><p>RESULT, BOOL = [SU]ADDO(LHS, RHS) - Overflow-aware nodes for addition. </p>
<p>These nodes take two operands: the normal LHS and RHS to the add. They produce two results: the normal result of the add, and a boolean that indicates if an overflow occurred (<em>not</em> a flag, because it may be store to memory, etc.). If the type of the boolean is not i1 then the high bits conform to getBooleanContents. These nodes are generated from llvm.[su]add.with.overflow intrinsics. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a1ddf36330110b4abea43fe390bea9ef9" name="a22ea9cec080dd5f4f47ba234c2f59110a1ddf36330110b4abea43fe390bea9ef9"></a>UADDO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a6efe16ea597cfd8eeac26516fc992ee7" name="a22ea9cec080dd5f4f47ba234c2f59110a6efe16ea597cfd8eeac26516fc992ee7"></a>SSUBO&#160;</td><td class="fielddoc"><p>Same for subtraction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a4ffc75d65231b55461c0ba4f36a3e500" name="a22ea9cec080dd5f4f47ba234c2f59110a4ffc75d65231b55461c0ba4f36a3e500"></a>USUBO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aa35d0a58fdded3d225d512a60aea0951" name="a22ea9cec080dd5f4f47ba234c2f59110aa35d0a58fdded3d225d512a60aea0951"></a>SMULO&#160;</td><td class="fielddoc"><p>Same for multiplication. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a7800622851751b8ae318b41f4096830e" name="a22ea9cec080dd5f4f47ba234c2f59110a7800622851751b8ae318b41f4096830e"></a>UMULO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110af1b946afff631cee7aa6de570bef7785" name="a22ea9cec080dd5f4f47ba234c2f59110af1b946afff631cee7aa6de570bef7785"></a>SADDSAT&#160;</td><td class="fielddoc"><p>RESULT = [US]ADDSAT(LHS, RHS) - Perform saturation addition on 2 integers with the same bit width (W). </p>
<p>If the true value of LHS + RHS exceeds the largest value that can be represented by W bits, the resulting value is this maximum value. Otherwise, if this value is less than the smallest value that can be represented by W bits, the resulting value is this minimum value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a5e433873c201ad85c30e42da1ae05977" name="a22ea9cec080dd5f4f47ba234c2f59110a5e433873c201ad85c30e42da1ae05977"></a>UADDSAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a77984d86d70df1f3229da7a5119652a9" name="a22ea9cec080dd5f4f47ba234c2f59110a77984d86d70df1f3229da7a5119652a9"></a>SSUBSAT&#160;</td><td class="fielddoc"><p>RESULT = [US]SUBSAT(LHS, RHS) - Perform saturation subtraction on 2 integers with the same bit width (W). </p>
<p>If the true value of LHS - RHS exceeds the largest value that can be represented by W bits, the resulting value is this maximum value. Otherwise, if this value is less than the smallest value that can be represented by W bits, the resulting value is this minimum value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a89166b38f12c0bd3e8a61d8f1a5a8bc8" name="a22ea9cec080dd5f4f47ba234c2f59110a89166b38f12c0bd3e8a61d8f1a5a8bc8"></a>USUBSAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aa30a145a99902daca036d039378abca2" name="a22ea9cec080dd5f4f47ba234c2f59110aa30a145a99902daca036d039378abca2"></a>SSHLSAT&#160;</td><td class="fielddoc"><p>RESULT = [US]SHLSAT(LHS, RHS) - Perform saturation left shift. </p>
<p>The first operand is the value to be shifted, and the second argument is the amount to shift by. Both must be integers of the same bit width (W). If the true value of LHS &lt;&lt; RHS exceeds the largest value that can be represented by W bits, the resulting value is this maximum value, Otherwise, if this value is less than the smallest value that can be represented by W bits, the resulting value is this minimum value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a5ae4b108d3f627b66f3b1e5da51f4587" name="a22ea9cec080dd5f4f47ba234c2f59110a5ae4b108d3f627b66f3b1e5da51f4587"></a>USHLSAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a1a7f3f523e22ac3df6332e625289a7e6" name="a22ea9cec080dd5f4f47ba234c2f59110a1a7f3f523e22ac3df6332e625289a7e6"></a>SMULFIX&#160;</td><td class="fielddoc"><p>RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication on 2 integers with the same width and scale. </p>
<p>SCALE represents the scale of both operands as fixed point numbers. This SCALE parameter must be a constant integer. A scale of zero is effectively performing multiplication on 2 integers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a293cdca810c396f99a2bd63b017dd943" name="a22ea9cec080dd5f4f47ba234c2f59110a293cdca810c396f99a2bd63b017dd943"></a>UMULFIX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a26a7dd56cd899cec0a1f6d2443f91db4" name="a22ea9cec080dd5f4f47ba234c2f59110a26a7dd56cd899cec0a1f6d2443f91db4"></a>SMULFIXSAT&#160;</td><td class="fielddoc"><p>Same as the corresponding unsaturated fixed point instructions, but the result is clamped between the min and max values representable by the bits of the first 2 operands. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aaab3219acc86e3b3a199effbb69aa07a" name="a22ea9cec080dd5f4f47ba234c2f59110aaab3219acc86e3b3a199effbb69aa07a"></a>UMULFIXSAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a470242ff0d0c1f979101aa369a3a410e" name="a22ea9cec080dd5f4f47ba234c2f59110a470242ff0d0c1f979101aa369a3a410e"></a>SDIVFIX&#160;</td><td class="fielddoc"><p>RESULT = [US]DIVFIX(LHS, RHS, SCALE) - Perform fixed point division on 2 integers with the same width and scale. </p>
<p>SCALE represents the scale of both operands as fixed point numbers. This SCALE parameter must be a constant integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aaa5af2aa3cc2e31b44b69d43e13235be" name="a22ea9cec080dd5f4f47ba234c2f59110aaa5af2aa3cc2e31b44b69d43e13235be"></a>UDIVFIX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aadc85d973be8149bbaa5f372aa1faf3e" name="a22ea9cec080dd5f4f47ba234c2f59110aadc85d973be8149bbaa5f372aa1faf3e"></a>SDIVFIXSAT&#160;</td><td class="fielddoc"><p>Same as the corresponding unsaturated fixed point instructions, but the result is clamped between the min and max values representable by the bits of the first 2 operands. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a5c5ebc516cae422508ee0c062ef6b593" name="a22ea9cec080dd5f4f47ba234c2f59110a5c5ebc516cae422508ee0c062ef6b593"></a>UDIVFIXSAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a32ec12017722f5b42a295fe5eb0b0bdf" name="a22ea9cec080dd5f4f47ba234c2f59110a32ec12017722f5b42a295fe5eb0b0bdf"></a>FADD&#160;</td><td class="fielddoc"><p>Simple binary floating point operators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a2852a5b6baa80b1589a46737210a8cad" name="a22ea9cec080dd5f4f47ba234c2f59110a2852a5b6baa80b1589a46737210a8cad"></a>FSUB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a9ab5860c97a00c4627a08cab7b0c8178" name="a22ea9cec080dd5f4f47ba234c2f59110a9ab5860c97a00c4627a08cab7b0c8178"></a>FMUL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110abc6c09c7af98236460f0b020eb3be94e" name="a22ea9cec080dd5f4f47ba234c2f59110abc6c09c7af98236460f0b020eb3be94e"></a>FDIV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110abdd7bbb76dac7962dda6e116e33699da" name="a22ea9cec080dd5f4f47ba234c2f59110abdd7bbb76dac7962dda6e116e33699da"></a>FREM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad11fa7fd2a91d210ecbdf09d56cd9f42" name="a22ea9cec080dd5f4f47ba234c2f59110ad11fa7fd2a91d210ecbdf09d56cd9f42"></a>STRICT_FADD&#160;</td><td class="fielddoc"><p>Constrained versions of the binary floating point operators. </p>
<p>These will be lowered to the simple operators before final selection. They are used to limit optimizations while the DAG is being optimized. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad6192a54cb1dfeca8173749cc735269a" name="a22ea9cec080dd5f4f47ba234c2f59110ad6192a54cb1dfeca8173749cc735269a"></a>STRICT_FSUB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a4b912b6be299d30d75b876e939d16fd6" name="a22ea9cec080dd5f4f47ba234c2f59110a4b912b6be299d30d75b876e939d16fd6"></a>STRICT_FMUL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a4151e13f7626f6d790d58c0fa444f32e" name="a22ea9cec080dd5f4f47ba234c2f59110a4151e13f7626f6d790d58c0fa444f32e"></a>STRICT_FDIV&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aacf4034f48b7e32a9e20bfedbb5502bd" name="a22ea9cec080dd5f4f47ba234c2f59110aacf4034f48b7e32a9e20bfedbb5502bd"></a>STRICT_FREM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a26ff7f7547f66e1a4f6d5e7efe4b2f59" name="a22ea9cec080dd5f4f47ba234c2f59110a26ff7f7547f66e1a4f6d5e7efe4b2f59"></a>STRICT_FMA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a476844aad24870fab3d132b5fe6b1f37" name="a22ea9cec080dd5f4f47ba234c2f59110a476844aad24870fab3d132b5fe6b1f37"></a>STRICT_FSQRT&#160;</td><td class="fielddoc"><p>Constrained versions of libm-equivalent floating point intrinsics. </p>
<p>These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a65a342694a17f4a1db771dbc36d31cc9" name="a22ea9cec080dd5f4f47ba234c2f59110a65a342694a17f4a1db771dbc36d31cc9"></a>STRICT_FPOW&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a7acf26c84b90a50efe9898bc9bcd8d18" name="a22ea9cec080dd5f4f47ba234c2f59110a7acf26c84b90a50efe9898bc9bcd8d18"></a>STRICT_FPOWI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110addd63c6d866c8a8020a0cc4de467b285" name="a22ea9cec080dd5f4f47ba234c2f59110addd63c6d866c8a8020a0cc4de467b285"></a>STRICT_FLDEXP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a06c721642eadaa31c37384b39fe11387" name="a22ea9cec080dd5f4f47ba234c2f59110a06c721642eadaa31c37384b39fe11387"></a>STRICT_FSIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ae2047d551dd66943aa285b4c7eab0766" name="a22ea9cec080dd5f4f47ba234c2f59110ae2047d551dd66943aa285b4c7eab0766"></a>STRICT_FCOS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad8ae8131038d9b94abd2880812bf5b0e" name="a22ea9cec080dd5f4f47ba234c2f59110ad8ae8131038d9b94abd2880812bf5b0e"></a>STRICT_FTAN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a548c5ee9bfffd516c18b0844d8916d98" name="a22ea9cec080dd5f4f47ba234c2f59110a548c5ee9bfffd516c18b0844d8916d98"></a>STRICT_FASIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110afc1699b53cce73a1a89fa9190db8f2f8" name="a22ea9cec080dd5f4f47ba234c2f59110afc1699b53cce73a1a89fa9190db8f2f8"></a>STRICT_FACOS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a5fc35989024437e6878d228dce85b34d" name="a22ea9cec080dd5f4f47ba234c2f59110a5fc35989024437e6878d228dce85b34d"></a>STRICT_FATAN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a9b07fb8cd5a1230b0f736489ddd9eebc" name="a22ea9cec080dd5f4f47ba234c2f59110a9b07fb8cd5a1230b0f736489ddd9eebc"></a>STRICT_FSINH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ac9090021eb9a063125475a3d2f380af2" name="a22ea9cec080dd5f4f47ba234c2f59110ac9090021eb9a063125475a3d2f380af2"></a>STRICT_FCOSH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a244401fe9aee94da72b7f0fb6b095a45" name="a22ea9cec080dd5f4f47ba234c2f59110a244401fe9aee94da72b7f0fb6b095a45"></a>STRICT_FTANH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aba2dfbb2100ec6aee6e5b52bc713c26a" name="a22ea9cec080dd5f4f47ba234c2f59110aba2dfbb2100ec6aee6e5b52bc713c26a"></a>STRICT_FEXP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad5d3bf9997ecfea792abc058e7d39e72" name="a22ea9cec080dd5f4f47ba234c2f59110ad5d3bf9997ecfea792abc058e7d39e72"></a>STRICT_FEXP2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad795680a8d2d37bdede6696d72f41c35" name="a22ea9cec080dd5f4f47ba234c2f59110ad795680a8d2d37bdede6696d72f41c35"></a>STRICT_FLOG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad227f160898f13eeb05150f03de8d40b" name="a22ea9cec080dd5f4f47ba234c2f59110ad227f160898f13eeb05150f03de8d40b"></a>STRICT_FLOG10&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a409f18d3c3acb29ab844e9942441cc4b" name="a22ea9cec080dd5f4f47ba234c2f59110a409f18d3c3acb29ab844e9942441cc4b"></a>STRICT_FLOG2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110af57a22f2843a1c3a79d17350945ede58" name="a22ea9cec080dd5f4f47ba234c2f59110af57a22f2843a1c3a79d17350945ede58"></a>STRICT_FRINT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ae463c3e40819d6e9de30d7d858867ef4" name="a22ea9cec080dd5f4f47ba234c2f59110ae463c3e40819d6e9de30d7d858867ef4"></a>STRICT_FNEARBYINT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a92f7a0e4dfe860ff938d463d84270ba3" name="a22ea9cec080dd5f4f47ba234c2f59110a92f7a0e4dfe860ff938d463d84270ba3"></a>STRICT_FMAXNUM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a98f18e85e4e6421f5c859680602a4c1f" name="a22ea9cec080dd5f4f47ba234c2f59110a98f18e85e4e6421f5c859680602a4c1f"></a>STRICT_FMINNUM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a1fb1e48394636004fd75f5916f0d730f" name="a22ea9cec080dd5f4f47ba234c2f59110a1fb1e48394636004fd75f5916f0d730f"></a>STRICT_FCEIL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ab74cbb3933c5f5d2cc90d299836c05cc" name="a22ea9cec080dd5f4f47ba234c2f59110ab74cbb3933c5f5d2cc90d299836c05cc"></a>STRICT_FFLOOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ab0953e80e4e94f6ded9680e64c5df5cc" name="a22ea9cec080dd5f4f47ba234c2f59110ab0953e80e4e94f6ded9680e64c5df5cc"></a>STRICT_FROUND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ab7d5c27c800b79a02a1492f1965af72f" name="a22ea9cec080dd5f4f47ba234c2f59110ab7d5c27c800b79a02a1492f1965af72f"></a>STRICT_FROUNDEVEN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a883c1084962f12018ca0fe3e1222fa7d" name="a22ea9cec080dd5f4f47ba234c2f59110a883c1084962f12018ca0fe3e1222fa7d"></a>STRICT_FTRUNC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a6bd04c8da718875a071107ede0f362d6" name="a22ea9cec080dd5f4f47ba234c2f59110a6bd04c8da718875a071107ede0f362d6"></a>STRICT_LROUND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110adef1eba7d8c2a0db4a94d7327d217c90" name="a22ea9cec080dd5f4f47ba234c2f59110adef1eba7d8c2a0db4a94d7327d217c90"></a>STRICT_LLROUND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aa7fc883444df66de315a684ecf5f5e2d" name="a22ea9cec080dd5f4f47ba234c2f59110aa7fc883444df66de315a684ecf5f5e2d"></a>STRICT_LRINT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad4892124e4817d9807dcf39808016bc4" name="a22ea9cec080dd5f4f47ba234c2f59110ad4892124e4817d9807dcf39808016bc4"></a>STRICT_LLRINT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a917038ef7ae3264e336457da0f75e95b" name="a22ea9cec080dd5f4f47ba234c2f59110a917038ef7ae3264e336457da0f75e95b"></a>STRICT_FMAXIMUM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a3093a04e2918e155f32d435e2f974e88" name="a22ea9cec080dd5f4f47ba234c2f59110a3093a04e2918e155f32d435e2f974e88"></a>STRICT_FMINIMUM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ac2618c1a69fa9d62427a5a6dc43e24ed" name="a22ea9cec080dd5f4f47ba234c2f59110ac2618c1a69fa9d62427a5a6dc43e24ed"></a>STRICT_FP_TO_SINT&#160;</td><td class="fielddoc"><p>STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or unsigned integer. </p>
<p>These have the same semantics as fptosi and fptoui in IR. They are used to limit optimizations while the DAG is being optimized. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110abf955b4b70f63865e022c329d1775579" name="a22ea9cec080dd5f4f47ba234c2f59110abf955b4b70f63865e022c329d1775579"></a>STRICT_FP_TO_UINT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ab38d2af541b99492acf69c041c98bcb6" name="a22ea9cec080dd5f4f47ba234c2f59110ab38d2af541b99492acf69c041c98bcb6"></a>STRICT_SINT_TO_FP&#160;</td><td class="fielddoc"><p>STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to a floating point value. </p>
<p>These have the same semantics as sitofp and uitofp in IR. They are used to limit optimizations while the DAG is being optimized. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a56735332b7dc26b4e164035831fb40ab" name="a22ea9cec080dd5f4f47ba234c2f59110a56735332b7dc26b4e164035831fb40ab"></a>STRICT_UINT_TO_FP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ac2273d9cd04ba6e4a7c1a4b28ab1aaba" name="a22ea9cec080dd5f4f47ba234c2f59110ac2273d9cd04ba6e4a7c1a4b28ab1aaba"></a>STRICT_FP_ROUND&#160;</td><td class="fielddoc"><p>X = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac2273d9cd04ba6e4a7c1a4b28ab1aaba" title="X = STRICT_FP_ROUND(Y, TRUNC) - Rounding &#39;Y&#39; from a larger floating point type down to the precision ...">STRICT_FP_ROUND(Y, TRUNC)</a> - Rounding 'Y' from a larger floating point type down to the precision of the destination VT. </p>
<p>TRUNC is a flag, which is always an integer that is zero or one. If TRUNC is 0, this is a normal rounding, if it is 1, this FP_ROUND is known to not change the value of Y.</p>
<p>The TRUNC = 1 case is used in cases where we know that the value will not be modified by the node, because Y is not using any of the extra precision of source type. This allows certain transformations like <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac47e026e409ff39f319cbb3b096863e6" title="X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type.">STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1))</a> -&gt; X which are not safe for <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac47e026e409ff39f319cbb3b096863e6" title="X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type.">STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0))</a> because the extra bits aren't removed. It is used to limit optimizations while the DAG is being optimized. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ac47e026e409ff39f319cbb3b096863e6" name="a22ea9cec080dd5f4f47ba234c2f59110ac47e026e409ff39f319cbb3b096863e6"></a>STRICT_FP_EXTEND&#160;</td><td class="fielddoc"><p>X = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac47e026e409ff39f319cbb3b096863e6" title="X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type.">STRICT_FP_EXTEND(Y)</a> - Extend a smaller FP type into a larger FP type. </p>
<p>It is used to limit optimizations while the DAG is being optimized. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a0466b21bfb4f3596e41380d8e2d1956f" name="a22ea9cec080dd5f4f47ba234c2f59110a0466b21bfb4f3596e41380d8e2d1956f"></a>STRICT_FSETCC&#160;</td><td class="fielddoc"><p>STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used for floating-point operands only. </p>
<p>STRICT_FSETCC performs a quiet comparison operation, while STRICT_FSETCCS performs a signaling comparison operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a3c8d07d668872f2176fb34724cd799c4" name="a22ea9cec080dd5f4f47ba234c2f59110a3c8d07d668872f2176fb34724cd799c4"></a>STRICT_FSETCCS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a40b296b7db128b2d63f81a95efc5a311" name="a22ea9cec080dd5f4f47ba234c2f59110a40b296b7db128b2d63f81a95efc5a311"></a>FPTRUNC_ROUND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a293ca68b3b2ce80eef991de822822254" name="a22ea9cec080dd5f4f47ba234c2f59110a293ca68b3b2ce80eef991de822822254"></a>FMA&#160;</td><td class="fielddoc"><p>FMA - Perform a * b + c with no intermediate rounding step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a2415bea72c995bb9cf9f85bbbf90bcd7" name="a22ea9cec080dd5f4f47ba234c2f59110a2415bea72c995bb9cf9f85bbbf90bcd7"></a>FMAD&#160;</td><td class="fielddoc"><p>FMAD - Perform a * b + c, while getting the same result as the separately rounded operations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aeffc3319657e213a530ce583603f7221" name="a22ea9cec080dd5f4f47ba234c2f59110aeffc3319657e213a530ce583603f7221"></a>FCOPYSIGN&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aeffc3319657e213a530ce583603f7221" title="FCOPYSIGN(X, Y) - Return the value of X with the sign of Y.">FCOPYSIGN(X, Y)</a> - Return the value of X with the sign of Y. </p>
<p>NOTE: This DAG node does not require that X and Y have the same type, just that they are both floating point. X and the result must have the same type. <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aeffc3319657e213a530ce583603f7221" title="FCOPYSIGN(X, Y) - Return the value of X with the sign of Y.">FCOPYSIGN(f32, f64)</a> is allowed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a130b6a6d409367c8a61dd14dfa39785c" name="a22ea9cec080dd5f4f47ba234c2f59110a130b6a6d409367c8a61dd14dfa39785c"></a>FGETSIGN&#160;</td><td class="fielddoc"><p>INT = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a130b6a6d409367c8a61dd14dfa39785c" title="INT = FGETSIGN(FP) - Return the sign bit of the specified floating point value as an integer 0/1 valu...">FGETSIGN(FP)</a> - Return the sign bit of the specified floating point value as an integer 0/1 value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a74a787311d3ab9a17ee0acde7b6a6b14" name="a22ea9cec080dd5f4f47ba234c2f59110a74a787311d3ab9a17ee0acde7b6a6b14"></a>FCANONICALIZE&#160;</td><td class="fielddoc"><p>Returns platform specific canonical encoding of a floating point number. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a76b6d3008e806ea613323ff316ef72c3" name="a22ea9cec080dd5f4f47ba234c2f59110a76b6d3008e806ea613323ff316ef72c3"></a>IS_FPCLASS&#160;</td><td class="fielddoc"><p>Performs a check of floating point class property, defined by IEEE-754. </p>
<p>The first operand is the floating point value to check. The second operand specifies the checked property and is a TargetConstant which specifies test in the same way as intrinsic 'is_fpclass'. Returns boolean value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aff6f73b624fecca7dbe94259f9437e32" name="a22ea9cec080dd5f4f47ba234c2f59110aff6f73b624fecca7dbe94259f9437e32"></a>BUILD_VECTOR&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aff6f73b624fecca7dbe94259f9437e32" title="BUILD_VECTOR(ELT0, ELT1, ELT2, ELT3,...) - Return a fixed-width vector with the specified,...">BUILD_VECTOR(ELT0, ELT1, ELT2, ELT3,...)</a> - Return a fixed-width vector with the specified, possibly variable, elements. </p>
<p>The types of the operands must match the vector element type, except that integer types are allowed to be larger than the element type, in which case the operands are implicitly truncated. The types of the operands must all be the same. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad3bc7c2d379fbfdc2f8eaca038690ec9" name="a22ea9cec080dd5f4f47ba234c2f59110ad3bc7c2d379fbfdc2f8eaca038690ec9"></a>INSERT_VECTOR_ELT&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad3bc7c2d379fbfdc2f8eaca038690ec9" title="INSERT_VECTOR_ELT(VECTOR, VAL, IDX) - Returns VECTOR with the element at IDX replaced with VAL.">INSERT_VECTOR_ELT(VECTOR, VAL, IDX)</a> - Returns VECTOR with the element at IDX replaced with VAL. </p>
<p>If the type of VAL is larger than the vector element type then VAL is truncated before replacement.</p>
<p>If VECTOR is a scalable vector, then IDX may be larger than the minimum vector width. IDX is not first scaled by the runtime scaling factor of VECTOR. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a9329e79f62e9ab9b41cfbcafd314bcbd" name="a22ea9cec080dd5f4f47ba234c2f59110a9329e79f62e9ab9b41cfbcafd314bcbd"></a>EXTRACT_VECTOR_ELT&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a9329e79f62e9ab9b41cfbcafd314bcbd" title="EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR identified by the (potentially...">EXTRACT_VECTOR_ELT(VECTOR, IDX)</a> - Returns a single element from VECTOR identified by the (potentially variable) element number IDX. </p>
<p>If the return type is an integer type larger than the element type of the vector, the result is extended to the width of the return type. In that case, the high bits are undefined.</p>
<p>If VECTOR is a scalable vector, then IDX may be larger than the minimum vector width. IDX is not first scaled by the runtime scaling factor of VECTOR. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a320898056eadc3254fc601e1362eb9f5" name="a22ea9cec080dd5f4f47ba234c2f59110a320898056eadc3254fc601e1362eb9f5"></a>CONCAT_VECTORS&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a320898056eadc3254fc601e1362eb9f5" title="CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of vector type with the same length ...">CONCAT_VECTORS(VECTOR0, VECTOR1, ...)</a> - Given a number of values of vector type with the same length and element type, this produces a concatenated vector result value, with length equal to the sum of the lengths of the input vectors. </p>
<p>If VECTOR0 is a fixed-width vector, then VECTOR1..VECTORN must all be fixed-width vectors. Similarly, if VECTOR0 is a scalable vector, then VECTOR1..VECTORN must all be scalable vectors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a1617abaedbb1d902bb3a5b3136684f9c" name="a22ea9cec080dd5f4f47ba234c2f59110a1617abaedbb1d902bb3a5b3136684f9c"></a>INSERT_SUBVECTOR&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a1617abaedbb1d902bb3a5b3136684f9c" title="INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2 inserted into VECTOR1.">INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX)</a> - Returns a vector with VECTOR2 inserted into VECTOR1. </p>
<p>IDX represents the starting element number at which VECTOR2 will be inserted. IDX must be a constant multiple of T's known minimum vector length. Let the type of VECTOR2 be T, then if T is a scalable vector, IDX is first scaled by the runtime scaling factor of T. The elements of VECTOR1 starting at IDX are overwritten with VECTOR2. Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR1 indices. If this condition cannot be determined statically but is false at runtime, then the result vector is undefined. The IDX parameter must be a vector index constant type, which for most targets will be an integer pointer type.</p>
<p>This operation supports inserting a fixed-width vector into a scalable vector, but not the other way around. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a9070de8a5c5b71851732c4c54e2ffedf" name="a22ea9cec080dd5f4f47ba234c2f59110a9070de8a5c5b71851732c4c54e2ffedf"></a>EXTRACT_SUBVECTOR&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a9070de8a5c5b71851732c4c54e2ffedf" title="EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR.">EXTRACT_SUBVECTOR(VECTOR, IDX)</a> - Returns a subvector from VECTOR. </p>
<p>Let the result type be T, then IDX represents the starting element number from which a subvector of type T is extracted. IDX must be a constant multiple of T's known minimum vector length. If T is a scalable vector, IDX is first scaled by the runtime scaling factor of T. Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR indices. If this condition cannot be determined statically but is false at runtime, then the result vector is undefined. The IDX parameter must be a vector index constant type, which for most targets will be an integer pointer type.</p>
<p>This operation supports extracting a fixed-width vector from a scalable vector, but not the other way around. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110af5b978686fa3409a40ce3abe447db653" name="a22ea9cec080dd5f4f47ba234c2f59110af5b978686fa3409a40ce3abe447db653"></a>VECTOR_DEINTERLEAVE&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110af5b978686fa3409a40ce3abe447db653" title="VECTOR_DEINTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and output vectors having the sa...">VECTOR_DEINTERLEAVE(VEC1, VEC2)</a> - Returns two vectors with all input and output vectors having the same type. </p>
<p>The first output contains the even indices from <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a320898056eadc3254fc601e1362eb9f5" title="CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of vector type with the same length ...">CONCAT_VECTORS(VEC1, VEC2)</a>, with the second output containing the odd indices. The relative order of elements within an output match that of the concatenated input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a7314e9c42c2c93e3786adfd12aee39d7" name="a22ea9cec080dd5f4f47ba234c2f59110a7314e9c42c2c93e3786adfd12aee39d7"></a>VECTOR_INTERLEAVE&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7314e9c42c2c93e3786adfd12aee39d7" title="VECTOR_INTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and output vectors having the same...">VECTOR_INTERLEAVE(VEC1, VEC2)</a> - Returns two vectors with all input and output vectors having the same type. </p>
<p>The first output contains the result of interleaving the low half of <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a320898056eadc3254fc601e1362eb9f5" title="CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of vector type with the same length ...">CONCAT_VECTORS(VEC1, VEC2)</a>, with the second output containing the result of interleaving the high half. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aad7728df1343db6f976857aaa2e945ee" name="a22ea9cec080dd5f4f47ba234c2f59110aad7728df1343db6f976857aaa2e945ee"></a>VECTOR_REVERSE&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aad7728df1343db6f976857aaa2e945ee" title="VECTOR_REVERSE(VECTOR) - Returns a vector, of the same type as VECTOR, whose elements are shuffled us...">VECTOR_REVERSE(VECTOR)</a> - Returns a vector, of the same type as VECTOR, whose elements are shuffled using the following algorithm: RESULT[i] = VECTOR[VECTOR.ElementCount - 1 - i]. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a8d8773b28111d8898663d4a0f6223d68" name="a22ea9cec080dd5f4f47ba234c2f59110a8d8773b28111d8898663d4a0f6223d68"></a>VECTOR_SHUFFLE&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a8d8773b28111d8898663d4a0f6223d68" title="VECTOR_SHUFFLE(VEC1, VEC2) - Returns a vector, of the same type as VEC1/VEC2.">VECTOR_SHUFFLE(VEC1, VEC2)</a> - Returns a vector, of the same type as VEC1/VEC2. </p>
<p>A VECTOR_SHUFFLE node also contains an array of constant int values that indicate which value (or undef) each result element will get. These constant ints are accessible through the <a class="el" href="classllvm_1_1ShuffleVectorSDNode.html" title="This SDNode is used to implement the code generator support for the llvm IR shufflevector instruction...">ShuffleVectorSDNode</a> class. This is quite similar to the Altivec 'vperm' instruction, except that the indices must be constants and are in terms of the element size of VEC1/VEC2, not in terms of bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad55a17543ef86f6d46aebb45028a9067" name="a22ea9cec080dd5f4f47ba234c2f59110ad55a17543ef86f6d46aebb45028a9067"></a>VECTOR_SPLICE&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad55a17543ef86f6d46aebb45028a9067" title="VECTOR_SPLICE(VEC1, VEC2, IMM) - Returns a subvector of the same type as VEC1/VEC2 from CONCAT_VECTOR...">VECTOR_SPLICE(VEC1, VEC2, IMM)</a> - Returns a subvector of the same type as VEC1/VEC2 from <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a320898056eadc3254fc601e1362eb9f5" title="CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of vector type with the same length ...">CONCAT_VECTORS(VEC1, VEC2)</a>, based on the IMM in two ways. </p>
<p>Let the result type be T, if IMM is positive it represents the starting element number (an index) from which a subvector of type T is extracted from <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a320898056eadc3254fc601e1362eb9f5" title="CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of vector type with the same length ...">CONCAT_VECTORS(VEC1, VEC2)</a>. If IMM is negative it represents a count specifying the number of trailing elements to extract from VEC1, where the elements of T are selected using the following algorithm: RESULT[i] = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a320898056eadc3254fc601e1362eb9f5" title="CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of vector type with the same length ...">CONCAT_VECTORS(VEC1,VEC2)</a>[VEC1.ElementCount - <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a35c1cf0dd553444732dba8e8b9be0f6b" title="ABS - Determine the unsigned absolute value of a signed integer value of the same bitwidth.">ABS(IMM)</a> + i] If IMM is not in the range [-VL, VL-1] the result vector is undefined. IMM is a constant integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a576080a08ef1bbab0308eac9d5838f75" name="a22ea9cec080dd5f4f47ba234c2f59110a576080a08ef1bbab0308eac9d5838f75"></a>SCALAR_TO_VECTOR&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a576080a08ef1bbab0308eac9d5838f75" title="SCALAR_TO_VECTOR(VAL) - This represents the operation of loading a scalar value into element 0 of the...">SCALAR_TO_VECTOR(VAL)</a> - This represents the operation of loading a scalar value into element 0 of the resultant vector type. </p>
<p>The top elements 1 to N-1 of the N-element vector are undefined. The type of the operand must match the vector element type, except when they are integer types. In this case the operand is allowed to be wider than the vector element type, and is implicitly truncated to it. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a7f864031b6fb691b1525cbea92542ef1" name="a22ea9cec080dd5f4f47ba234c2f59110a7f864031b6fb691b1525cbea92542ef1"></a>SPLAT_VECTOR&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7f864031b6fb691b1525cbea92542ef1" title="SPLAT_VECTOR(VAL) - Returns a vector with the scalar value VAL duplicated in all lanes.">SPLAT_VECTOR(VAL)</a> - Returns a vector with the scalar value VAL duplicated in all lanes. </p>
<p>The type of the operand must match the vector element type, except when they are integer types. In this case the operand is allowed to be wider than the vector element type, and is implicitly truncated to it. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ad358f0823a936bde7edd419ab1058bd4" name="a22ea9cec080dd5f4f47ba234c2f59110ad358f0823a936bde7edd419ab1058bd4"></a>SPLAT_VECTOR_PARTS&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad358f0823a936bde7edd419ab1058bd4" title="SPLAT_VECTOR_PARTS(SCALAR1, SCALAR2, ...) - Returns a vector with the scalar values joined together a...">SPLAT_VECTOR_PARTS(SCALAR1, SCALAR2, ...)</a> - Returns a vector with the scalar values joined together and then duplicated in all lanes. </p>
<p>This represents a SPLAT_VECTOR that has had its scalar operand expanded. This allows representing a 64-bit splat on a target with 32-bit integers. The total width of the scalars must cover the element width. SCALAR1 contains the least significant bits of the value regardless of endianness and all scalars should have the same type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a73ec2109e5056d5cb07dad24ddd848c3" name="a22ea9cec080dd5f4f47ba234c2f59110a73ec2109e5056d5cb07dad24ddd848c3"></a>STEP_VECTOR&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a73ec2109e5056d5cb07dad24ddd848c3" title="STEP_VECTOR(IMM) - Returns a scalable vector whose lanes are comprised of a linear sequence of unsign...">STEP_VECTOR(IMM)</a> - Returns a scalable vector whose lanes are comprised of a linear sequence of unsigned values starting from 0 with a step of IMM, where IMM must be a TargetConstant with type equal to the vector element type. </p>
<p>The arithmetic is performed modulo the bitwidth of the element.</p>
<p>The operation does not support returning fixed-width vectors or non-constant operands. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110adb06c311948bd9fb944ab3c433138181" name="a22ea9cec080dd5f4f47ba234c2f59110adb06c311948bd9fb944ab3c433138181"></a>VECTOR_COMPRESS&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110adb06c311948bd9fb944ab3c433138181" title="VECTOR_COMPRESS(Vec, Mask, Passthru) consecutively place vector elements based on mask e....">VECTOR_COMPRESS(Vec, Mask, Passthru)</a> consecutively place vector elements based on mask e.g., vec = {A, B, C, D} and mask = {1, 0, 1, 0} --&gt; {A, C, ?, ?} where ? is undefined If passthru is defined, ?s are replaced with elements from passthru. </p>
<p>If passthru is undef, ?s remain undefined. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a8a80d3b085af08f0dce1724207ef99b5" name="a22ea9cec080dd5f4f47ba234c2f59110a8a80d3b085af08f0dce1724207ef99b5"></a>MULHU&#160;</td><td class="fielddoc"><p>MULHU/MULHS - Multiply high - Multiply two integers of type iN, producing an unsigned/signed value of type i[2*N], then return the top part. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aa2a7c3eccf06b41e4275bbeadb46d22e" name="a22ea9cec080dd5f4f47ba234c2f59110aa2a7c3eccf06b41e4275bbeadb46d22e"></a>MULHS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110acc5444f2e2933b551e3afbdd93a9bfc8" name="a22ea9cec080dd5f4f47ba234c2f59110acc5444f2e2933b551e3afbdd93a9bfc8"></a>AVGFLOORS&#160;</td><td class="fielddoc"><p>AVGFLOORS/AVGFLOORU - Averaging add - Add two integers using an integer of type i[N+1], halving the result by shifting it one bit right. </p>
<p>shr(add(ext(X), ext(Y)), 1) </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a5096628a43b16ff34ace64193ded1c93" name="a22ea9cec080dd5f4f47ba234c2f59110a5096628a43b16ff34ace64193ded1c93"></a>AVGFLOORU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a55a4b1d94ca6176bcb5449196d67e798" name="a22ea9cec080dd5f4f47ba234c2f59110a55a4b1d94ca6176bcb5449196d67e798"></a>AVGCEILS&#160;</td><td class="fielddoc"><p>AVGCEILS/AVGCEILU - Rounding averaging add - Add two integers using an integer of type i[N+2], add 1 and halve the result by shifting it one bit right. </p>
<p>shr(add(ext(X), ext(Y), 1), 1) </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a8489c40b1b3f92b0c4fc98d06099c441" name="a22ea9cec080dd5f4f47ba234c2f59110a8489c40b1b3f92b0c4fc98d06099c441"></a>AVGCEILU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110af798622367e75c5536666dbfec5d5ea3" name="a22ea9cec080dd5f4f47ba234c2f59110af798622367e75c5536666dbfec5d5ea3"></a>ABDS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aff129f5ab4fbc8279e7aaacb45f840b1" name="a22ea9cec080dd5f4f47ba234c2f59110aff129f5ab4fbc8279e7aaacb45f840b1"></a>ABDU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aaac895215ecbb3c411c957c8beb39b70" name="a22ea9cec080dd5f4f47ba234c2f59110aaac895215ecbb3c411c957c8beb39b70"></a>SMIN&#160;</td><td class="fielddoc"><p>[US]{MIN/MAX} - Binary minimum or maximum of signed or unsigned integers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110af3b59179b6fcbc89463181015ace8e9b" name="a22ea9cec080dd5f4f47ba234c2f59110af3b59179b6fcbc89463181015ace8e9b"></a>SMAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a17126302da6199930e55e841ca1b082d" name="a22ea9cec080dd5f4f47ba234c2f59110a17126302da6199930e55e841ca1b082d"></a>UMIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110af675e759c0ffff8d48ea14a60fe3517b" name="a22ea9cec080dd5f4f47ba234c2f59110af675e759c0ffff8d48ea14a60fe3517b"></a>UMAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ac9cda41d5b1ac3a0babb77b881b506eb" name="a22ea9cec080dd5f4f47ba234c2f59110ac9cda41d5b1ac3a0babb77b881b506eb"></a>SCMP&#160;</td><td class="fielddoc"><p>[US]CMP - 3-way comparison of signed or unsigned integers. </p>
<p>Returns -1, 0, or 1 depending on whether Op0 &lt;, ==, or &gt; Op1. The operands can have type different to the result. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a482ae65625bd4d6059f7259b88ac4dbc" name="a22ea9cec080dd5f4f47ba234c2f59110a482ae65625bd4d6059f7259b88ac4dbc"></a>UCMP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ac513a7da1bf74fb3e3c594da8534f2d2" name="a22ea9cec080dd5f4f47ba234c2f59110ac513a7da1bf74fb3e3c594da8534f2d2"></a>AND&#160;</td><td class="fielddoc"><p>Bitwise operators - logical and, logical or, logical xor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a7415ab9f2172c59a2ee7c7a02afa56a4" name="a22ea9cec080dd5f4f47ba234c2f59110a7415ab9f2172c59a2ee7c7a02afa56a4"></a>OR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a92febb83e6ba116eb7aae8e7e3f70cc1" name="a22ea9cec080dd5f4f47ba234c2f59110a92febb83e6ba116eb7aae8e7e3f70cc1"></a>XOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a35c1cf0dd553444732dba8e8b9be0f6b" name="a22ea9cec080dd5f4f47ba234c2f59110a35c1cf0dd553444732dba8e8b9be0f6b"></a>ABS&#160;</td><td class="fielddoc"><p>ABS - Determine the unsigned absolute value of a signed integer value of the same bitwidth. </p>
<p>Note: A value of INT_MIN will return INT_MIN, no saturation or overflow is performed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a8cc94e03dea594863073a02f5bb94997" name="a22ea9cec080dd5f4f47ba234c2f59110a8cc94e03dea594863073a02f5bb94997"></a>SHL&#160;</td><td class="fielddoc"><p>Shift and rotation operations. </p>
<p>After legalization, the type of the shift amount is known to be TLI.getShiftAmountTy(). Before legalization the shift amount can be any type, but care must be taken to ensure it is large enough. TLI.getShiftAmountTy() is i8 on some targets, but before legalization, types like i1024 can occur and i8 doesn't have enough bits to represent the shift amount. When the 1st operand is a vector, the shift amount must be in the same type. (TLI.getShiftAmountTy() will return the same type when the input type is a vector.) For rotates and funnel shifts, the shift amount is treated as an unsigned amount modulo the element size of the first operand.</p>
<p>Funnel 'double' shifts take 3 operands, 2 inputs and the shift amount. fshl(X,Y,Z): (X &lt;&lt; (Z % BW)) | (Y &gt;&gt; (BW - (Z % BW))) fshr(X,Y,Z): (X &lt;&lt; (BW - (Z % BW))) | (Y &gt;&gt; (Z % BW)) </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a4a055321c361a0f6ee77ed764730ffc1" name="a22ea9cec080dd5f4f47ba234c2f59110a4a055321c361a0f6ee77ed764730ffc1"></a>SRA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a3c6553c8acebe1b57c211ee45e2d8f98" name="a22ea9cec080dd5f4f47ba234c2f59110a3c6553c8acebe1b57c211ee45e2d8f98"></a>SRL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ae8f8f81d8e8d7a557d67622c05786f1d" name="a22ea9cec080dd5f4f47ba234c2f59110ae8f8f81d8e8d7a557d67622c05786f1d"></a>ROTL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a19cd524269b035941434cce28b585715" name="a22ea9cec080dd5f4f47ba234c2f59110a19cd524269b035941434cce28b585715"></a>ROTR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a822b0d02b601898e2d6db5b39e12cc8a" name="a22ea9cec080dd5f4f47ba234c2f59110a822b0d02b601898e2d6db5b39e12cc8a"></a>FSHL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a874350de5b4f6b8f4db13940e17ed81b" name="a22ea9cec080dd5f4f47ba234c2f59110a874350de5b4f6b8f4db13940e17ed81b"></a>FSHR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a19328c462764af5f4699fb1698dad994" name="a22ea9cec080dd5f4f47ba234c2f59110a19328c462764af5f4699fb1698dad994"></a>BSWAP&#160;</td><td class="fielddoc"><p>Byte Swap and Counting operators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a6da41a113af0909470baea7486b3386b" name="a22ea9cec080dd5f4f47ba234c2f59110a6da41a113af0909470baea7486b3386b"></a>CTTZ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110add33c0ae9a63902e573fc1f92fc33f1c" name="a22ea9cec080dd5f4f47ba234c2f59110add33c0ae9a63902e573fc1f92fc33f1c"></a>CTLZ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a991d07d163bd4d9984cf1ef36e92c214" name="a22ea9cec080dd5f4f47ba234c2f59110a991d07d163bd4d9984cf1ef36e92c214"></a>CTPOP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aeea401cc0b7fa5aa6f4d3a0612140e1d" name="a22ea9cec080dd5f4f47ba234c2f59110aeea401cc0b7fa5aa6f4d3a0612140e1d"></a>BITREVERSE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aa47439d20ce0879ea68ca293e018b4f5" name="a22ea9cec080dd5f4f47ba234c2f59110aa47439d20ce0879ea68ca293e018b4f5"></a>PARITY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a601e66a26efd05520f7cb26aef3af340" name="a22ea9cec080dd5f4f47ba234c2f59110a601e66a26efd05520f7cb26aef3af340"></a>CTTZ_ZERO_UNDEF&#160;</td><td class="fielddoc"><p>Bit counting operators with an undefined result for zero inputs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a0340c8d57d1dcebc43a00412989583d3" name="a22ea9cec080dd5f4f47ba234c2f59110a0340c8d57d1dcebc43a00412989583d3"></a>CTLZ_ZERO_UNDEF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a78d0f198115bfe3331ab7cfcf7a40a97" name="a22ea9cec080dd5f4f47ba234c2f59110a78d0f198115bfe3331ab7cfcf7a40a97"></a>SELECT&#160;</td><td class="fielddoc"><p><a class="el" href="AMDGPURegBankSelect_8cpp.html#a14e0c000ed52e5fc187d4a885914cc1a">Select(COND, TRUEVAL, FALSEVAL)</a>. </p>
<p>If the type of the boolean COND is not i1 then the high bits must conform to getBooleanContents. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ab0b7d2c769fd0fbaab3c4a2fc8e7ea0c" name="a22ea9cec080dd5f4f47ba234c2f59110ab0b7d2c769fd0fbaab3c4a2fc8e7ea0c"></a>VSELECT&#160;</td><td class="fielddoc"><p>Select with a vector condition (op #0) and two vector operands (ops #1 and #2), returning a vector result. </p>
<p>All vectors have the same length. Much like the scalar select and setcc, each bit in the condition selects whether the corresponding result element is taken from op #1 or op #2. At first, the VSELECT condition is of vXi1 type. Later, targets may change the condition type in order to match the VSELECT node using a pattern. The condition follows the BooleanContent format of the target. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a99ad6b342b7457df56b91d24e66016b3" name="a22ea9cec080dd5f4f47ba234c2f59110a99ad6b342b7457df56b91d24e66016b3"></a>SELECT_CC&#160;</td><td class="fielddoc"><p>Select with condition operator - This selects between a true value and a false value (ops #2 and #3) based on the boolean result of comparing the lhs and rhs (ops #0 and #1) of a conditional expression with the condition code in op #4, a <a class="el" href="classllvm_1_1CondCodeSDNode.html">CondCodeSDNode</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a0158ee47dfa868be5d28e2cbef70d5d0" name="a22ea9cec080dd5f4f47ba234c2f59110a0158ee47dfa868be5d28e2cbef70d5d0"></a>SETCC&#160;</td><td class="fielddoc"><p>SetCC operator - This evaluates to a true value iff the condition is true. </p>
<p>If the result value type is not i1 then the high bits conform to getBooleanContents. The operands to this are the left and right operands to compare (ops #0, and #1) and the condition code to compare them with (op #2) as a <a class="el" href="classllvm_1_1CondCodeSDNode.html">CondCodeSDNode</a>. If the operands are vector types then the result type must also be a vector type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a6bb33e400f29724907dc27ced04e9038" name="a22ea9cec080dd5f4f47ba234c2f59110a6bb33e400f29724907dc27ced04e9038"></a>SETCCCARRY&#160;</td><td class="fielddoc"><p>Like SetCC, ops #0 and #1 are the LHS and RHS operands to compare, but op #2 is a boolean indicating if there is an incoming carry. </p>
<p>This operator checks the result of "LHS - RHS - Carry", and can be used to compare two wide integers: (setcccarry lhshi rhshi (usubo_carry lhslo rhslo) cc). Only valid for integers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aeb80f9832dad739ee9c6deaa3110d98f" name="a22ea9cec080dd5f4f47ba234c2f59110aeb80f9832dad739ee9c6deaa3110d98f"></a>SHL_PARTS&#160;</td><td class="fielddoc"><p>SHL_PARTS/SRA_PARTS/SRL_PARTS - These operators are used for expanded integer shift operations. </p>
<p>The operation ordering is: [Lo,Hi] = op [LoLHS,HiLHS], Amt </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a78139be59781ad05e1698eb95c58e0b1" name="a22ea9cec080dd5f4f47ba234c2f59110a78139be59781ad05e1698eb95c58e0b1"></a>SRA_PARTS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a9ed8e1dc0db59ab2a071da53ee794759" name="a22ea9cec080dd5f4f47ba234c2f59110a9ed8e1dc0db59ab2a071da53ee794759"></a>SRL_PARTS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a5183f3d72924bc7c77ba8d3f5de9f602" name="a22ea9cec080dd5f4f47ba234c2f59110a5183f3d72924bc7c77ba8d3f5de9f602"></a>SIGN_EXTEND&#160;</td><td class="fielddoc"><p>Conversion operators. </p>
<p>These are all single input single output operations. For all of these, the result type must be strictly wider or narrower (depending on the operation) than the source type. SIGN_EXTEND - Used for integer types, replicating the sign bit into new bits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a93fdf85eff945f1a668b4915a051453e" name="a22ea9cec080dd5f4f47ba234c2f59110a93fdf85eff945f1a668b4915a051453e"></a>ZERO_EXTEND&#160;</td><td class="fielddoc"><p>ZERO_EXTEND - Used for integer types, zeroing the new bits. </p>
<p>Can carry the NonNeg SDNodeFlag to indicate that the input is known to be non-negative. If the flag is present and the input is negative, the result is poison. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a27d5d8ef82302b739ba3ca8be1a5513d" name="a22ea9cec080dd5f4f47ba234c2f59110a27d5d8ef82302b739ba3ca8be1a5513d"></a>ANY_EXTEND&#160;</td><td class="fielddoc"><p>ANY_EXTEND - Used for integer types. The high bits are undefined. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ae690127648393001a7d5b93dc23da7b3" name="a22ea9cec080dd5f4f47ba234c2f59110ae690127648393001a7d5b93dc23da7b3"></a>TRUNCATE&#160;</td><td class="fielddoc"><p>TRUNCATE - Completely drop the high bits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a315004656a75a3c3a9d7294f105a8da2" name="a22ea9cec080dd5f4f47ba234c2f59110a315004656a75a3c3a9d7294f105a8da2"></a>SINT_TO_FP&#160;</td><td class="fielddoc"><p>[SU]INT_TO_FP - These operators convert integers (whose interpreted sign depends on the first letter) to floating point. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a169032eecd015d4eeb869c457202a6c8" name="a22ea9cec080dd5f4f47ba234c2f59110a169032eecd015d4eeb869c457202a6c8"></a>UINT_TO_FP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aaa59dd5ec37f21905436b354c0292d9e" name="a22ea9cec080dd5f4f47ba234c2f59110aaa59dd5ec37f21905436b354c0292d9e"></a>SIGN_EXTEND_INREG&#160;</td><td class="fielddoc"><p>SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to sign extend a small value in a large integer register (e.g. </p>
<p>sign extending the low 8 bits of a 32-bit register to fill the top 24 bits with the 7th bit). The size of the smaller type is indicated by the 1th operand, a ValueType node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110aaa275bf149ab5df1067cfb721936ecbc" name="a22ea9cec080dd5f4f47ba234c2f59110aaa275bf149ab5df1067cfb721936ecbc"></a>ANY_EXTEND_VECTOR_INREG&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110aaa275bf149ab5df1067cfb721936ecbc" title="ANY_EXTEND_VECTOR_INREG(Vector) - This operator represents an in-register any-extension of the low la...">ANY_EXTEND_VECTOR_INREG(Vector)</a> - This operator represents an in-register any-extension of the low lanes of an integer vector. </p>
<p>The result type must have fewer elements than the operand type, and those elements must be larger integer types such that the total size of the operand type is less than or equal to the size of the result type. Each of the low operand elements is any-extended into the corresponding, wider result elements with the high bits becoming undef. NOTE: The type legalizer prefers to make the operand and result size the same to allow expansion to shuffle vector during op legalization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a3893859b5caa079593b9bf91b96e05fb" name="a22ea9cec080dd5f4f47ba234c2f59110a3893859b5caa079593b9bf91b96e05fb"></a>SIGN_EXTEND_VECTOR_INREG&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a3893859b5caa079593b9bf91b96e05fb" title="SIGN_EXTEND_VECTOR_INREG(Vector) - This operator represents an in-register sign-extension of the low ...">SIGN_EXTEND_VECTOR_INREG(Vector)</a> - This operator represents an in-register sign-extension of the low lanes of an integer vector. </p>
<p>The result type must have fewer elements than the operand type, and those elements must be larger integer types such that the total size of the operand type is less than or equal to the size of the result type. Each of the low operand elements is sign-extended into the corresponding, wider result elements. NOTE: The type legalizer prefers to make the operand and result size the same to allow expansion to shuffle vector during op legalization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110adf7f4fc30c272a1987e075d7470df84c" name="a22ea9cec080dd5f4f47ba234c2f59110adf7f4fc30c272a1987e075d7470df84c"></a>ZERO_EXTEND_VECTOR_INREG&#160;</td><td class="fielddoc"><p><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110adf7f4fc30c272a1987e075d7470df84c" title="ZERO_EXTEND_VECTOR_INREG(Vector) - This operator represents an in-register zero-extension of the low ...">ZERO_EXTEND_VECTOR_INREG(Vector)</a> - This operator represents an in-register zero-extension of the low lanes of an integer vector. </p>
<p>The result type must have fewer elements than the operand type, and those elements must be larger integer types such that the total size of the operand type is less than or equal to the size of the result type. Each of the low operand elements is zero-extended into the corresponding, wider result elements. NOTE: The type legalizer prefers to make the operand and result size the same to allow expansion to shuffle vector during op legalization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ac3f8f8d8437c64b2e2e9f978e2707210" name="a22ea9cec080dd5f4f47ba234c2f59110ac3f8f8d8437c64b2e2e9f978e2707210"></a>FP_TO_SINT&#160;</td><td class="fielddoc"><p>FP_TO_[US]INT - Convert a floating point value to a signed or unsigned integer. </p>
<p>These have the same semantics as fptosi and fptoui in IR. If the FP value cannot fit in the integer type, the results are undefined. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a71640703ec096a8b07111e85cfff6987" name="a22ea9cec080dd5f4f47ba234c2f59110a71640703ec096a8b07111e85cfff6987"></a>FP_TO_UINT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ae4a4e2126c6db34e2dfd71b6bd0408ee" name="a22ea9cec080dd5f4f47ba234c2f59110ae4a4e2126c6db34e2dfd71b6bd0408ee"></a>FP_TO_SINT_SAT&#160;</td><td class="fielddoc"><p>FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a signed or unsigned scalar integer type given in operand 1 with the following semantics: </p>
<ul>
<li>If the value is NaN, zero is returned.</li>
<li>If the value is larger/smaller than the largest/smallest integer, the largest/smallest integer is returned (saturation).</li>
<li>Otherwise the result of rounding the value towards zero is returned.</li>
</ul>
<p>The scalar width of the type given in operand 1 must be equal to, or smaller than, the scalar result type width. It may end up being smaller than the result width as a result of integer type legalization.</p>
<p>After converting to the scalar integer type in operand 1, the value is extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT zero extends. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a98661814400e72a77f5ed4e088c06937" name="a22ea9cec080dd5f4f47ba234c2f59110a98661814400e72a77f5ed4e088c06937"></a>FP_TO_UINT_SAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110adaf9a3cb5c2ef5eb713bd6bf4ae23aeb" name="a22ea9cec080dd5f4f47ba234c2f59110adaf9a3cb5c2ef5eb713bd6bf4ae23aeb"></a>FP_ROUND&#160;</td><td class="fielddoc"><p>X = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110adaf9a3cb5c2ef5eb713bd6bf4ae23aeb" title="X = FP_ROUND(Y, TRUNC) - Rounding &#39;Y&#39; from a larger floating point type down to the precision of the ...">FP_ROUND(Y, TRUNC)</a> - Rounding 'Y' from a larger floating point type down to the precision of the destination VT. </p>
<p>TRUNC is a flag, which is always an integer that is zero or one. If TRUNC is 0, this is a normal rounding, if it is 1, this FP_ROUND is known to not change the value of Y.</p>
<p>The TRUNC = 1 case is used in cases where we know that the value will not be modified by the node, because Y is not using any of the extra precision of source type. This allows certain transformations like FP_EXTEND(FP_ROUND(X,1)) -&gt; X which are not safe for FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a89f3afc3fa907ff83759c6c76d97a973" name="a22ea9cec080dd5f4f47ba234c2f59110a89f3afc3fa907ff83759c6c76d97a973"></a>GET_ROUNDING&#160;</td><td class="fielddoc"><p>Returns current rounding mode: -1 Undefined 0 Round to 0 1 Round to nearest, ties to even 2 Round to +inf 3 Round to -inf 4 Round to nearest, ties to zero Other values are target dependent. </p>
<p>Result is rounding mode and chain. Input is a chain. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a041c4b27006496ee8d8bcdf72e248632" name="a22ea9cec080dd5f4f47ba234c2f59110a041c4b27006496ee8d8bcdf72e248632"></a>CONVERGENCECTRL_ANCHOR&#160;</td><td class="fielddoc"><p>Set rounding mode. </p>
<p>The first operand is a chain pointer. The second specifies the required rounding mode, encoded in the same way as used in '<code>GET_ROUNDING</code>'. SET_ROUNDING,</p>
<p>/ X = FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type. FP_EXTEND,</p>
<p>/ BITCAST - This operator converts between integer, vector and FP / values, as if the value was stored to memory with one type and loaded / from the same address with the other type (or equivalently for vector / format conversions, etc). The source and result are required to have / the same bit size (e.g. f32 &lt;-&gt; i32). This can also be used for / int-to-int or fp-to-fp conversions, but that is a noop, deleted by / <a class="el" href="AMDGPUDelayedMCExpr_8cpp.html#a3b9e43a5529fa7d4adb2bad70198c9bd">getNode()</a>. / / This operator is subtly different from the bitcast instruction from / LLVM-IR since this node may change the bits in the register. For / example, this occurs on big-endian NEON and big-endian MSA where the / layout of the bits in the register depends on the vector type and this / operator acts as a shuffle operation for some vector type combinations. BITCAST,</p>
<p>/ ADDRSPACECAST - This operator converts between pointers of different / address spaces. ADDRSPACECAST,</p>
<p>/ FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions / and truncation for half-precision (16 bit) floating numbers. These nodes / form a semi-softened interface for dealing with f16 (as an i16), which / is often a storage-only type but has native conversions. FP16_TO_FP, FP_TO_FP16, STRICT_FP16_TO_FP, STRICT_FP_TO_FP16,</p>
<p>/ BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions / and truncation for bfloat16. These nodes form a semi-softened interface / for dealing with bf16 (as an i16), which is often a storage-only type but / has native conversions. BF16_TO_FP, FP_TO_BF16, STRICT_BF16_TO_FP, STRICT_FP_TO_BF16,</p>
<p>/ Perform various unary floating-point operations inspired by libm. For / FPOWI, the result is undefined if the integer operand doesn't fit into / sizeof(int). FNEG, FABS, FSQRT, FCBRT, FSIN, FCOS, FTAN, FASIN, FACOS, FATAN, FSINH, FCOSH, FTANH, FPOW, FPOWI, / FLDEXP - ldexp, inspired by libm (op0 * 2**op1). FLDEXP,</p>
<p>/ FFREXP - frexp, extract fractional and exponent component of a / floating-point value. Returns the two components as separate return / values. FFREXP,</p>
<p>FLOG, FLOG2, FLOG10, FEXP, FEXP2, FEXP10, FCEIL, FTRUNC, FRINT, FNEARBYINT, FROUND, FROUNDEVEN, FFLOOR, LROUND, LLROUND, LRINT, LLRINT,</p>
<p>/ FMINNUM/FMAXNUM - Perform floating-point minimum or maximum on two / values.</p>
<p>/ In the case where a single input is a NaN (either signaling or quiet), / the non-NaN input is returned. / / The return value of (FMINNUM 0.0, -0.0) could be either 0.0 or -0.0. FMINNUM, FMAXNUM,</p>
<p>/ FMINNUM_IEEE/FMAXNUM_IEEE - Perform floating-point minimumNumber or / maximumNumber on two values, following IEEE-754 definitions. This differs / from FMINNUM/FMAXNUM in the handling of signaling NaNs, and signed zero. / / If one input is a signaling NaN, returns a quiet NaN. This matches / IEEE-754 2008's minnum/maxnum behavior for signaling NaNs (which differs / from 2019). / / These treat -0 as ordered less than +0, matching the behavior of IEEE-754 / 2019's minimumNumber/maximumNumber. FMINNUM_IEEE, FMAXNUM_IEEE,</p>
<p>/ FMINIMUM/FMAXIMUM - NaN-propagating minimum/maximum that also treat -0.0 / as less than 0.0. While FMINNUM_IEEE/FMAXNUM_IEEE follow IEEE 754-2008 / semantics, FMINIMUM/FMAXIMUM follow IEEE 754-2019 semantics. FMINIMUM, FMAXIMUM,</p>
<p>/ FSINCOS - Compute both fsin and fcos as a single operation. FSINCOS,</p>
<p>/ Gets the current floating-point environment. The first operand is a token / chain. The results are FP environment, represented by an integer value, / and a token chain. GET_FPENV,</p>
<p>/ Sets the current floating-point environment. The first operand is a token / chain, the second is FP environment, represented by an integer value. The / result is a token chain. SET_FPENV,</p>
<p>/ Set floating-point environment to default state. The first operand and the / result are token chains. RESET_FPENV,</p>
<p>/ Gets the current floating-point environment. The first operand is a token / chain, the second is a pointer to memory, where FP environment is stored / to. The result is a token chain. GET_FPENV_MEM,</p>
<p>/ Sets the current floating point environment. The first operand is a token / chain, the second is a pointer to memory, where FP environment is loaded / from. The result is a token chain. SET_FPENV_MEM,</p>
<p>/ Reads the current dynamic floating-point control modes. The operand is / a token chain. GET_FPMODE,</p>
<p>/ Sets the current dynamic floating-point control modes. The first operand / is a token chain, the second is control modes set represented as integer / value. SET_FPMODE,</p>
<p>/ Sets default dynamic floating-point control modes. The operand is a / token chain. RESET_FPMODE,</p>
<p>/ LOAD and STORE have token chains as their first operand, then the same / operands as an LLVM load/store instruction, then an offset node that / is added / subtracted from the base pointer to form the address (for / indexed memory ops). LOAD, STORE,</p>
<p>/ DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned / to a specified boundary. This node always has two return values: a new / stack pointer value and a chain. The first operand is the token chain, / the second is the number of bytes to allocate, and the third is the / alignment boundary. The size is guaranteed to be a multiple of the / stack alignment, and the alignment is guaranteed to be bigger than the / stack alignment (if required) or 0 to get standard stack alignment. DYNAMIC_STACKALLOC,</p>
<p>/ Control flow instructions. These all have token chains.</p>
<p>/ BR - Unconditional branch. The first operand is the chain / operand, the second is the MBB to branch to. BR,</p>
<p>/ BRIND - Indirect branch. The first operand is the chain, the second / is the value to branch to, which must be of the same type as the / target's pointer type. BRIND,</p>
<p>/ BR_JT - Jumptable branch. The first operand is the chain, the second / is the jumptable index, the last one is the jumptable entry index. BR_JT,</p>
<p>/ JUMP_TABLE_DEBUG_INFO - Jumptable debug info. The first operand is the / chain, the second is the jumptable index. JUMP_TABLE_DEBUG_INFO,</p>
<p>/ BRCOND - Conditional branch. The first operand is the chain, the / second is the condition, the third is the block to branch to if the / condition is true. If the type of the condition is not i1, then the / high bits must conform to getBooleanContents. If the condition is undef, / it nondeterministically jumps to the block. / TODO: Its semantics w.r.t undef requires further discussion; we need to / make it sure that it is consistent with optimizations in MIR &amp; the / meaning of IMPLICIT_DEF. See <a href="https://reviews.llvm.org/D92015">https://reviews.llvm.org/D92015</a> BRCOND,</p>
<p>/ BR_CC - Conditional branch. The behavior is like that of SELECT_CC, in / that the condition is represented as condition code, and two nodes to / compare, rather than as a combined SetCC node. The operands in order / are chain, cc, lhs, rhs, block to branch to if condition is true. If / condition is undef, it nondeterministically jumps to the block. BR_CC,</p>
<p>/ INLINEASM - Represents an inline asm block. This node always has two / return values: a chain and a flag result. The inputs are as follows: / Operand #0 : Input chain. / Operand #1 : a <a class="el" href="classllvm_1_1ExternalSymbolSDNode.html">ExternalSymbolSDNode</a> with a pointer to the asm string. / Operand #2 : a <a class="el" href="classllvm_1_1MDNodeSDNode.html">MDNodeSDNode</a> with the !srcloc metadata. / Operand #3 : HasSideEffect, IsAlignStack bits. / After this, it is followed by a list of operands with this format: / <a class="el" href="classllvm_1_1ConstantSDNode.html">ConstantSDNode</a>: Flags that encode whether it is a mem or not, the / of operands that follow, etc. See <a class="el" href="InlineAsm_8h.html">InlineAsm.h</a>. / ... however many operands ... / Operand #last: Optional, an incoming flag. / / The variable width operands are required to represent target addressing / modes as a single "operand", even though they may have multiple / SDOperands. INLINEASM,</p>
<p>/ INLINEASM_BR - Branching version of inline asm. Used by asm-goto. INLINEASM_BR,</p>
<p>/ EH_LABEL - Represents a label in mid basic block used to track / locations needed for debug and exception handling tables. These nodes / take a chain as input and return a chain. EH_LABEL,</p>
<p>/ ANNOTATION_LABEL - Represents a mid basic block label used by / annotations. This should remain within the basic block and be ordered / with respect to other call instructions, but loads and stores may float / past it. ANNOTATION_LABEL,</p>
<p>/ CATCHRET - Represents a return from a catch block funclet. Used for / MSVC compatible exception handling. Takes a chain operand and a / destination basic block operand. CATCHRET,</p>
<p>/ CLEANUPRET - Represents a return from a cleanup block funclet. Used for / MSVC compatible exception handling. Takes only a chain operand. CLEANUPRET,</p>
<p>/ STACKSAVE - STACKSAVE has one operand, an input chain. It produces a / value, the same type as the pointer type for the system, and an output / chain. STACKSAVE,</p>
<p>/ STACKRESTORE has two operands, an input chain and a pointer to restore / to it returns an output chain. STACKRESTORE,</p>
<p>/ CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end / of a call sequence, and carry arbitrary information that target might / want to know. The first operand is a chain, the rest are specified by / the target and not touched by the DAG optimizers. / Targets that may use stack to pass call arguments define additional / operands: / - size of the call frame part that must be set up within the / CALLSEQ_START..CALLSEQ_END pair, / - part of the call frame prepared prior to CALLSEQ_START. / Both these parameters must be constants, their sum is the total call / frame size. / CALLSEQ_START..CALLSEQ_END pairs may not be nested. CALLSEQ_START, // Beginning of a call sequence CALLSEQ_END, // End of a call sequence</p>
<p>/ VAARG - VAARG has four operands: an input chain, a pointer, a SRCVALUE, / and the alignment. It returns a pair of values: the vaarg value and a / new chain. VAARG,</p>
<p>/ VACOPY - VACOPY has 5 operands: an input chain, a destination pointer, / a source pointer, a SRCVALUE for the destination, and a SRCVALUE for the / source. VACOPY,</p>
<p>/ VAEND, VASTART - VAEND and VASTART have three operands: an input chain, / pointer, and a SRCVALUE. VAEND, VASTART,</p>
<p>PREALLOCATED_SETUP - This has 2 operands: an input chain and a SRCVALUE with the preallocated call <a class="el" href="classllvm_1_1Value.html" title="LLVM Value Representation.">Value</a>. PREALLOCATED_SETUP, PREALLOCATED_ARG - This has 3 operands: an input chain, a SRCVALUE with the preallocated call <a class="el" href="classllvm_1_1Value.html" title="LLVM Value Representation.">Value</a>, and a constant int. PREALLOCATED_ARG,</p>
<p>/ SRCVALUE - This is a node type that holds a Value* that is used to / make reference to a value in the LLVM IR. SRCVALUE,</p>
<p>/ MDNODE_SDNODE - This is a node that holdes an MDNode*, which is used to / reference metadata in the IR. MDNODE_SDNODE,</p>
<p>/ PCMARKER - This corresponds to the pcmarker intrinsic. PCMARKER,</p>
<p>/ READCYCLECOUNTER - This corresponds to the readcyclecounter intrinsic. / It produces a chain and one i64 value. The only operand is a chain. / If i64 is not legal, the result will be expanded into smaller values. / Still, it returns an i64, so targets should set legality for i64. / The result is the content of the architecture-specific cycle / counter-like register (or other high accuracy low latency clock source). READCYCLECOUNTER,</p>
<p>/ READSTEADYCOUNTER - This corresponds to the readfixedcounter intrinsic. / It has the same semantics as the READCYCLECOUNTER implementation except / that the result is the content of the architecture-specific fixed / frequency counter suitable for measuring elapsed time. READSTEADYCOUNTER,</p>
<p>/ HANDLENODE node - Used as a handle for various purposes. HANDLENODE,</p>
<p>/ INIT_TRAMPOLINE - This corresponds to the init_trampoline intrinsic. It / takes as input a token chain, the pointer to the trampoline, the pointer / to the nested function, the pointer to pass for the 'nest' parameter, a / SRCVALUE for the trampoline and another for the nested function / (allowing targets to access the original Function*). / It produces a token chain as output. INIT_TRAMPOLINE,</p>
<p>/ ADJUST_TRAMPOLINE - This corresponds to the adjust_trampoline intrinsic. / It takes a pointer to the trampoline and produces a (possibly) new / pointer to the same trampoline with platform-specific adjustments / applied. The pointer it returns points to an executable block of code. ADJUST_TRAMPOLINE,</p>
<p>/ TRAP - Trapping instruction TRAP,</p>
<p>/ DEBUGTRAP - Trap intended to get the attention of a debugger. DEBUGTRAP,</p>
<p>/ UBSANTRAP - Trap with an immediate describing the kind of sanitizer / failure. UBSANTRAP,</p>
<p>/ PREFETCH - This corresponds to a prefetch intrinsic. The first operand / is the chain. The other operands are the address to prefetch, / read / write specifier, locality specifier and instruction / data cache / specifier. PREFETCH,</p>
<p>/ ARITH_FENCE - This corresponds to a arithmetic fence intrinsic. Both its / operand and output are the same floating type. ARITH_FENCE,</p>
<p>/ MEMBARRIER - Compiler barrier only; generate a no-op. MEMBARRIER,</p>
<p>/ OUTCHAIN = ATOMIC_FENCE(INCHAIN, ordering, scope) / This corresponds to the fence instruction. It takes an input chain, and / two integer constants: an AtomicOrdering and a SynchronizationScope. ATOMIC_FENCE,</p>
<p>/ Val, OUTCHAIN = ATOMIC_LOAD(INCHAIN, ptr) / This corresponds to "load atomic" instruction. ATOMIC_LOAD,</p>
<p>/ OUTCHAIN = ATOMIC_STORE(INCHAIN, ptr, val) / This corresponds to "store atomic" instruction. ATOMIC_STORE,</p>
<p>/ Val, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmp, swap) / For double-word atomic operations: / ValLo, ValHi, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmpLo, cmpHi, / swapLo, swapHi) / This corresponds to the cmpxchg instruction. ATOMIC_CMP_SWAP,</p>
<p>/ Val, Success, OUTCHAIN / = ATOMIC_CMP_SWAP_WITH_SUCCESS(INCHAIN, ptr, cmp, swap) / N.b. this is still a strong cmpxchg operation, so / Success == "Val == cmp". ATOMIC_CMP_SWAP_WITH_SUCCESS,</p>
<p>/ Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) / Val, OUTCHAIN = ATOMIC_LOAD_[<a class="el" href="namespaceOpName.html">OpName</a>](INCHAIN, ptr, amt) / For double-word atomic operations: / ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) / ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[<a class="el" href="namespaceOpName.html">OpName</a>](INCHAIN, ptr, amtLo, amtHi) / These correspond to the atomicrmw instruction. ATOMIC_SWAP, ATOMIC_LOAD_ADD, ATOMIC_LOAD_SUB, ATOMIC_LOAD_AND, ATOMIC_LOAD_CLR, ATOMIC_LOAD_OR, ATOMIC_LOAD_XOR, ATOMIC_LOAD_NAND, ATOMIC_LOAD_MIN, ATOMIC_LOAD_MAX, ATOMIC_LOAD_UMIN, ATOMIC_LOAD_UMAX, ATOMIC_LOAD_FADD, ATOMIC_LOAD_FSUB, ATOMIC_LOAD_FMAX, ATOMIC_LOAD_FMIN, ATOMIC_LOAD_UINC_WRAP, ATOMIC_LOAD_UDEC_WRAP,</p>
<p>Masked load and store - consecutive vector load and store operations with additional mask operand that prevents memory accesses to the masked-off lanes.</p>
<p>Val, OutChain = MLOAD(BasePtr, Mask, PassThru) OutChain = MSTORE(Value, BasePtr, Mask) MLOAD, MSTORE,</p>
<p>Masked gather and scatter - load and store operations for a vector of random addresses with additional mask operand that prevents memory accesses to the masked-off lanes.</p>
<p>Val, OutChain = <a class="el" href="namespacellvm.html#ad98783229b874cc80970a2f3aa495caaaae7890e198f938a5cfe2ac4c528c4ac7">GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale)</a> OutChain = <a class="el" href="namespacellvm.html#ad98783229b874cc80970a2f3aa495caaa635984b0013f45af313b83be0011e523">SCATTER(InChain, Value, Mask, BasePtr, Index, Scale)</a></p>
<p>The Index operand can have more vector elements than the other operands due to type legalization. The extra elements are ignored. MGATHER, MSCATTER,</p>
<p>/ This corresponds to the llvm.lifetime.* intrinsics. The first operand / is the chain and the second operand is the alloca pointer. LIFETIME_START, LIFETIME_END,</p>
<p>/ GC_TRANSITION_START/GC_TRANSITION_END - These operators mark the / beginning and end of GC transition sequence, and carry arbitrary / information that target might need for lowering. The first operand is / a chain, the rest are specified by the target and not touched by the DAG / optimizers. GC_TRANSITION_START..GC_TRANSITION_END pairs may not be / nested. GC_TRANSITION_START, GC_TRANSITION_END,</p>
<p>/ GET_DYNAMIC_AREA_OFFSET - get offset from native SP to the address of / the most recent dynamic alloca. For most targets that would be 0, but / for some others (e.g. PowerPC, PowerPC64) that would be compile-time / known nonzero constant. The only operand here is the chain. GET_DYNAMIC_AREA_OFFSET,</p>
<p>/ Pseudo probe for AutoFDO, as a place holder in a basic block to improve / the sample counts quality. PSEUDO_PROBE,</p>
<p>/ VSCALE(IMM) - Returns the runtime scaling factor used to calculate the / number of elements within a scalable vector. IMM is a constant integer / multiplier that is applied to the runtime value. VSCALE,</p>
<p>/ Generic reduction nodes. These nodes represent horizontal vector / reduction operations, producing a scalar result. / The SEQ variants perform reductions in sequential order. The first / operand is an initial scalar accumulator value, and the second operand / is the vector to reduce. / E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, &lt;4 x f32&gt; SRC_VEC / ... is equivalent to / RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3] VECREDUCE_SEQ_FADD, VECREDUCE_SEQ_FMUL,</p>
<p>/ These reductions have relaxed evaluation order semantics, and have a / single vector operand. The order of evaluation is unspecified. For / pow-of-2 vectors, one valid legalizer expansion is to use a tree / reduction, i.e.: / For RES = VECREDUCE_FADD &lt;8 x f16&gt; SRC_VEC / PART_RDX = FADD SRC_VEC[0:3], SRC_VEC[4:7] / PART_RDX2 = FADD PART_RDX[0:1], PART_RDX[2:3] / RES = FADD PART_RDX2[0], PART_RDX2[1] / For non-pow-2 vectors, this can be computed by extracting each element / and performing the operation as if it were scalarized. VECREDUCE_FADD, VECREDUCE_FMUL, / FMIN/FMAX nodes can have flags, for NaN/NoNaN variants. VECREDUCE_FMAX, VECREDUCE_FMIN, / FMINIMUM/FMAXIMUM nodes propatate NaNs and signed zeroes using the / <a class="el" href="namespacellvm.html#ae2f7e8a5325f48bbbdaec78e5d6c320c" title="Implements IEEE 754-2019 minimum semantics.">llvm.minimum</a> and <a class="el" href="namespacellvm.html#a38dcdde63d81fbda1d22dffd1a27b343" title="Implements IEEE 754-2019 maximum semantics.">llvm.maximum</a> semantics. VECREDUCE_FMAXIMUM, VECREDUCE_FMINIMUM, / Integer reductions may have a result type larger than the vector element / type. However, the reduction is performed using the vector element type / and the value in the top bits is unspecified. VECREDUCE_ADD, VECREDUCE_MUL, VECREDUCE_AND, VECREDUCE_OR, VECREDUCE_XOR, VECREDUCE_SMAX, VECREDUCE_SMIN, VECREDUCE_UMAX, VECREDUCE_UMIN,</p>
<p>The <code>llvm.experimental.stackmap</code> intrinsic. Operands: input chain, glue, &lt;id&gt;, &lt;numShadowBytes&gt;, [live0[, live1...]] Outputs: output chain, glue STACKMAP,</p>
<p>The <code>llvm.experimental.patchpoint.*</code> intrinsic. Operands: input chain, [glue], reg-mask, &lt;id&gt;, &lt;numShadowBytes&gt;, callee, &lt;numArgs&gt;, cc, ... Outputs: [rv], output chain, glue PATCHPOINT,</p>
<p>Vector Predication #define <a class="el" href="ISDOpcodes_8h.html#a702652b3014f083e39ba0426207678e6">BEGIN_REGISTER_VP_SDNODE(VPSDID, ...)</a> <br  />
</p>
<p>The <code>llvm.experimental.convergence.*</code> intrinsics. </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a5a787d44a3bcbc803d314896056d9569" name="a22ea9cec080dd5f4f47ba234c2f59110a5a787d44a3bcbc803d314896056d9569"></a>CONVERGENCECTRL_ENTRY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110adef60c4df07ee437cd2714f7b18f93f2" name="a22ea9cec080dd5f4f47ba234c2f59110adef60c4df07ee437cd2714f7b18f93f2"></a>CONVERGENCECTRL_LOOP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a509e81081ec1935d3f4f0df758c60e0f" name="a22ea9cec080dd5f4f47ba234c2f59110a509e81081ec1935d3f4f0df758c60e0f"></a>CONVERGENCECTRL_GLUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110ae243ce466d350b1aca774a6ae9aea81c" name="a22ea9cec080dd5f4f47ba234c2f59110ae243ce466d350b1aca774a6ae9aea81c"></a>EXPERIMENTAL_VECTOR_HISTOGRAM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110addc63b0e91a7c2b397e7908052d8caf9" name="a22ea9cec080dd5f4f47ba234c2f59110addc63b0e91a7c2b397e7908052d8caf9"></a>CLEAR_CACHE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a22ea9cec080dd5f4f47ba234c2f59110a477ef80c70c7359199eace0e5d3133b1" name="a22ea9cec080dd5f4f47ba234c2f59110a477ef80c70c7359199eace0e5d3133b1"></a>BUILTIN_OP_END&#160;</td><td class="fielddoc"><p>BUILTIN_OP_END - This must be the last enum value in this list. </p>
<p>The target-specific pre-isel opcode values start here. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l00040">40</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a933d79e63e855d7c90bf161355c008ec" name="a933d79e63e855d7c90bf161355c008ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933d79e63e855d7c90bf161355c008ec">&#9670;&#160;</a></span>allOperandsUndef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::allOperandsUndef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the node has at least one operand and all operands of the specified node are <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a7c6d8f265e9e16e5debdb9a536b55d3d" title="UNDEF - An undefined node.">ISD::UNDEF</a>. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00342">342</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="STLExtras_8h_source.html#l01722">llvm::all_of()</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVPTXISelLowering_8cpp_source.html#l05887">PerformEXTRACTCombine()</a>.</p>

</div>
</div>
<a id="a67022d78a6d8ee4377558da9ff259b8b" name="a67022d78a6d8ee4377558da9ff259b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67022d78a6d8ee4377558da9ff259b8b">&#9670;&#160;</a></span>getBaseOpcodeForVP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; llvm::ISD::getBaseOpcodeForVP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>hasFPExcept</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate this VP Opcode to its corresponding non-VP Opcode. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00540">540</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

</div>
</div>
<a id="a2fdb5c9abf8403d4dbf0d8ae59d89916" name="a2fdb5c9abf8403d4dbf0d8ae59d89916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdb5c9abf8403d4dbf0d8ae59d89916">&#9670;&#160;</a></span>getExtForLoadExtType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110">ISD::NodeType</a> llvm::ISD::getExtForLoadExtType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsFP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad4d48171b87ca51ff54c10a436bac4d7">ISD::LoadExtType</a></td>          <td class="paramname"><span class="paramname"><em>ExtType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00565">565</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00811">ANY_EXTEND</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01554">EXTLOAD</a>, <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01554">SEXTLOAD</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00802">SIGN_EXTEND</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00808">ZERO_EXTEND</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01554">ZEXTLOAD</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetLowering_8cpp_source.html#l09619">llvm::TargetLowering::scalarizeVectorLoad()</a>.</p>

</div>
</div>
<a id="a06081b690c5f0c0be1e6c520585c2b5c" name="a06081b690c5f0c0be1e6c520585c2b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06081b690c5f0c0be1e6c520585c2b5c">&#9670;&#160;</a></span>getSetCCAndOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">ISD::CondCode</a> llvm::ISD::getSetCCAndOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">ISD::CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Op1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">ISD::CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Op2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1EVT.html">EVT</a></td>          <td class="paramname"><span class="paramname"><em>Type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result of a logical AND between different comparisons of identical values: ((X op1 Y) &amp; (X op2 Y)). </p>
<p>This function returns SETCC_INVALID if it is not possible to represent the resultant comparison. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00652">652</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="SelectionDAG_8cpp_source.html#l00615">isSignedOp()</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01602">SETCC_INVALID</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01594">SETEQ</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01576">SETFALSE</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01577">SETOEQ</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01578">SETOGT</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01580">SETOLT</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01585">SETUEQ</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01586">SETUGT</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01588">SETULT</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01584">SETUO</a>.</p>

</div>
</div>
<a id="a5fbc38db5c4f3ef878ab19245d3f381d" name="a5fbc38db5c4f3ef878ab19245d3f381d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbc38db5c4f3ef878ab19245d3f381d">&#9670;&#160;</a></span>getSetCCInverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">ISD::CondCode</a> llvm::ISD::getSetCCInverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">ISD::CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1EVT.html">EVT</a></td>          <td class="paramname"><span class="paramname"><em>Type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the operation corresponding to !(X op Y), where 'op' is a valid SetCC operation. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00603">603</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="SelectionDAG_8cpp_source.html#l00590">getSetCCInverseImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RISCVISelLowering_8cpp_source.html#l15772">combine_CC()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l13446">combineSubOfBoolean()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l45452">combineVSelectWithAllOnesOrZeros()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l45816">commuteSelect()</a>, <a class="el" href="SystemZISelLowering_8cpp_source.html#l03252">getVectorComparisonOrInvert()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l07534">matchSetCC()</a>, <a class="el" href="R600ISelLowering_8cpp_source.html#l01716">llvm::R600TargetLowering::PerformDAGCombine()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16654">llvm::RISCVTargetLowering::PerformDAGCombine()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l18220">PerformHWLoopCombine()</a>, <a class="el" href="MipsISelLowering_8cpp_source.html#l00685">performSELECTCombine()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l19797">performSetccAddFolding()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l13789">performXORCombine()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l04458">llvm::TargetLowering::SimplifySetCC()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l15713">tryDemorganOfBooleanCondition()</a>, and <a class="el" href="AArch64ISelLowering_8cpp_source.html#l24161">trySwapVSelectOperands()</a>.</p>

</div>
</div>
<a id="af1bf9aaeb72d421a1ef57a1a1e6fac92" name="af1bf9aaeb72d421a1ef57a1a1e6fac92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bf9aaeb72d421a1ef57a1a1e6fac92">&#9670;&#160;</a></span>getSetCCOrOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">ISD::CondCode</a> llvm::ISD::getSetCCOrOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">ISD::CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Op1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">ISD::CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Op2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1EVT.html">EVT</a></td>          <td class="paramname"><span class="paramname"><em>Type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the result of a logical OR between different comparisons of identical values: ((X op1 Y) | (X op2 Y)). </p>
<p>This function returns SETCC_INVALID if it is not possible to represent the resultant comparison. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00631">631</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="SelectionDAG_8cpp_source.html#l00615">isSignedOp()</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01602">SETCC_INVALID</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01599">SETNE</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01600">SETTRUE2</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01590">SETUNE</a>.</p>

</div>
</div>
<a id="a9cc23aed232ccdeadbd8648c349236a6" name="a9cc23aed232ccdeadbd8648c349236a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc23aed232ccdeadbd8648c349236a6">&#9670;&#160;</a></span>getSetCCSwappedOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">ISD::CondCode</a> llvm::ISD::getSetCCSwappedOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">ISD::CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Operation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the operation corresponding to (Y op X) when given the operation for (X op Y). </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00580">580</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="PPCReduceCRLogicals_8cpp_source.html#l00735">Operation</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l54197">combineSetCC()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l06144">foldAndOrOfSETCC()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l02527">llvm::SelectionDAG::FoldSetCC()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l03839">getAArch64Cmp()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l11535">llvm::TargetLowering::LegalizeSetCCCondCode()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l23127">LowerIntVSETCC_AVX512()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l06242">llvm::RISCVTargetLowering::LowerOperation()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l07534">matchSetCC()</a>, <a class="el" href="BPFISelLowering_8cpp_source.html#l00613">NegateCC()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l04458">llvm::TargetLowering::SimplifySetCC()</a>, and <a class="el" href="RISCVISelLowering_8cpp_source.html#l02386">translateSetCCForBranch()</a>.</p>

</div>
</div>
<a id="a7cfab76369f71a9f62a02815c5aa0777" name="a7cfab76369f71a9f62a02815c5aa0777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfab76369f71a9f62a02815c5aa0777">&#9670;&#160;</a></span>getUnorderedFlavor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> llvm::ISD::getUnorderedFlavor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Cond</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns 0 if the condition is always false if an operand is a NaN, 1 if the condition is always true if the operand is a NaN, and 2 if the condition is undefined if the operand is a NaN. </p>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01637">1637</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">References <a class="el" href="RISCVRedundantCopyElimination_8cpp_source.html#l00075">Cond</a>.</p>

<p class="reference">Referenced by <a class="el" href="SelectionDAG_8cpp_source.html#l02527">llvm::SelectionDAG::FoldSetCC()</a>, and <a class="el" href="TargetLowering_8cpp_source.html#l04458">llvm::TargetLowering::SimplifySetCC()</a>.</p>

</div>
</div>
<a id="ace75a0fc6736a8bf8b8187083078354d" name="ace75a0fc6736a8bf8b8187083078354d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace75a0fc6736a8bf8b8187083078354d">&#9670;&#160;</a></span>getVecReduceBaseOpcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110">ISD::NodeType</a> llvm::ISD::getVecReduceBaseOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>VecReduceOpcode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get underlying scalar opcode for VECREDUCE opcode. </p>
<p>For example <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ac513a7da1bf74fb3e3c594da8534f2d2" title="Bitwise operators - logical and, logical or, logical xor.">ISD::AND</a> for ISD::VECREDUCE_AND. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00425">425</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00246">ADD</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00708">AND</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00397">FADD</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00399">FMUL</a>, <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00248">MUL</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00709">OR</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00697">SMAX</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00696">SMIN</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00699">UMAX</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00698">UMIN</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l00710">XOR</a>.</p>

<p class="reference">Referenced by <a class="el" href="RISCVISelLowering_8cpp_source.html#l12944">combineBinOpOfExtractToReduceTree()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l11037">llvm::TargetLowering::expandVecReduce()</a>, and <a class="el" href="TargetLowering_8cpp_source.html#l11077">llvm::TargetLowering::expandVecReduceSeq()</a>.</p>

</div>
</div>
<a id="a8d086c45b7e89dc21157d97b9fc150a5" name="a8d086c45b7e89dc21157d97b9fc150a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d086c45b7e89dc21157d97b9fc150a5">&#9670;&#160;</a></span>getVPExplicitVectorLengthIdx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; llvm::ISD::getVPExplicitVectorLengthIdx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operand position of the explicit vector length parameter. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00529">529</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VECustomDAG_8cpp_source.html#l00166">llvm::getAVLPos()</a>, <a class="el" href="VVPISelLowering_8cpp_source.html#l00038">llvm::VETargetLowering::lowerToVVP()</a>, and <a class="el" href="RISCVISelLowering_8cpp_source.html#l06161">SplitVPOp()</a>.</p>

</div>
</div>
<a id="a2e29f855114c8d578b8d3acc09abe71a" name="a2e29f855114c8d578b8d3acc09abe71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e29f855114c8d578b8d3acc09abe71a">&#9670;&#160;</a></span>getVPForBaseOpcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> llvm::ISD::getVPForBaseOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate this non-VP Opcode to its corresponding VP Opcode. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00554">554</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>.</p>

</div>
</div>
<a id="a7437e83b31f58ab47107029f63bd70b0" name="a7437e83b31f58ab47107029f63bd70b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7437e83b31f58ab47107029f63bd70b0">&#9670;&#160;</a></span>getVPMaskIdx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; llvm::ISD::getVPMaskIdx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operand position of the vector mask. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00517">517</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VECustomDAG_8cpp_source.html#l00191">llvm::getMaskPos()</a>, and <a class="el" href="VVPISelLowering_8cpp_source.html#l00038">llvm::VETargetLowering::lowerToVVP()</a>.</p>

</div>
</div>
<a id="a6b220b2107d211a5db501de58981e214" name="a6b220b2107d211a5db501de58981e214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b220b2107d211a5db501de58981e214">&#9670;&#160;</a></span>isBitwiseLogicOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isBitwiseLogicOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this is bitwise logic opcode. </p>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01466">1466</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00708">AND</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00709">OR</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l00710">XOR</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l54486">combineMOVMSK()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l48682">combineVectorShiftImm()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l10278">foldBitOrderCrossLogicOp()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l06853">foldLogicOfShifts()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l06901">foldLogicTreeOfShifts()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l02679">isLogicOp()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l49098">PromoteMaskArithmetic()</a>, and <a class="el" href="FastISel_8cpp_source.html#l00444">llvm::FastISel::selectBinaryOp()</a>.</p>

</div>
</div>
<a id="ac78d4df51ca05e4fb1630a01e07de434" name="ac78d4df51ca05e4fb1630a01e07de434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78d4df51ca05e4fb1630a01e07de434">&#9670;&#160;</a></span>isBuildVectorAllOnes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isBuildVectorAllOnes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified node is a BUILD_VECTOR where all of the elements are ~0 or undef. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00271">271</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="SelectionDAG_8cpp_source.html#l00180">isConstantSplatVectorAllOnes()</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l40476">canonicalizeShuffleWithOp()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l43357">checkBitcastSrcVectorSize()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l53454">combineAndnp()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l56980">combineEXTRACT_SUBVECTOR()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l53214">combineFAndFNotToFAndn()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l54486">combineMOVMSK()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l50626">combineOrXorWithSETCC()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l46811">combinePTESTCC()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l45847">combineSelect()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l48682">combineVectorShiftImm()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l45452">combineVSelectWithAllOnesOrZeros()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l39693">combineX86ShufflesRecursively()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l53034">combineXor()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l27262">convertFixedMaskToScalableVector()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l17601">foldVectorXorShiftIntoCmp()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l50893">foldVectorXorShiftIntoCmp()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l26489">getAVX2GatherNode()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l26521">getGatherNode()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l05106">IsNOT()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l07626">LowerBUILD_VECTORvXi1()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l03619">lowerBuildVectorOfConstants()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l23240">LowerVSETCC()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l08428">materializeVectorConstant()</a>, and <a class="el" href="MipsSEISelLowering_8cpp_source.html#l00997">performXORCombine()</a>.</p>

</div>
</div>
<a id="aaac3e239cbdfe15a8e9bad4f8e1e3a95" name="aaac3e239cbdfe15a8e9bad4f8e1e3a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac3e239cbdfe15a8e9bad4f8e1e3a95">&#9670;&#160;</a></span>isBuildVectorAllZeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isBuildVectorAllZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified node is a BUILD_VECTOR where all of the elements are 0 or undef. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00275">275</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="SelectionDAG_8cpp_source.html#l00229">isConstantSplatVectorAllZeros()</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l43399">adjustBitcastSrcVectorSSE1()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l40476">canonicalizeShuffleWithOp()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l43357">checkBitcastSrcVectorSize()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l55768">combineAdd()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l53454">combineAndnp()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l43855">combineBitcast()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l43464">combineBitcastvxi1()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l56068">combineConcatVectorOps()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l56980">combineEXTRACT_SUBVECTOR()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l52203">combineFaddCFmul()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l56769">combineINSERT_SUBVECTOR()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l57443">combineKSHIFT()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l45770">combineLogicBlendIntoConditionalNegate()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l51419">combineMaskedLoadConstantMask()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l50626">combineOrXorWithSETCC()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l57277">combinePMULDQ()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l45847">combineSelect()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l54197">combineSetCC()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l25083">combineShuffleOfScalars()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l48682">combineVectorShiftImm()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l48649">combineVectorShiftVar()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l57330">combineVPMADD()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l45452">combineVSelectWithAllOnesOrZeros()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l05542">computeZeroableShuffleElements()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l06890">EltsFromConsecutiveLoads()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l31902">ExtendToType()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l05799">getFauxShuffleMask()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l04319">insert1BitVector()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l05106">IsNOT()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l53193">isNullFPScalarOrVectorConst()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l10257">isZeroVector()</a>, <a class="el" href="SystemZISelLowering_8cpp_source.html#l05188">isZeroVector()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l09208">LowerAVXCONCAT_VECTORS()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l07626">LowerBUILD_VECTORvXi1()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l03619">lowerBuildVectorOfConstants()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l09275">LowerCONCAT_VECTORSvXi1()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l32014">LowerMLOAD()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l10922">lowerShuffleAsPermuteAndUnpack()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l14934">lowerV2X128Shuffle()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l17610">lowerVECTOR_SHUFFLE()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l23240">LowerVSETCC()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l06780">LowerVSETCC()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l10555">matchShuffleAsBlend()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l08428">materializeVectorConstant()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l15777">llvm::PPCTargetLowering::PerformDAGCombine()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l17095">PerformVECREDUCE_ADDCombine()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l01101">llvm::TargetLowering::SimplifyDemandedBits()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l42643">llvm::X86TargetLowering::SimplifyDemandedBitsForTargetNode()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l00670">llvm::TargetLowering::SimplifyMultipleUseDemandedBits()</a>, and <a class="el" href="X86ISelLowering_8cpp_source.html#l43157">llvm::X86TargetLowering::SimplifyMultipleUseDemandedBitsForTargetNode()</a>.</p>

</div>
</div>
<a id="abf3a86e6cdc4fe3dbd4e618c2f7a64c2" name="abf3a86e6cdc4fe3dbd4e618c2f7a64c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3a86e6cdc4fe3dbd4e618c2f7a64c2">&#9670;&#160;</a></span>isBuildVectorOfConstantFPSDNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isBuildVectorOfConstantFPSDNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified node is a BUILD_VECTOR node of all <a class="el" href="classllvm_1_1ConstantFPSDNode.html">ConstantFPSDNode</a> or undef. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00292">292</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00529">BUILD_VECTOR</a>, <a class="el" href="Casting_8h_source.html#l00548">llvm::isa()</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l40476">canonicalizeShuffleWithOp()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l56068">combineConcatVectorOps()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l56980">combineEXTRACT_SUBVECTOR()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l54007">combineFMA()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l31902">ExtendToType()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l53960">getInvertedVectorForFMA()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l01054">isAnyConstantBuildVector()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l13103">llvm::SelectionDAG::isConstantFPBuildVectorOrConstantFP()</a>, and <a class="el" href="RISCVISelLowering_8cpp_source.html#l04009">lowerBUILD_VECTOR()</a>.</p>

</div>
</div>
<a id="a2f37af786c5ba90887c1b4ec137a066c" name="a2f37af786c5ba90887c1b4ec137a066c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f37af786c5ba90887c1b4ec137a066c">&#9670;&#160;</a></span>isBuildVectorOfConstantSDNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isBuildVectorOfConstantSDNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified node is a BUILD_VECTOR node of all <a class="el" href="classllvm_1_1ConstantSDNode.html">ConstantSDNode</a> or undef. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00279">279</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00529">BUILD_VECTOR</a>, <a class="el" href="Casting_8h_source.html#l00548">llvm::isa()</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l40476">canonicalizeShuffleWithOp()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l43855">combineBitcast()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l43630">combineCastedMaskArithmetic()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l56068">combineConcatVectorOps()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l56980">combineEXTRACT_SUBVECTOR()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l51419">combineMaskedLoadConstantMask()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l47705">combineMulToPMADDWD()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l45847">combineSelect()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l51594">combineStore()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l52310">combineTruncatedArithmetic()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l45662">combineVSelectToBLENDV()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l43613">combinevXi1ConstantToInteger()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l31902">ExtendToType()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l06894">llvm::SelectionDAG::getNode()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l25175">getTargetVShiftByConstNode()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l04572">getVectorShuffle()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l13084">llvm::SelectionDAG::isConstantIntBuildVectorOrConstantInt()</a>, <a class="el" href="LegalizeVectorTypes_8cpp_source.html#l05922">isSETCCorConvertedSETCC()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l06347">llvm::SelectionDAG::isUndef()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l04009">lowerBUILD_VECTOR()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l03619">lowerBuildVectorOfConstants()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l03512">lowerBuildVectorViaDominantValues()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l29942">LowerFunnelShift()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l28450">LowerMUL()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l30144">LowerRotate()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l29457">LowerShift()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l17752">lowerVSELECTtoVectorShuffle()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l28622">LowervXi8MulWithUNPCK()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16388">matchIndexAsShuffle()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16423">matchIndexAsWiderOp()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l14102">narrowIndex()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16654">llvm::RISCVTargetLowering::PerformDAGCombine()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16086">performINSERT_VECTOR_ELTCombine()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l01101">llvm::TargetLowering::SimplifyDemandedBits()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l37008">llvm::X86TargetLowering::targetShrinkDemandedConstant()</a>, and <a class="el" href="DAGCombiner_8cpp_source.html#l12860">tryToFoldExtendOfConstant()</a>.</p>

</div>
</div>
<a id="aafb64237a88493be2c913b0a51630a0f" name="aafb64237a88493be2c913b0a51630a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb64237a88493be2c913b0a51630a0f">&#9670;&#160;</a></span>isConstantSplatVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isConstantSplatVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SplatValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classNode.html">Node</a> predicates. </p>
<p>If N is a BUILD_VECTOR or SPLAT_VECTOR node whose elements are all the same constant or undefined, return true and return the constant value in <code>SplatValue</code>. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00145">145</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00641">SPLAT_VECTOR</a>, and <a class="el" href="APInt_8cpp_source.html#l00906">llvm::APInt::trunc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l52391">combinePMULH()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l54197">combineSetCC()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l48045">combineShiftToPMULH()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16524">combineTruncToVnclip()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l14015">combineVectorMulToSraBitcast()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l03157">llvm::X86TargetLowering::decomposeMulByConstant()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l50996">detectSSatPattern()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l50949">detectUSatPattern()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l11433">llvm::TargetLowering::expandVECTOR_COMPRESS()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l06372">llvm::SelectionDAG::FoldConstantArithmetic()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l00180">isConstantSplatVectorAllOnes()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l00229">isConstantSplatVectorAllZeros()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l01005">isConstantSplatVectorMaskForType()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l23240">LowerVSETCC()</a>, <a class="el" href="SDPatternMatch_8h_source.html#l00731">llvm::SDPatternMatch::ConstantInt_match::match()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l14102">narrowIndex()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l20631">performExtBinopLoadFold()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l17974">PerformMinMaxCombine()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l18166">performMulVectorCmpZeroCombine()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l24199">performVSelectCombine()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l32504">llvm::X86TargetLowering::ReplaceNodeResults()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l22337">scalarizeExtractedBinop()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l18647">tryCombineToBSL()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l13684">tryLowerToSLI()</a>, and <a class="el" href="AArch64ISelLowering_8cpp_source.html#l23812">tryToWidenSetCCOperands()</a>.</p>

</div>
</div>
<a id="a08b1839785665aed1d6e91dd72764713" name="a08b1839785665aed1d6e91dd72764713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b1839785665aed1d6e91dd72764713">&#9670;&#160;</a></span>isConstantSplatVectorAllOnes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isConstantSplatVectorAllOnes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>BuildVectorOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified node is a BUILD_VECTOR or SPLAT_VECTOR where all of the elements are ~0 or undef. </p>
<p>If <code>BuildVectorOnly</code> is set to true, it only checks BUILD_VECTOR. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00180">180</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00529">BUILD_VECTOR</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="SelectionDAGNodes_8h_source.html#l00959">llvm::SDNode::getOperand()</a>, <a class="el" href="ValueTypes_8h_source.html#l00370">llvm::EVT::getScalarSizeInBits()</a>, <a class="el" href="SelectionDAGNodes_8h_source.html#l01031">llvm::SDNode::getValueType()</a>, <a class="el" href="APInt_8h_source.html#l00351">llvm::APInt::isAllOnes()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l00145">isConstantSplatVector()</a>, <a class="el" href="SelectionDAGNodes_8h_source.html#l01222">llvm::SDValue::isUndef()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l00641">SPLAT_VECTOR</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l54197">combineSetCC()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l13639">isAllActivePredicate()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l00271">isBuildVectorAllOnes()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16388">matchIndexAsShuffle()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16423">matchIndexAsWiderOp()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l19301">performConcatVectorsCombine()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l24199">performVSelectCombine()</a>, <a class="el" href="SelectionDAGISel_8cpp_source.html#l03185">llvm::SelectionDAGISel::SelectCodeCommon()</a>, and <a class="el" href="AArch64ISelLowering_8cpp_source.html#l18647">tryCombineToBSL()</a>.</p>

</div>
</div>
<a id="a531723c97a9c44056fc4996bde57229e" name="a531723c97a9c44056fc4996bde57229e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531723c97a9c44056fc4996bde57229e">&#9670;&#160;</a></span>isConstantSplatVectorAllZeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isConstantSplatVectorAllZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>BuildVectorOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified node is a BUILD_VECTOR or SPLAT_VECTOR where all of the elements are 0 or undef. </p>
<p>If <code>BuildVectorOnly</code> is set to true, it only checks BUILD_VECTOR. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00229">229</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00529">BUILD_VECTOR</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l00145">isConstantSplatVector()</a>, <a class="el" href="APInt_8h_source.html#l00360">llvm::APInt::isZero()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l00641">SPLAT_VECTOR</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l45847">combineSelect()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l48094">combineShiftLeft()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l48230">combineShiftRightLogical()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l15078">combineVWADDSUBWSelect()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l13631">isAllInactivePredicate()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l00275">isBuildVectorAllZeros()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l21538">isCheapToExtend()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l03235">isZerosVector()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l24918">removeRedundantInsertVectorElt()</a>, <a class="el" href="SelectionDAGISel_8cpp_source.html#l03185">llvm::SelectionDAGISel::SelectCodeCommon()</a>, and <a class="el" href="AArch64ISelLowering_8cpp_source.html#l18647">tryCombineToBSL()</a>.</p>

</div>
</div>
<a id="a910795e8d77c1545da0683c0e1cb81ee" name="a910795e8d77c1545da0683c0e1cb81ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910795e8d77c1545da0683c0e1cb81ee">&#9670;&#160;</a></span>isEXTLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isEXTLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified node is a EXTLOAD. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAGNodes_8h_source.html#l03189">3189</a> of file <a class="el" href="SelectionDAGNodes_8h_source.html">SelectionDAGNodes.h</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01554">EXTLOAD</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l40686">combineTargetShuffle()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l03144">llvm::SelectionDAG::computeKnownBits()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l04722">isFloatingPointZero()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l01862">isFloatingPointZero()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l09411">isValidSplatLoad()</a>, and <a class="el" href="DAGCombiner_8cpp_source.html#l13245">tryToFoldExtOfExtload()</a>.</p>

</div>
</div>
<a id="a4a72af46491472b765d836f2b5b62592" name="a4a72af46491472b765d836f2b5b62592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a72af46491472b765d836f2b5b62592">&#9670;&#160;</a></span>isExtOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isExtOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01645">1645</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00811">ANY_EXTEND</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00802">SIGN_EXTEND</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l00808">ZERO_EXTEND</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUISelDAGToDAG_8cpp_source.html#l02404">combineBallotPattern()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l56980">combineEXTRACT_SUBVECTOR()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l04452">llvm::SelectionDAG::ComputeNumSignBits()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l20292">isExtendOrShiftOperand()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l20631">performExtBinopLoadFold()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l05025">skipExtensionForVectorMULL()</a>, and <a class="el" href="DAGCombiner_8cpp_source.html#l12860">tryToFoldExtendOfConstant()</a>.</p>

</div>
</div>
<a id="a256306086883f189bdc13ed15c2f7800" name="a256306086883f189bdc13ed15c2f7800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256306086883f189bdc13ed15c2f7800">&#9670;&#160;</a></span>isExtVecInRegOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isExtVecInRegOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01650">1650</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00837">ANY_EXTEND_VECTOR_INREG</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00848">SIGN_EXTEND_VECTOR_INREG</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l00859">ZERO_EXTEND_VECTOR_INREG</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l56980">combineEXTRACT_SUBVECTOR()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l25368">combineTruncationShuffle()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l14860">foldExtendVectorInregToExtendOfSubvector()</a>, and <a class="el" href="DAGCombiner_8cpp_source.html#l12860">tryToFoldExtendOfConstant()</a>.</p>

</div>
</div>
<a id="a47810790d5bd808946ba55b160e513e7" name="a47810790d5bd808946ba55b160e513e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47810790d5bd808946ba55b160e513e7">&#9670;&#160;</a></span>isFPEqualitySetCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isFPEqualitySetCC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a setcc instruction that performs an equality comparison when used with floating point operands. </p>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01625">1625</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l01577">SETOEQ</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01582">SETONE</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01585">SETUEQ</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01590">SETUNE</a>.</p>

<p class="reference">Referenced by <a class="el" href="DAGCombiner_8cpp_source.html#l06144">foldAndOrOfSETCC()</a>.</p>

</div>
</div>
<a id="a938294d45605337641e10c207def0988" name="a938294d45605337641e10c207def0988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938294d45605337641e10c207def0988">&#9670;&#160;</a></span>isFreezeUndef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isFreezeUndef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified node is <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110ad3b50b6d74957b19afb85ac29f66afef">FREEZE(UNDEF)</a>. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00351">351</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00223">FREEZE</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l09208">LowerAVXCONCAT_VECTORS()</a>.</p>

</div>
</div>
<a id="a247f22e450c54c4a1c680641cb7546e7" name="a247f22e450c54c4a1c680641cb7546e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247f22e450c54c4a1c680641cb7546e7">&#9670;&#160;</a></span>isIndexTypeSigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isIndexTypeSigned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa30bf48cd2a89f80c9c608adcabc53e3">MemIndexType</a></td>          <td class="paramname"><span class="paramname"><em>IndexType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01540">1540</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l01536">SIGNED_SCALED</a>.</p>

<p class="reference">Referenced by <a class="el" href="DAGCombiner_8cpp_source.html#l11858">refineIndexType()</a>.</p>

</div>
</div>
<a id="afda64d97fb7fe554744b7a68c304c224" name="afda64d97fb7fe554744b7a68c304c224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda64d97fb7fe554744b7a68c304c224">&#9670;&#160;</a></span>isIntEqualitySetCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isIntEqualitySetCC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a setcc instruction that performs an equality comparison when used with integer operands. </p>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01619">1619</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l01594">SETEQ</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01599">SETNE</a>.</p>

<p class="reference">Referenced by <a class="el" href="RISCVISelLowering_8cpp_source.html#l15772">combine_CC()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l06144">foldAndOrOfSETCC()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16654">llvm::RISCVTargetLowering::PerformDAGCombine()</a>, <a class="el" href="RISCVISelDAGToDAG_8cpp_source.html#l02823">llvm::RISCVDAGToDAGISel::selectSETCC()</a>, and <a class="el" href="RISCVISelLowering_8cpp_source.html#l15713">tryDemorganOfBooleanCondition()</a>.</p>

</div>
</div>
<a id="a15623094a1ed0cd7163dc786e44c87c9" name="a15623094a1ed0cd7163dc786e44c87c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15623094a1ed0cd7163dc786e44c87c9">&#9670;&#160;</a></span>isNON_EXTLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isNON_EXTLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified node is a non-extending load. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAGNodes_8h_source.html#l03183">3183</a> of file <a class="el" href="SelectionDAGNodes_8h_source.html">SelectionDAGNodes.h</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01554">NON_EXTLOAD</a>.</p>

<p class="reference">Referenced by <a class="el" href="SelectionDAG_8cpp_source.html#l03144">llvm::SelectionDAG::computeKnownBits()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l06843">findEltLoadSrc()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l04722">isFloatingPointZero()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l01862">isFloatingPointZero()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l12195">isShuffleFoldableLoad()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l09411">isValidSplatLoad()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l15777">llvm::PPCTargetLowering::PerformDAGCombine()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l12185">llvm::RISCVTargetLowering::ReplaceNodeResults()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l32504">llvm::X86TargetLowering::ReplaceNodeResults()</a>, <a class="el" href="M68kISelLowering_8cpp_source.html#l01753">TranslateM68kCC()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l02832">TranslateX86CC()</a>, and <a class="el" href="DAGCombiner_8cpp_source.html#l13277">tryToFoldExtOfLoad()</a>.</p>

</div>
</div>
<a id="afaaeadcd82b42fc0d385a6247bf7bb52" name="afaaeadcd82b42fc0d385a6247bf7bb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaaeadcd82b42fc0d385a6247bf7bb52">&#9670;&#160;</a></span>isNormalLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isNormalLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified node is a non-extending and unindexed load. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAGNodes_8h_source.html#l03176">3176</a> of file <a class="el" href="SelectionDAGNodes_8h_source.html">SelectionDAGNodes.h</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01554">NON_EXTLOAD</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01523">UNINDEXED</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l43399">adjustBitcastSrcVectorSSE1()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l05596">canChangeToInt()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l19725">CheckForMaskedLoad()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l56068">combineConcatVectorOps()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l51130">combineConstantPoolLoads()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l53417">combineCVTP2I_CVTTP2I()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l53588">combineCVTPH2PS()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l57375">combineEXTEND_VECTOR_INREG()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l44640">combineExtractFromVectorLoad()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l57707">combineMOVDQ2Q()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l53690">combineSignExtendInReg()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l54958">combineSIntToFP()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l51594">combineStore()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l40686">combineTargetShuffle()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l53384">combineX86INT_TO_FP()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l09356">getNormalLoadInput()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l18052">llvm::RISCVTargetLowering::getTargetConstantFromLoad()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l04708">getTargetConstantFromNode()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l15258">hasNormalLoadOperand()</a>, <a class="el" href="SystemZISelDAGToDAG_8cpp_source.html#l01303">isFusableLoadOpStorePattern()</a>, <a class="el" href="X86ISelDAGToDAG_8cpp_source.html#l03425">isFusableLoadOpStorePattern()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l06768">LowerAsSplatVectorLoad()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l07272">lowerBuildVectorAsBroadcast()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l10639">lowerShuffleAsBlend()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l12479">lowerShuffleAsBroadcast()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l10202">lowerShuffleAsVTRUNC()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l05077">lowerVECTOR_SHUFFLE()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l02634">llvm::X86::mayFoldLoad()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16158">performCONCAT_VECTORSCombine()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l15777">llvm::PPCTargetLowering::PerformDAGCombine()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16654">llvm::RISCVTargetLowering::PerformDAGCombine()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l24962">performFPExtendCombine()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l15484">PerformInsertEltCombine()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l18536">performIntToFpCombine()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l16536">PerformLOADCombine()</a>, <a class="el" href="AMDGPUISelLowering_8cpp_source.html#l03797">llvm::AMDGPUTargetLowering::performLoadCombine()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l15223">PerformVMOVrhCombine()</a>, and <a class="el" href="ARMISelLowering_8cpp_source.html#l15053">PerformVMOVRRDCombine()</a>.</p>

</div>
</div>
<a id="a308088c2d65f8f3955f5fb0f6aca7ccc" name="a308088c2d65f8f3955f5fb0f6aca7ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308088c2d65f8f3955f5fb0f6aca7ccc">&#9670;&#160;</a></span>isNormalStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isNormalStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified node is a non-truncating and unindexed store. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAGNodes_8h_source.html#l03214">3214</a> of file <a class="el" href="SelectionDAGNodes_8h_source.html">SelectionDAGNodes.h</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01523">UNINDEXED</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l58035">llvm::X86TargetLowering::IsDesirableToPromoteOp()</a>, <a class="el" href="SystemZISelDAGToDAG_8cpp_source.html#l01303">isFusableLoadOpStorePattern()</a>, <a class="el" href="X86ISelDAGToDAG_8cpp_source.html#l03425">isFusableLoadOpStorePattern()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l02667">llvm::X86::mayFoldIntoStore()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l15777">llvm::PPCTargetLowering::PerformDAGCombine()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l16654">llvm::RISCVTargetLowering::PerformDAGCombine()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l16806">PerformSTORECombine()</a>, and <a class="el" href="AMDGPUISelLowering_8cpp_source.html#l03850">llvm::AMDGPUTargetLowering::performStoreCombine()</a>.</p>

</div>
</div>
<a id="a2d58a0ced655af200989177b8e029f2d" name="a2d58a0ced655af200989177b8e029f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d58a0ced655af200989177b8e029f2d">&#9670;&#160;</a></span>isOverflowIntrOpRes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isOverflowIntrOpRes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDValue.html">SDValue</a></td>          <td class="paramname"><span class="paramname"><em>Op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified value is the overflow result from one of the overflow intrinsic nodes. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAGNodes_8h_source.html#l03260">3260</a> of file <a class="el" href="SelectionDAGNodes_8h_source.html">SelectionDAGNodes.h</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00330">SADDO</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00338">SMULO</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00334">SSUBO</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00331">UADDO</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00339">UMULO</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l00335">USUBO</a>.</p>

</div>
</div>
<a id="ac174dc465cbe0e04a0f5e41c0a422124" name="ac174dc465cbe0e04a0f5e41c0a422124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac174dc465cbe0e04a0f5e41c0a422124">&#9670;&#160;</a></span>isSEXTLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isSEXTLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified node is a SEXTLOAD. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAGNodes_8h_source.html#l03195">3195</a> of file <a class="el" href="SelectionDAGNodes_8h_source.html">SelectionDAGNodes.h</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01554">SEXTLOAD</a>.</p>

<p class="reference">Referenced by <a class="el" href="SelectionDAG_8cpp_source.html#l03144">llvm::SelectionDAG::computeKnownBits()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l09469">isSignExtended()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l09411">isValidSplatLoad()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l09554">SkipExtensionForVMULL()</a>, and <a class="el" href="DAGCombiner_8cpp_source.html#l13245">tryToFoldExtOfExtload()</a>.</p>

</div>
</div>
<a id="aae86ddfa346964171caa61f29d46294b" name="aae86ddfa346964171caa61f29d46294b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae86ddfa346964171caa61f29d46294b">&#9670;&#160;</a></span>isSignedIntSetCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isSignedIntSetCC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a setcc instruction that performs a signed comparison when used with integer operands. </p>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01607">1607</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l01596">SETGE</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01595">SETGT</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01598">SETLE</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01597">SETLT</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l54197">combineSetCC()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l12943">ExtendUsesToFormExtLoad()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l04458">llvm::TargetLowering::SimplifySetCC()</a>, and <a class="el" href="DAGCombiner_8cpp_source.html#l13277">tryToFoldExtOfLoad()</a>.</p>

</div>
</div>
<a id="a6eaea873272c138c801dae8542b1be46" name="a6eaea873272c138c801dae8542b1be46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eaea873272c138c801dae8542b1be46">&#9670;&#160;</a></span>isTrueWhenEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isTrueWhenEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Cond</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the specified condition returns true if the two operands to the condition are equal. </p>
<p>Note that if one of the two operands is a NaN, this value is meaningless. </p>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01632">1632</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">References <a class="el" href="RISCVRedundantCopyElimination_8cpp_source.html#l00075">Cond</a>.</p>

<p class="reference">Referenced by <a class="el" href="SelectionDAG_8cpp_source.html#l02527">llvm::SelectionDAG::FoldSetCC()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l23240">LowerVSETCC()</a>, and <a class="el" href="TargetLowering_8cpp_source.html#l04458">llvm::TargetLowering::SimplifySetCC()</a>.</p>

</div>
</div>
<a id="a7da84980dd2ee06405d74303cfb90485" name="a7da84980dd2ee06405d74303cfb90485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da84980dd2ee06405d74303cfb90485">&#9670;&#160;</a></span>isUNINDEXEDLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isUNINDEXEDLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified node is an unindexed load. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAGNodes_8h_source.html#l03207">3207</a> of file <a class="el" href="SelectionDAGNodes_8h_source.html">SelectionDAGNodes.h</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01523">UNINDEXED</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l40686">combineTargetShuffle()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l09411">isValidSplatLoad()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l13245">tryToFoldExtOfExtload()</a>, and <a class="el" href="DAGCombiner_8cpp_source.html#l13277">tryToFoldExtOfLoad()</a>.</p>

</div>
</div>
<a id="ab5c74add1b228292dae9d97d63b6f27b" name="ab5c74add1b228292dae9d97d63b6f27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c74add1b228292dae9d97d63b6f27b">&#9670;&#160;</a></span>isUNINDEXEDStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isUNINDEXEDStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified node is an unindexed store. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAGNodes_8h_source.html#l03221">3221</a> of file <a class="el" href="SelectionDAGNodes_8h_source.html">SelectionDAGNodes.h</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01523">UNINDEXED</a>.</p>

</div>
</div>
<a id="adb237925346ec53b00d3c82a42311318" name="adb237925346ec53b00d3c82a42311318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb237925346ec53b00d3c82a42311318">&#9670;&#160;</a></span>isUnsignedIntSetCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isUnsignedIntSetCC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3c3cf58d6d631af6a172457304d3d07">CondCode</a></td>          <td class="paramname"><span class="paramname"><em>Code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a setcc instruction that performs an unsigned comparison when used with integer operands. </p>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01613">1613</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l01587">SETUGE</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01586">SETUGT</a>, <a class="el" href="ISDOpcodes_8h_source.html#l01589">SETULE</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01588">SETULT</a>.</p>

<p class="reference">Referenced by <a class="el" href="X86ISelLowering_8cpp_source.html#l53859">combineExtSetcc()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l54197">combineSetCC()</a>, <a class="el" href="SparcISelLowering_8cpp_source.html#l02621">LowerBR_CC()</a>, <a class="el" href="SparcISelLowering_8cpp_source.html#l02672">LowerSELECT_CC()</a>, and <a class="el" href="X86ISelLowering_8cpp_source.html#l23240">LowerVSETCC()</a>.</p>

</div>
</div>
<a id="a570c0c51d118ee761eb55fc0d2d910f4" name="a570c0c51d118ee761eb55fc0d2d910f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570c0c51d118ee761eb55fc0d2d910f4">&#9670;&#160;</a></span>isVectorShrinkable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isVectorShrinkable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NewEltSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>Signed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the specified node is a vector where all elements can be truncated to the specified element size without a loss in meaning. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00305">305</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00529">BUILD_VECTOR</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="Casting_8h_source.html#l00548">llvm::isa()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="ISDOpcodes_8h_source.html#l00802">SIGN_EXTEND</a>, <a class="el" href="NVPTXISelLowering_8cpp_source.html#l05611">Signed</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l00808">ZERO_EXTEND</a>.</p>

<p class="reference">Referenced by <a class="el" href="AArch64ISelLowering_8cpp_source.html#l23074">findMoreOptimalIndexType()</a>.</p>

</div>
</div>
<a id="a5ec28aae630b390b75abfebf79bce788" name="a5ec28aae630b390b75abfebf79bce788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec28aae630b390b75abfebf79bce788">&#9670;&#160;</a></span>isVPBinaryOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isVPBinaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this is a vector-predicated binary operation opcode. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00492">492</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

</div>
</div>
<a id="aed1c239da7e4526d3140443b3bf6f8d7" name="aed1c239da7e4526d3140443b3bf6f8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1c239da7e4526d3140443b3bf6f8d7">&#9670;&#160;</a></span>isVPOpcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isVPOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this is a vector-predicated Opcode. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00481">481</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SelectionDAGNodes_8h_source.html#l00721">llvm::SDNode::isVPOpcode()</a>, <a class="el" href="VEISelLowering_8cpp_source.html#l01870">llvm::VETargetLowering::LowerOperation()</a>, <a class="el" href="VVPISelLowering_8cpp_source.html#l00038">llvm::VETargetLowering::lowerToVVP()</a>, and <a class="el" href="RISCVISelLowering_8cpp_source.html#l06161">SplitVPOp()</a>.</p>

</div>
</div>
<a id="ab7d0f87095c6d1ece5c444d0e030083d" name="ab7d0f87095c6d1ece5c444d0e030083d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d0f87095c6d1ece5c444d0e030083d">&#9670;&#160;</a></span>isVPReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isVPReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether this is a vector-predicated reduction opcode. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00504">504</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VECustomDAG_8cpp_source.html#l00362">llvm::hasReductionStartParam()</a>.</p>

</div>
</div>
<a id="a35edacef22fcaed7a8681fa573476131" name="a35edacef22fcaed7a8681fa573476131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35edacef22fcaed7a8681fa573476131">&#9670;&#160;</a></span>isZEXTLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::isZEXTLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SDNode.html">SDNode</a> *</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified node is a ZEXTLOAD. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAGNodes_8h_source.html#l03201">3201</a> of file <a class="el" href="SelectionDAGNodes_8h_source.html">SelectionDAGNodes.h</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l01554">ZEXTLOAD</a>.</p>

<p class="reference">Referenced by <a class="el" href="SelectionDAG_8cpp_source.html#l03144">llvm::SelectionDAG::computeKnownBits()</a>, <a class="el" href="PPCISelLowering_8cpp_source.html#l09411">isValidSplatLoad()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l09479">isZeroExtended()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l01101">llvm::TargetLowering::SimplifyDemandedBits()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l09554">SkipExtensionForVMULL()</a>, and <a class="el" href="DAGCombiner_8cpp_source.html#l13245">tryToFoldExtOfExtload()</a>.</p>

</div>
</div>
<a id="ab283a383171c46fb4445cb64eb6b687a" name="ab283a383171c46fb4445cb64eb6b687a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab283a383171c46fb4445cb64eb6b687a">&#9670;&#160;</a></span>matchBinaryPredicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::matchBinaryPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDValue.html">SDValue</a></td>          <td class="paramname"><span class="paramname"><em>LHS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDValue.html">SDValue</a></td>          <td class="paramname"><span class="paramname"><em>RHS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1ConstantSDNode.html">ConstantSDNode</a> *, <a class="el" href="classllvm_1_1ConstantSDNode.html">ConstantSDNode</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>Match</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowUndefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowTypeMismatch</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to match a binary predicate against a pair of scalar/splat constants or every element of a pair of constant BUILD_VECTORs. </p>
<p>If AllowUndef is true, then UNDEF elements will pass nullptr to Match. If AllowTypeMismatch is true then RetType + ArgTypes don't need to match. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00388">388</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00529">BUILD_VECTOR</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="SelectionDAGNodes_8h_source.html#l01194">llvm::SDValue::getOperand()</a>, <a class="el" href="ValueTypes_8h_source.html#l00313">llvm::EVT::getScalarType()</a>, <a class="el" href="SelectionDAGNodes_8h_source.html#l01186">llvm::SDValue::getValueType()</a>, <a class="el" href="SelectionDAGNodes_8h_source.html#l01222">llvm::SDValue::isUndef()</a>, <a class="el" href="namespacellvm.html#a313a633eb3049b90e931206183e1251ea6da89265a9a8b0b28eb4946bb2ec0c6d">llvm::Match</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l00641">SPLAT_VECTOR</a>.</p>

</div>
</div>
<a id="a425d6f0e5036ca26fdd80efcaae21589" name="a425d6f0e5036ca26fdd80efcaae21589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425d6f0e5036ca26fdd80efcaae21589">&#9670;&#160;</a></span>matchUnaryFpPredicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::matchUnaryFpPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDValue.html">SDValue</a></td>          <td class="paramname"><span class="paramname"><em>Op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1ConstantFPSDNode.html">ConstantFPSDNode</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>Match</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowUndefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook for matching <a class="el" href="classllvm_1_1ConstantFPSDNode.html">ConstantFPSDNode</a> predicate. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAGNodes_8h_source.html#l03243">3243</a> of file <a class="el" href="SelectionDAGNodes_8h_source.html">SelectionDAGNodes.h</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a313a633eb3049b90e931206183e1251ea6da89265a9a8b0b28eb4946bb2ec0c6d">llvm::Match</a>, and <a class="el" href="SelectionDAG_8cpp_source.html#l00356">matchUnaryPredicateImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SelectionDAG_8cpp_source.html#l05505">llvm::SelectionDAG::isKnownNeverZeroFloat()</a>.</p>

</div>
</div>
<a id="a309c11edf22da984f95cf9ba7a699c11" name="a309c11edf22da984f95cf9ba7a699c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309c11edf22da984f95cf9ba7a699c11">&#9670;&#160;</a></span>matchUnaryPredicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::matchUnaryPredicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDValue.html">SDValue</a></td>          <td class="paramname"><span class="paramname"><em>Op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classllvm_1_1ConstantSDNode.html">ConstantSDNode</a> *)&gt;</td>          <td class="paramname"><span class="paramname"><em>Match</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowUndefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook for matching <a class="el" href="classllvm_1_1ConstantSDNode.html">ConstantSDNode</a> predicate. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAGNodes_8h_source.html#l03235">3235</a> of file <a class="el" href="SelectionDAGNodes_8h_source.html">SelectionDAGNodes.h</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#a313a633eb3049b90e931206183e1251ea6da89265a9a8b0b28eb4946bb2ec0c6d">llvm::Match</a>, and <a class="el" href="SelectionDAG_8cpp_source.html#l00356">matchUnaryPredicateImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetLowering_8cpp_source.html#l06096">BuildExactSDIV()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l06158">BuildExactUDIV()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l06286">llvm::TargetLowering::BuildSDIV()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l06448">llvm::TargetLowering::BuildUDIV()</a>, <a class="el" href="X86ISelLowering_8cpp_source.html#l45847">combineSelect()</a>, <a class="el" href="DAGCombiner_8cpp_source.html#l04761">isDivisorPowerOfTwo()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l05514">llvm::SelectionDAG::isKnownNeverZero()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l04346">llvm::SelectionDAG::isKnownToBeAPowerOfTwo()</a>, <a class="el" href="TargetLowering_8cpp_source.html#l07909">isNonZeroModBitWidthOrUndef()</a>, <a class="el" href="SelectionDAG_8cpp_source.html#l09934">llvm::SelectionDAG::simplifyShift()</a>, and <a class="el" href="DAGCombiner_8cpp_source.html#l27903">takeInexpensiveLog2()</a>.</p>

</div>
</div>
<a id="a5bffdefad1ad0a43b40eaa2a2cded351" name="a5bffdefad1ad0a43b40eaa2a2cded351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bffdefad1ad0a43b40eaa2a2cded351">&#9670;&#160;</a></span>matchUnaryPredicateImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstNodeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::ISD::matchUnaryPredicateImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SDValue.html">SDValue</a></td>          <td class="paramname"><span class="paramname"><em>Op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classbool.html">bool</a>(ConstNodeType *)&gt;</td>          <td class="paramname"><span class="paramname"><em>Match</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>AllowUndefs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to match a unary predicate against a scalar/splat constant or every element of a constant BUILD_VECTOR. </p>
<p>If AllowUndef is true, then UNDEF elements will pass nullptr to Match. </p>

<p class="definition">Definition at line <a class="el" href="SelectionDAG_8cpp_source.html#l00356">356</a> of file <a class="el" href="SelectionDAG_8cpp_source.html">SelectionDAG.cpp</a>.</p>

<p class="reference">References <a class="el" href="ISDOpcodes_8h_source.html#l00529">BUILD_VECTOR</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="Casting_8h_source.html#l00649">llvm::dyn_cast()</a>, <a class="el" href="DWARFExpression_8h_source.html#l00090">llvm::DWARFExpression::Operation::getNumOperands()</a>, <a class="el" href="namespacellvm.html#a313a633eb3049b90e931206183e1251ea6da89265a9a8b0b28eb4946bb2ec0c6d">llvm::Match</a>, and <a class="el" href="ISDOpcodes_8h_source.html#l00641">SPLAT_VECTOR</a>.</p>

<p class="reference">Referenced by <a class="el" href="SelectionDAGNodes_8h_source.html#l03243">matchUnaryFpPredicate()</a>, and <a class="el" href="SelectionDAGNodes_8h_source.html#l03235">matchUnaryPredicate()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a492b8a748b427bf9338f626f438cf91c" name="a492b8a748b427bf9338f626f438cf91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492b8a748b427bf9338f626f438cf91c">&#9670;&#160;</a></span>FIRST_TARGET_MEMORY_OPCODE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> int llvm::ISD::FIRST_TARGET_MEMORY_OPCODE = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a477ef80c70c7359199eace0e5d3133b1">BUILTIN_OP_END</a> + 500</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FIRST_TARGET_MEMORY_OPCODE - Target-specific pre-isel operations which do not reference a specific memory location should be less than this value. </p>
<p>Those that do must not be less than this value, and can be used with <a class="el" href="classllvm_1_1SelectionDAG.html#ae6cc63109335eefe2c5727d1e12fc820" title="Creates a MemIntrinsicNode that may produce a result and takes a list of operands.">SelectionDAG::getMemIntrinsicNode</a>. </p>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01463">1463</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SelectionDAG_8cpp_source.html#l08739">llvm::SelectionDAG::getMemIntrinsicNode()</a>, and <a class="el" href="SelectionDAGNodes_8h_source.html#l00686">llvm::SDNode::isTargetMemoryOpcode()</a>.</p>

</div>
</div>
<a id="ac12e5034984d1e706d2a8b89dc3e9394" name="ac12e5034984d1e706d2a8b89dc3e9394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12e5034984d1e706d2a8b89dc3e9394">&#9670;&#160;</a></span>FIRST_TARGET_STRICTFP_OPCODE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> int llvm::ISD::FIRST_TARGET_STRICTFP_OPCODE = <a class="el" href="#a22ea9cec080dd5f4f47ba234c2f59110a477ef80c70c7359199eace0e5d3133b1">BUILTIN_OP_END</a> + 400</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FIRST_TARGET_STRICTFP_OPCODE - Target-specific pre-isel operations which cannot raise FP exceptions should be less than this value. </p>
<p>Those that do must not be less than this value. </p>

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01457">1457</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RISCVISelLowering_8cpp_source.html#l06116">hasMaskOp()</a>, <a class="el" href="RISCVISelLowering_8cpp_source.html#l06090">hasMergeOp()</a>, and <a class="el" href="SelectionDAGNodes_8h_source.html#l00679">llvm::SDNode::isTargetStrictFPOpcode()</a>.</p>

</div>
</div>
<a id="ae0010333b4e1424ce473b508d802bbbd" name="ae0010333b4e1424ce473b508d802bbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0010333b4e1424ce473b508d802bbbd">&#9670;&#160;</a></span>LAST_INDEXED_MODE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> int llvm::ISD::LAST_INDEXED_MODE = <a class="el" href="#abee7ecb577fcade34eb16ccb7f503e31a10a4094c81c0b9cd5e82e53b48932203">POST_DEC</a> + 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01525">1525</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AArch64ISelLowering_8cpp_source.html#l00376">llvm::AArch64TargetLowering::AArch64TargetLowering()</a>, <a class="el" href="ARMISelLowering_8cpp_source.html#l00496">llvm::ARMTargetLowering::ARMTargetLowering()</a>, and <a class="el" href="TargetLoweringBase_8cpp_source.html#l00648">llvm::TargetLoweringBase::initActions()</a>.</p>

</div>
</div>
<a id="a53490a5ced1d50808fe962a298c315cd" name="a53490a5ced1d50808fe962a298c315cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53490a5ced1d50808fe962a298c315cd">&#9670;&#160;</a></span>LAST_LOADEXT_TYPE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> int llvm::ISD::LAST_LOADEXT_TYPE = <a class="el" href="#ad4d48171b87ca51ff54c10a436bac4d7a8d89c7da4444d9ec11667aa369abc5f7">ZEXTLOAD</a> + 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01556">1556</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetLowering_8h_source.html#l01463">llvm::TargetLoweringBase::getAtomicLoadExtAction()</a>, <a class="el" href="TargetLowering_8h_source.html#l01439">llvm::TargetLoweringBase::getLoadExtAction()</a>, <a class="el" href="TargetLowering_8h_source.html#l02575">llvm::TargetLoweringBase::setAtomicLoadExtAction()</a>, and <a class="el" href="TargetLowering_8h_source.html#l02553">llvm::TargetLoweringBase::setLoadExtAction()</a>.</p>

</div>
</div>
<a id="a769bfb423d42986a688a04035ce40cf7" name="a769bfb423d42986a688a04035ce40cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769bfb423d42986a688a04035ce40cf7">&#9670;&#160;</a></span>LAST_MEM_INDEX_TYPE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> int llvm::ISD::LAST_MEM_INDEX_TYPE = <a class="el" href="#aa30bf48cd2a89f80c9c608adcabc53e3af3218635b665db9e7e1d97e015f14e3a">UNSIGNED_SCALED</a> + 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ISDOpcodes_8h_source.html#l01538">1538</a> of file <a class="el" href="ISDOpcodes_8h_source.html">ISDOpcodes.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Nov 1 2024 14:05:57 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
