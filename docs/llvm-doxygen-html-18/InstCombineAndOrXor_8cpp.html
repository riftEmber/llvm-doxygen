<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Transforms/InstCombine/InstCombineAndOrXor.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;18.1.0rc</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a72932e0778af28115095468f6286ff8.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_99567d9c0c7f3685f25b19ecc341a865.html">InstCombine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">InstCombineAndOrXor.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="InstCombineInternal_8h_source.html">InstCombineInternal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="CmpInstAnalysis_8h_source.html">llvm/Analysis/CmpInstAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InstructionSimplify_8h_source.html">llvm/Analysis/InstructionSimplify.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ConstantRange_8h_source.html">llvm/IR/ConstantRange.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Intrinsics_8h_source.html">llvm/IR/Intrinsics.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">llvm/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InstCombiner_8h_source.html">llvm/Transforms/InstCombine/InstCombiner.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Transforms_2Utils_2Local_8h_source.html">llvm/Transforms/Utils/Local.h</a>&quot;</code><br />
</div>
<p><a href="InstCombineAndOrXor_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntPart.html">IntPart</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;instcombine&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa9c705ecec80ebd584bb3d54b48f7ee1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1">MaskedICmpType</a> { <br />
&#160;&#160;<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a7cc1609a568ad3b240cf86126370e24f">AMask_AllOnes</a> = 1
, <a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a54ee032f1a4a27e3066fbb88346cd49a">AMask_NotAllOnes</a> = 2
, <a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a4357ae5a8ec7cec4162a1f25c69558ff">BMask_AllOnes</a> = 4
, <a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a2b00a345b6b0214f7aa5cbe8203aeb3e">BMask_NotAllOnes</a> = 8
, <br />
&#160;&#160;<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a37651a7acaf5871fb8a4d593749c06f4">Mask_AllZeros</a> = 16
, <a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1ac7606c30ddb7a593051b6e5ad209f30c">Mask_NotAllZeros</a> = 32
, <a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1ada8a0932439ca5f15218c4d7cd43d895">AMask_Mixed</a> = 64
, <a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a1ee37b18b82ef426e90d86a093d45334">AMask_NotMixed</a> = 128
, <br />
&#160;&#160;<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a3f5a9337c05ff64ea433ed2d4e9d49d5">BMask_Mixed</a> = 256
, <a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a10e63e798489e9c5ad2dc2c5ed98ac10">BMask_NotMixed</a> = 512
<br />
 }</td></tr>
<tr class="memdesc:aa9c705ecec80ebd584bb3d54b48f7ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classify (icmp eq (A &amp; B), C) and (icmp ne (A &amp; B), C) as matching patterns that can be simplified.  <a href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1">More...</a><br /></td></tr>
<tr class="separator:aa9c705ecec80ebd584bb3d54b48f7ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a89cfa00019cb17baa05532705ea198e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a89cfa00019cb17baa05532705ea198e0">getNewICmpValue</a> (<a class="el" href="classunsigned.html">unsigned</a> Code, <a class="el" href="classbool.html">bool</a> Sign, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a89cfa00019cb17baa05532705ea198e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the complement of getICmpCode, which turns an opcode and two operands into either a constant true or false, or a brand new ICmp instruction.  <br /></td></tr>
<tr class="separator:a89cfa00019cb17baa05532705ea198e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72e7003829df7704d63a8d830742a35"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#ab72e7003829df7704d63a8d830742a35">getFCmpValue</a> (<a class="el" href="classunsigned.html">unsigned</a> Code, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:ab72e7003829df7704d63a8d830742a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the complement of getFCmpCode, which turns an opcode and two operands into either a FCmp instruction, or a true/false constant.  <br /></td></tr>
<tr class="separator:ab72e7003829df7704d63a8d830742a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39257c6c73db3440e6d05b9eec5999a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a39257c6c73db3440e6d05b9eec5999a0">getMaskedICmpType</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, ICmpInst::Predicate Pred)</td></tr>
<tr class="memdesc:a39257c6c73db3440e6d05b9eec5999a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of patterns (from MaskedICmpType) that (icmp SCC (A &amp; B), C) satisfies.  <br /></td></tr>
<tr class="separator:a39257c6c73db3440e6d05b9eec5999a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c36c07a47775cef8f8e93d8090d919"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a09c36c07a47775cef8f8e93d8090d919">conjugateICmpMask</a> (<a class="el" href="classunsigned.html">unsigned</a> Mask)</td></tr>
<tr class="memdesc:a09c36c07a47775cef8f8e93d8090d919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an analysis of a masked ICmp into its equivalent if all boolean operations had the opposite sense.  <br /></td></tr>
<tr class="separator:a09c36c07a47775cef8f8e93d8090d919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1267ddd1fbc10bd31ab88ecb2109bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a1d1267ddd1fbc10bd31ab88ecb2109bd">decomposeBitTestICmp</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classllvm_1_1CmpInst.html#a2be3583dac92a031fa1458d4d992c78b">CmpInst::Predicate</a> &amp;Pred, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;Z)</td></tr>
<tr class="separator:a1d1267ddd1fbc10bd31ab88ecb2109bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9216b6f91863c6f4c51e03aa7147c019"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a9216b6f91863c6f4c51e03aa7147c019">getMaskedTypeForICmpPair</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, ICmpInst::Predicate &amp;PredL, ICmpInst::Predicate &amp;PredR)</td></tr>
<tr class="memdesc:a9216b6f91863c6f4c51e03aa7147c019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E).  <br /></td></tr>
<tr class="separator:a9216b6f91863c6f4c51e03aa7147c019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30194649427f98c3ceaf7092c83911dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a30194649427f98c3ceaf7092c83911dc">foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classbool.html">bool</a> IsAnd, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, ICmpInst::Predicate PredL, ICmpInst::Predicate PredR, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a30194649427f98c3ceaf7092c83911dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y), where the left-hand side is of type Mask_NotAllZeros and the right hand side is of type BMask_Mixed.  <br /></td></tr>
<tr class="separator:a30194649427f98c3ceaf7092c83911dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea6a6eec165567da33302ad84811f84"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a6ea6a6eec165567da33302ad84811f84">foldLogOpOfMaskedICmpsAsymmetric</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classbool.html">bool</a> IsAnd, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, ICmpInst::Predicate PredL, ICmpInst::Predicate PredR, <a class="el" href="classunsigned.html">unsigned</a> LHSMask, <a class="el" href="classunsigned.html">unsigned</a> RHSMask, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a6ea6a6eec165567da33302ad84811f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold (icmp(A &amp; B) ==/!= 0) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y), where the left-hand side and the right hand side aren't of the common mask pattern type.  <br /></td></tr>
<tr class="separator:a6ea6a6eec165567da33302ad84811f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c138f9e5e8e5c6a477b297d39d22094"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a6c138f9e5e8e5c6a477b297d39d22094">foldLogOpOfMaskedICmps</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classbool.html">bool</a> IsAnd, <a class="el" href="classbool.html">bool</a> IsLogical, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a6c138f9e5e8e5c6a477b297d39d22094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y).  <br /></td></tr>
<tr class="separator:a6c138f9e5e8e5c6a477b297d39d22094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f569ebf4402ad560d7c147f688ac05a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a1f569ebf4402ad560d7c147f688ac05a">foldSignedTruncationCheck</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *ICmp0, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *ICmp1, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;CxtI, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a1f569ebf4402ad560d7c147f688ac05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">General pattern: X &amp; Y.  <br /></td></tr>
<tr class="separator:a1f569ebf4402ad560d7c147f688ac05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3634e7e4bbadf2cb8229341858f520f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a3634e7e4bbadf2cb8229341858f520f3">foldIsPowerOf2OrZero</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp0, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp1, <a class="el" href="classbool.html">bool</a> IsAnd, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a3634e7e4bbadf2cb8229341858f520f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold (icmp eq ctpop(X) 1) | (icmp eq X 0) into (icmp ult ctpop(X) 2) and fold (icmp ne ctpop(X) 1) &amp; (icmp ne X 0) into (icmp ugt ctpop(X) 1).  <br /></td></tr>
<tr class="separator:a3634e7e4bbadf2cb8229341858f520f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4527846f6a8b98d7fe16428ff7a28e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a6d4527846f6a8b98d7fe16428ff7a28e">foldIsPowerOf2</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp0, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp1, <a class="el" href="classbool.html">bool</a> JoinedByAnd, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a6d4527846f6a8b98d7fe16428ff7a28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a pair of compares that check if a value has exactly 1 bit set.  <br /></td></tr>
<tr class="separator:a6d4527846f6a8b98d7fe16428ff7a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5532e05d5caa4fb5e2b8512aa3095f1e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a5532e05d5caa4fb5e2b8512aa3095f1e">foldNegativePower2AndShiftedMask</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, ICmpInst::Predicate PredL, ICmpInst::Predicate PredR, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a5532e05d5caa4fb5e2b8512aa3095f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold (icmp(A &amp; B) == 0) &amp; (icmp(A &amp; D) != E) into (icmp A u&lt; D) iff B is a contiguous set of ones starting from the most significant bit (negative power of 2), D and E are equal, and D is a contiguous set of ones starting at the most significant zero bit in B.  <br /></td></tr>
<tr class="separator:a5532e05d5caa4fb5e2b8512aa3095f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609a05f40709dea74bb5cd248c5816fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a609a05f40709dea74bb5cd248c5816fd">foldPowerOf2AndShiftedMask</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp0, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp1, <a class="el" href="classbool.html">bool</a> JoinedByAnd, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a609a05f40709dea74bb5cd248c5816fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold ((icmp X u&lt; P) &amp; (icmp(X &amp; M) != M)) or ((icmp X s&gt; -1) &amp; (icmp(X &amp; M) != M)) into (icmp X u&lt; M).  <br /></td></tr>
<tr class="separator:a609a05f40709dea74bb5cd248c5816fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dce8fa354f0f1d52209e805f0ae6a3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a24dce8fa354f0f1d52209e805f0ae6a3">foldUnsignedUnderflowCheck</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *ZeroICmp, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *UnsignedICmp, <a class="el" href="classbool.html">bool</a> IsAnd, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1SimplifyQuery.html">SimplifyQuery</a> &amp;Q, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a24dce8fa354f0f1d52209e805f0ae6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commuted variants are assumed to be handled by calling this function again with the parameters swapped.  <br /></td></tr>
<tr class="separator:a24dce8fa354f0f1d52209e805f0ae6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7662d7ee7f100c9455f4a2c7e4992929"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="structIntPart.html">IntPart</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a7662d7ee7f100c9455f4a2c7e4992929">matchIntPart</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V)</td></tr>
<tr class="memdesc:a7662d7ee7f100c9455f4a2c7e4992929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match an extraction of bits from an integer.  <br /></td></tr>
<tr class="separator:a7662d7ee7f100c9455f4a2c7e4992929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940bbfdea38f2643d0b63c2cc5af4a82"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a940bbfdea38f2643d0b63c2cc5af4a82">extractIntPart</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structIntPart.html">IntPart</a> &amp;<a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, <a class="el" href="classllvm_1_1IRBuilderBase.html">IRBuilderBase</a> &amp;Builder)</td></tr>
<tr class="memdesc:a940bbfdea38f2643d0b63c2cc5af4a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize an extraction of bits from an integer in IR.  <br /></td></tr>
<tr class="separator:a940bbfdea38f2643d0b63c2cc5af4a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce22397c3eff1d8c0dc8e3d8c464829"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#afce22397c3eff1d8c0dc8e3d8c464829">foldAndOrOfICmpsWithConstEq</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp0, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp1, <a class="el" href="classbool.html">bool</a> IsAnd, <a class="el" href="classbool.html">bool</a> IsLogical, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1SimplifyQuery.html">SimplifyQuery</a> &amp;Q)</td></tr>
<tr class="memdesc:afce22397c3eff1d8c0dc8e3d8c464829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce logic-of-compares with equality to a constant by substituting a common operand with the constant.  <br /></td></tr>
<tr class="separator:afce22397c3eff1d8c0dc8e3d8c464829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ccec2dd2fc482ea50af1764f1db598"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a67ccec2dd2fc482ea50af1764f1db598">stripSignOnlyFPOps</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *Val)</td></tr>
<tr class="memdesc:a67ccec2dd2fc482ea50af1764f1db598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore all operations which only change the sign of a value, returning the underlying magnitude value.  <br /></td></tr>
<tr class="separator:a67ccec2dd2fc482ea50af1764f1db598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e92e028c2dd81bf7d518dfc3960624a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a9e92e028c2dd81bf7d518dfc3960624a">matchIsNotNaN</a> (FCmpInst::Predicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>)</td></tr>
<tr class="memdesc:a9e92e028c2dd81bf7d518dfc3960624a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches canonical form of isnan, fcmp ord x, 0.  <br /></td></tr>
<tr class="separator:a9e92e028c2dd81bf7d518dfc3960624a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9977c80be67ea7e51bb37ee242d1cc4c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a9977c80be67ea7e51bb37ee242d1cc4c">matchUnorderedInfCompare</a> (FCmpInst::Predicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>)</td></tr>
<tr class="memdesc:a9977c80be67ea7e51bb37ee242d1cc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches fcmp u__ x, +/-inf.  <br /></td></tr>
<tr class="separator:a9977c80be67ea7e51bb37ee242d1cc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5946d75decfd106d2b75af6d59009f34"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a5946d75decfd106d2b75af6d59009f34">matchIsFiniteTest</a> (<a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder, <a class="el" href="classllvm_1_1FCmpInst.html">FCmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1FCmpInst.html">FCmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>)</td></tr>
<tr class="memdesc:a5946d75decfd106d2b75af6d59009f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">and (fcmp ord x, 0), (fcmp u* x, inf) -&gt; fcmp o* x, inf  <br /></td></tr>
<tr class="separator:a5946d75decfd106d2b75af6d59009f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151e95d3f063067aa27c74930296a25e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a151e95d3f063067aa27c74930296a25e">matchIsFPClassLikeFCmp</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="namespacellvm.html#ab471937b9a227e70c7fe8bd9604014d6">Op</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;ClassVal, <a class="el" href="classuint64__t.html">uint64_t</a> &amp;ClassMask)</td></tr>
<tr class="memdesc:a151e95d3f063067aa27c74930296a25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match an fcmp against a special value that performs a test possible by llvm.is.fpclass.  <br /></td></tr>
<tr class="separator:a151e95d3f063067aa27c74930296a25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8208d3cd3c60073f5c9ceefec06ab2e3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a8208d3cd3c60073f5c9ceefec06ab2e3">reassociateFCmps</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;BO, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a8208d3cd3c60073f5c9ceefec06ab2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This a limited reassociation for a special case (see above) where we are checking if two values are either both NAN (unordered) or not-NAN (ordered).  <br /></td></tr>
<tr class="separator:a8208d3cd3c60073f5c9ceefec06ab2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3ce43f7795a8f4f6925bffbcc90279"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a2d3ce43f7795a8f4f6925bffbcc90279">matchDeMorgansLaws</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC)</td></tr>
<tr class="memdesc:a2d3ce43f7795a8f4f6925bffbcc90279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match variations of De Morgan's Laws: (~A &amp; ~B) == (~(A | B)) (~A | ~B) == (~(A &amp; B))  <br /></td></tr>
<tr class="separator:a2d3ce43f7795a8f4f6925bffbcc90279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45705c727d8388c014471504b4ab0c4e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a45705c727d8388c014471504b4ab0c4e">foldLogicCastConstant</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;Logic, <a class="el" href="classllvm_1_1CastInst.html">CastInst</a> *Cast, <a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC)</td></tr>
<tr class="memdesc:a45705c727d8388c014471504b4ab0c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold {and,or,xor} (cast X), C.  <br /></td></tr>
<tr class="separator:a45705c727d8388c014471504b4ab0c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385c1da88456d434ee18caa8f48018c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a385c1da88456d434ee18caa8f48018c2">foldAndToXor</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="separator:a385c1da88456d434ee18caa8f48018c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26257c73e483eab4b0e15d53340de986"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a26257c73e483eab4b0e15d53340de986">foldOrToXor</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="separator:a26257c73e483eab4b0e15d53340de986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f025ca3dbad2ca618ad4bf63fa51bb0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a3f025ca3dbad2ca618ad4bf63fa51bb0">canNarrowShiftAmt</a> (<a class="el" href="classllvm_1_1Constant.html">Constant</a> *<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classunsigned.html">unsigned</a> BitWidth)</td></tr>
<tr class="memdesc:a3f025ca3dbad2ca618ad4bf63fa51bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a constant shift amount is always less than the specified bit-width.  <br /></td></tr>
<tr class="separator:a3f025ca3dbad2ca618ad4bf63fa51bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01a210491dcbefc8db253f4dbaa6497"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#ab01a210491dcbefc8db253f4dbaa6497">foldComplexAndOrPatterns</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:ab01a210491dcbefc8db253f4dbaa6497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try folding relatively complex patterns for both And and Or operations with all And and Or swapped.  <br /></td></tr>
<tr class="separator:ab01a210491dcbefc8db253f4dbaa6497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80e92048884e85b87ddd733785e44d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#ac80e92048884e85b87ddd733785e44d9">reassociateForUses</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;BO, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombinerImpl::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:ac80e92048884e85b87ddd733785e44d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to reassociate a pair of binops so that values with one use only are part of the same instruction.  <br /></td></tr>
<tr class="separator:ac80e92048884e85b87ddd733785e44d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8ca6f7206a11fd57d6e194b2523ffe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a7b8ca6f7206a11fd57d6e194b2523ffe">canonicalizeLogicFirst</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="separator:a7b8ca6f7206a11fd57d6e194b2523ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ba7f841807b297e7c28874c285f538"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#ae3ba7f841807b297e7c28874c285f538">foldBitwiseLogicWithIntrinsics</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="separator:ae3ba7f841807b297e7c28874c285f538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22aecfb391040860cfe8c6fa6227ba4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a22aecfb391040860cfe8c6fa6227ba4a">matchFunnelShift</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;Or, <a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> &amp;DT)</td></tr>
<tr class="memdesc:a22aecfb391040860cfe8c6fa6227ba4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match UB-safe variants of the funnel shift intrinsic.  <br /></td></tr>
<tr class="separator:a22aecfb391040860cfe8c6fa6227ba4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6840885acb4ffa3e94e81a70b392fc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a9e6840885acb4ffa3e94e81a70b392fc">matchOrConcat</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;Or, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a9e6840885acb4ffa3e94e81a70b392fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to combine or(zext(x),shl(zext(y),bw/2) concat packing patterns.  <br /></td></tr>
<tr class="separator:a9e6840885acb4ffa3e94e81a70b392fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7934618280f5dc61a34615b689744d1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#aa7934618280f5dc61a34615b689744d1">areInverseVectorBitmasks</a> (<a class="el" href="classllvm_1_1Constant.html">Constant</a> *C1, <a class="el" href="classllvm_1_1Constant.html">Constant</a> *C2)</td></tr>
<tr class="memdesc:aa7934618280f5dc61a34615b689744d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If all elements of two constant vectors are 0/-1 and inverses, return true.  <br /></td></tr>
<tr class="separator:aa7934618280f5dc61a34615b689744d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec897890074179e7de73b934798976"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a45ec897890074179e7de73b934798976">foldAndOrOfICmpEqConstantAndICmp</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classbool.html">bool</a> IsAnd, <a class="el" href="classbool.html">bool</a> IsLogical, <a class="el" href="classllvm_1_1IRBuilderBase.html">IRBuilderBase</a> &amp;Builder)</td></tr>
<tr class="separator:a45ec897890074179e7de73b934798976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3df3036740dfcdeb37c3ad977b039a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a3b3df3036740dfcdeb37c3ad977b039a">foldXorToXor</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a3b3df3036740dfcdeb37c3ad977b039a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ^ B can be specified using other logic ops in a variety of patterns.  <br /></td></tr>
<tr class="separator:a3b3df3036740dfcdeb37c3ad977b039a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff7fad11ba04c97f0a4b679c74cb394"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a1ff7fad11ba04c97f0a4b679c74cb394">visitMaskedMerge</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a1ff7fad11ba04c97f0a4b679c74cb394"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we have a masked merge, in the canonical form of: (assuming that A only has one use.) | A | |B| ((x ^ y) &amp; M) ^ y | D |.  <br /></td></tr>
<tr class="separator:a1ff7fad11ba04c97f0a4b679c74cb394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e07326546257c169a5aff0d8b822a00"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a0e07326546257c169a5aff0d8b822a00">foldNotXor</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="separator:a0e07326546257c169a5aff0d8b822a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2280e030e66011e1715514cd6965be59"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a2280e030e66011e1715514cd6965be59">canonicalizeAbs</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;Xor, <a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a2280e030e66011e1715514cd6965be59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize a shifty way to code absolute value to the more common pattern that uses negation and select.  <br /></td></tr>
<tr class="separator:a2280e030e66011e1715514cd6965be59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fda26317fcc1b226ecc5a9a28bf68fc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a4fda26317fcc1b226ecc5a9a28bf68fc">canFreelyInvert</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="namespacellvm.html#ab471937b9a227e70c7fe8bd9604014d6">Op</a>, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *IgnoredUser)</td></tr>
<tr class="separator:a4fda26317fcc1b226ecc5a9a28bf68fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf246a84f7e8596777a0231fa7d7bc9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a6bf246a84f7e8596777a0231fa7d7bc9">freelyInvert</a> (<a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="namespacellvm.html#ab471937b9a227e70c7fe8bd9604014d6">Op</a>, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *IgnoredUser)</td></tr>
<tr class="separator:a6bf246a84f7e8596777a0231fa7d7bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;instcombine&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00025">25</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa9c705ecec80ebd584bb3d54b48f7ee1" name="aa9c705ecec80ebd584bb3d54b48f7ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c705ecec80ebd584bb3d54b48f7ee1">&#9670;&#160;</a></span>MaskedICmpType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1">MaskedICmpType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Classify (icmp eq (A &amp; B), C) and (icmp ne (A &amp; B), C) as matching patterns that can be simplified. </p>
<p>One of A and B is considered the mask. The other is the value. This is described as the "AMask" or "BMask" part of the enum. If the enum contains only "Mask", then both A and B can be considered masks. If A is the mask, then it was proven that (A &amp; C) == C. This is trivial if C == A or C == 0. If both A and C are constants, this proof is also easy. For the following explanations, we assume that A is the mask.</p>
<p>"AllOnes" declares that the comparison is true only if (A &amp; B) == A or all bits of A are set in B. Example: (icmp eq (A &amp; 3), 3) -&gt; AMask_AllOnes</p>
<p>"AllZeros" declares that the comparison is true only if (A &amp; B) == 0 or all bits of A are cleared in B. Example: (icmp eq (A &amp; 3), 0) -&gt; Mask_AllZeroes</p>
<p>"Mixed" declares that (A &amp; B) == C and C might or might not contain any number of one bits and zero bits. Example: (icmp eq (A &amp; 3), 1) -&gt; AMask_Mixed</p>
<p>"Not" means that in above descriptions "==" should be replaced by "!=". Example: (icmp ne (A &amp; 3), 3) -&gt; AMask_NotAllOnes</p>
<p>If the mask A contains a single bit, then the following is equivalent: (icmp eq (A &amp; B), A) equals (icmp ne (A &amp; B), 0) (icmp ne (A &amp; B), A) equals (icmp eq (A &amp; B), 0) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a7cc1609a568ad3b240cf86126370e24f" name="aa9c705ecec80ebd584bb3d54b48f7ee1a7cc1609a568ad3b240cf86126370e24f"></a>AMask_AllOnes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a54ee032f1a4a27e3066fbb88346cd49a" name="aa9c705ecec80ebd584bb3d54b48f7ee1a54ee032f1a4a27e3066fbb88346cd49a"></a>AMask_NotAllOnes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a4357ae5a8ec7cec4162a1f25c69558ff" name="aa9c705ecec80ebd584bb3d54b48f7ee1a4357ae5a8ec7cec4162a1f25c69558ff"></a>BMask_AllOnes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a2b00a345b6b0214f7aa5cbe8203aeb3e" name="aa9c705ecec80ebd584bb3d54b48f7ee1a2b00a345b6b0214f7aa5cbe8203aeb3e"></a>BMask_NotAllOnes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a37651a7acaf5871fb8a4d593749c06f4" name="aa9c705ecec80ebd584bb3d54b48f7ee1a37651a7acaf5871fb8a4d593749c06f4"></a>Mask_AllZeros&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1ac7606c30ddb7a593051b6e5ad209f30c" name="aa9c705ecec80ebd584bb3d54b48f7ee1ac7606c30ddb7a593051b6e5ad209f30c"></a>Mask_NotAllZeros&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1ada8a0932439ca5f15218c4d7cd43d895" name="aa9c705ecec80ebd584bb3d54b48f7ee1ada8a0932439ca5f15218c4d7cd43d895"></a>AMask_Mixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a1ee37b18b82ef426e90d86a093d45334" name="aa9c705ecec80ebd584bb3d54b48f7ee1a1ee37b18b82ef426e90d86a093d45334"></a>AMask_NotMixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a3f5a9337c05ff64ea433ed2d4e9d49d5" name="aa9c705ecec80ebd584bb3d54b48f7ee1a3f5a9337c05ff64ea433ed2d4e9d49d5"></a>BMask_Mixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a10e63e798489e9c5ad2dc2c5ed98ac10" name="aa9c705ecec80ebd584bb3d54b48f7ee1a10e63e798489e9c5ad2dc2c5ed98ac10"></a>BMask_NotMixed&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00103">103</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa7934618280f5dc61a34615b689744d1" name="aa7934618280f5dc61a34615b689744d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7934618280f5dc61a34615b689744d1">&#9670;&#160;</a></span>areInverseVectorBitmasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> areInverseVectorBitmasks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>C1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>C2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If all elements of two constant vectors are 0/-1 and inverses, return true. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02962">2962</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Constants_8cpp_source.html#l00418">llvm::Constant::getAggregateElement()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="PatternMatch_8h_source.html#l00461">llvm::PatternMatch::m_AllOnes()</a>, <a class="el" href="PatternMatch_8h_source.html#l00545">llvm::PatternMatch::m_Zero()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

</div>
</div>
<a id="a4fda26317fcc1b226ecc5a9a28bf68fc" name="a4fda26317fcc1b226ecc5a9a28bf68fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fda26317fcc1b226ecc5a9a28bf68fc">&#9670;&#160;</a></span>canFreelyInvert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> canFreelyInvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td>
          <td class="paramname"><em>IgnoredUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04205">4205</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombiner_8h_source.html#l00286">llvm::InstCombiner::canFreelyInvertAllUsersOf()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="InstCombiner_8h_source.html#l00270">llvm::InstCombiner::isFreeToInvert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04228">llvm::InstCombinerImpl::sinkNotIntoLogicalOp()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04274">llvm::InstCombinerImpl::sinkNotIntoOtherHandOfLogicalOp()</a>.</p>

</div>
</div>
<a id="a3f025ca3dbad2ca618ad4bf63fa51bb0" name="a3f025ca3dbad2ca618ad4bf63fa51bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f025ca3dbad2ca618ad4bf63fa51bb0">&#9670;&#160;</a></span>canNarrowShiftAmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> canNarrowShiftAmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Constant.html">Constant</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>BitWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if a constant shift amount is always less than the specified bit-width. </p>
<p>If not, the shift could create poison in the narrower type. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01822">1822</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BitmaskEnum_8h_source.html#l00191">llvm::BitWidth</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="InstrTypes_8h_source.html#l00805">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="PatternMatch_8h_source.html#l00606">llvm::PatternMatch::m_SpecificInt_ICMP()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

</div>
</div>
<a id="a2280e030e66011e1715514cd6965be59" name="a2280e030e66011e1715514cd6965be59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2280e030e66011e1715514cd6965be59">&#9670;&#160;</a></span>canonicalizeAbs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * canonicalizeAbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>Xor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize a shifty way to code absolute value to the more common pattern that uses negation and select. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04174">4174</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830eaec211f7c20af43e742bf2570c3cb84f9">llvm::Add</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Instructions_8h_source.html#l01732">llvm::SelectInst::Create()</a>, <a class="el" href="IRBuilder_8h_source.html#l02537">llvm::IRBuilderBase::CreateIsNeg()</a>, <a class="el" href="IRBuilder_8h_source.html#l01715">llvm::IRBuilderBase::CreateNeg()</a>, <a class="el" href="classllvm_1_1Type.html#a766db71cb4bfd7e802ac613ed98fc6b5">llvm::Type::getScalarSizeInBits()</a>, <a class="el" href="Value_8cpp_source.html#l00149">llvm::Value::hasNUses()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l01126">llvm::PatternMatch::m_AShr()</a>, <a class="el" href="PatternMatch_8h_source.html#l02388">llvm::PatternMatch::m_c_Add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>, and <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830ea76feb79109026728a20736a8c6504548">llvm::Xor</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04511">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
<a id="a7b8ca6f7206a11fd57d6e194b2523ffe" name="a7b8ca6f7206a11fd57d6e194b2523ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8ca6f7206a11fd57d6e194b2523ffe">&#9670;&#160;</a></span>canonicalizeLogicFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * canonicalizeLogicFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02046">2046</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="APInt_8h_source.html#l01583">llvm::APInt::countr_zero()</a>, <a class="el" href="IRBuilder_8h_source.html#l01660">llvm::IRBuilderBase::CreateBinOp()</a>, <a class="el" href="InstrTypes_8h_source.html#l00248">llvm::BinaryOperator::CreateWithCopiedFlags()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="classllvm_1_1Type.html#a766db71cb4bfd7e802ac613ed98fc6b5">llvm::Type::getScalarSizeInBits()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>, <a class="el" href="PatternMatch_8h_source.html#l00982">llvm::PatternMatch::m_Add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02185">llvm::InstCombinerImpl::visitAnd()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03344">llvm::InstCombinerImpl::visitOr()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04511">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
<a id="a09c36c07a47775cef8f8e93d8090d919" name="a09c36c07a47775cef8f8e93d8090d919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c36c07a47775cef8f8e93d8090d919">&#9670;&#160;</a></span>conjugateICmpMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> conjugateICmpMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an analysis of a masked ICmp into its equivalent if all boolean operations had the opposite sense. </p>
<p>Since each "NotXXX" flag (recording !=) is adjacent to the corresponding normal flag (recording ==), this just involves swapping those bits over. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00168">168</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00104">AMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00110">AMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00105">AMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00111">AMask_NotMixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00106">BMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00112">BMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00107">BMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00113">BMask_NotMixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00108">Mask_AllZeros</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00109">Mask_NotAllZeros</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00483">foldLogOpOfMaskedICmps()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00450">foldLogOpOfMaskedICmpsAsymmetric()</a>.</p>

</div>
</div>
<a id="a1d1267ddd1fbc10bd31ab88ecb2109bd" name="a1d1267ddd1fbc10bd31ab88ecb2109bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1267ddd1fbc10bd31ab88ecb2109bd">&#9670;&#160;</a></span>decomposeBitTestICmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> decomposeBitTestICmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CmpInst.html#a2be3583dac92a031fa1458d4d992c78b">CmpInst::Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00182">182</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="CmpInstAnalysis_8cpp_source.html#l00076">llvm::decomposeBitTestICmp()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00075">LHS</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

</div>
</div>
<a id="a940bbfdea38f2643d0b63c2cc5af4a82" name="a940bbfdea38f2643d0b63c2cc5af4a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940bbfdea38f2643d0b63c2cc5af4a82">&#9670;&#160;</a></span>extractIntPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * extractIntPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structIntPart.html">IntPart</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IRBuilderBase.html">IRBuilderBase</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Materialize an extraction of bits from an integer in IR. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01092">1092</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="IRBuilder_8h_source.html#l01431">llvm::IRBuilderBase::CreateLShr()</a>, <a class="el" href="IRBuilder_8h_source.html#l02006">llvm::IRBuilderBase::CreateTrunc()</a>, and <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>.</p>

</div>
</div>
<a id="a45ec897890074179e7de73b934798976" name="a45ec897890074179e7de73b934798976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ec897890074179e7de73b934798976">&#9670;&#160;</a></span>foldAndOrOfICmpEqConstantAndICmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldAndOrOfICmpEqConstantAndICmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsAnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsLogical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IRBuilderBase.html">IRBuilderBase</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03101">3101</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="IRBuilder_8h_source.html#l02518">llvm::IRBuilderBase::CreateFreeze()</a>, <a class="el" href="IRBuilder_8h_source.html#l02334">llvm::IRBuilderBase::CreateICmp()</a>, <a class="el" href="IRBuilder_8h_source.html#l01338">llvm::IRBuilderBase::CreateSub()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00804">llvm::CmpInst::ICMP_UGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00803">llvm::CmpInst::ICMP_UGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00805">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="Type_8h_source.html#l00234">llvm::Type::isIntOrIntVectorTy()</a>, <a class="el" href="APInt_8h_source.html#l00358">llvm::APInt::isZero()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00075">LHS</a>, <a class="el" href="PatternMatch_8h_source.html#l00982">llvm::PatternMatch::m_Add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00284">llvm::PatternMatch::m_APIntAllowUndef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00870">llvm::PatternMatch::m_SpecificIntAllowUndef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="namespacellvm.html#a9eb4f5b98b70ee4fab9614ed58282c1fa6311ae17c1ee52b36e68aaf4ad066387">llvm::Other</a>, and <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>.</p>

</div>
</div>
<a id="afce22397c3eff1d8c0dc8e3d8c464829" name="afce22397c3eff1d8c0dc8e3d8c464829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce22397c3eff1d8c0dc8e3d8c464829">&#9670;&#160;</a></span>foldAndOrOfICmpsWithConstEq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldAndOrOfICmpsWithConstEq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>Cmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>Cmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsAnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsLogical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1SimplifyQuery.html">SimplifyQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce logic-of-compares with equality to a constant by substituting a common operand with the constant. </p>
<p>Callers are expected to call this with Cmp0/Cmp1 switched to handle logic op commutativity. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01178">1178</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="IRBuilder_8h_source.html#l01660">llvm::IRBuilderBase::CreateBinOp()</a>, <a class="el" href="IRBuilder_8h_source.html#l02334">llvm::IRBuilderBase::CreateICmp()</a>, <a class="el" href="IRBuilder_8h_source.html#l01670">llvm::IRBuilderBase::CreateLogicalAnd()</a>, <a class="el" href="IRBuilder_8h_source.html#l01676">llvm::IRBuilderBase::CreateLogicalOr()</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00802">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="ValueTracking_8cpp_source.html#l06927">llvm::isGuaranteedNotToBeUndefOrPoison()</a>, <a class="el" href="PatternMatch_8h_source.html#l02374">llvm::PatternMatch::m_c_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00144">llvm::PatternMatch::m_Constant()</a>, <a class="el" href="PatternMatch_8h_source.html#l00798">llvm::PatternMatch::m_Deferred()</a>, <a class="el" href="PatternMatch_8h_source.html#l01433">llvm::PatternMatch::m_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="InstructionSimplify_8cpp_source.html#l04053">llvm::simplifyICmpInst()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

</div>
</div>
<a id="a385c1da88456d434ee18caa8f48018c2" name="a385c1da88456d434ee18caa8f48018c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385c1da88456d434ee18caa8f48018c2">&#9670;&#160;</a></span>foldAndToXor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldAndToXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01760">1760</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="Instructions_8cpp_source.html#l03008">llvm::BinaryOperator::CreateNot()</a>, <a class="el" href="IRBuilder_8h_source.html#l01513">llvm::IRBuilderBase::CreateXor()</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l00084">llvm::PatternMatch::m_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l02402">llvm::PatternMatch::m_c_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02409">llvm::PatternMatch::m_c_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l00798">llvm::PatternMatch::m_Deferred()</a>, <a class="el" href="PatternMatch_8h_source.html#l02442">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l01102">llvm::PatternMatch::m_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02185">llvm::InstCombinerImpl::visitAnd()</a>.</p>

</div>
</div>
<a id="ae3ba7f841807b297e7c28874c285f538" name="ae3ba7f841807b297e7c28874c285f538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ba7f841807b297e7c28874c285f538">&#9670;&#160;</a></span>foldBitwiseLogicWithIntrinsics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldBitwiseLogicWithIntrinsics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02134">2134</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="APInt_8cpp_source.html#l00715">llvm::APInt::byteSwap()</a>, <a class="el" href="Instructions_8h_source.html#l01519">llvm::CallInst::Create()</a>, <a class="el" href="IRBuilder_8h_source.html#l01660">llvm::IRBuilderBase::CreateBinOp()</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="Function_8cpp_source.html#l01444">llvm::Intrinsic::getDeclaration()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="APInt_8cpp_source.html#l00737">llvm::APInt::reverseBits()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02185">llvm::InstCombinerImpl::visitAnd()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03344">llvm::InstCombinerImpl::visitOr()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04511">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
<a id="ab01a210491dcbefc8db253f4dbaa6497" name="ab01a210491dcbefc8db253f4dbaa6497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01a210491dcbefc8db253f4dbaa6497">&#9670;&#160;</a></span>foldComplexAndOrPatterns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldComplexAndOrPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try folding relatively complex patterns for both And and Or operations with all And and Or swapped. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01870">1870</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="Instructions_8cpp_source.html#l02952">llvm::BinaryOperator::Create()</a>, <a class="el" href="IRBuilder_8h_source.html#l01469">llvm::IRBuilderBase::CreateAnd()</a>, <a class="el" href="IRBuilder_8h_source.html#l01660">llvm::IRBuilderBase::CreateBinOp()</a>, <a class="el" href="Instructions_8cpp_source.html#l03008">llvm::BinaryOperator::CreateNot()</a>, <a class="el" href="IRBuilder_8h_source.html#l01748">llvm::IRBuilderBase::CreateNot()</a>, <a class="el" href="IRBuilder_8h_source.html#l01491">llvm::IRBuilderBase::CreateOr()</a>, <a class="el" href="IRBuilder_8h_source.html#l01513">llvm::IRBuilderBase::CreateXor()</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l00084">llvm::PatternMatch::m_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l02366">llvm::PatternMatch::m_c_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l02416">llvm::PatternMatch::m_c_Xor()</a>, <a class="el" href="PatternMatch_8h_source.html#l00224">llvm::PatternMatch::m_CombineAnd()</a>, <a class="el" href="PatternMatch_8h_source.html#l02442">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830ea3a2d5fe857d8f9541136a124c2edec6c">llvm::Or</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830ea76feb79109026728a20736a8c6504548">llvm::Xor</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02185">llvm::InstCombinerImpl::visitAnd()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03344">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="a6d4527846f6a8b98d7fe16428ff7a28e" name="a6d4527846f6a8b98d7fe16428ff7a28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4527846f6a8b98d7fe16428ff7a28e">&#9670;&#160;</a></span>foldIsPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldIsPowerOf2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>Cmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>Cmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>JoinedByAnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce a pair of compares that check if a value has exactly 1 bit set. </p>
<p>Also used for logical and/or, must be poison safe. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00891">891</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="IRBuilder_8h_source.html#l02224">llvm::IRBuilderBase::CreateICmpEQ()</a>, <a class="el" href="IRBuilder_8h_source.html#l02228">llvm::IRBuilderBase::CreateICmpNE()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="InstrTypes_8h_source.html#l00870">llvm::CmpInst::getPredicate()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00802">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="InstrTypes_8h_source.html#l00803">llvm::CmpInst::ICMP_UGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00805">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="PatternMatch_8h_source.html#l01433">llvm::PatternMatch::m_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00862">llvm::PatternMatch::m_SpecificInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00532">llvm::PatternMatch::m_ZeroInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

</div>
</div>
<a id="a3634e7e4bbadf2cb8229341858f520f3" name="a3634e7e4bbadf2cb8229341858f520f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3634e7e4bbadf2cb8229341858f520f3">&#9670;&#160;</a></span>foldIsPowerOf2OrZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldIsPowerOf2OrZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>Cmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>Cmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsAnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold (icmp eq ctpop(X) 1) | (icmp eq X 0) into (icmp ult ctpop(X) 2) and fold (icmp ne ctpop(X) 1) &amp; (icmp ne X 0) into (icmp ugt ctpop(X) 1). </p>
<p>Also used for logical and/or, must be poison safe. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00871">871</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="IRBuilder_8h_source.html#l02232">llvm::IRBuilderBase::CreateICmpUGT()</a>, <a class="el" href="IRBuilder_8h_source.html#l02240">llvm::IRBuilderBase::CreateICmpULT()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00802">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="PatternMatch_8h_source.html#l01433">llvm::PatternMatch::m_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00862">llvm::PatternMatch::m_SpecificInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00532">llvm::PatternMatch::m_ZeroInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

</div>
</div>
<a id="a45705c727d8388c014471504b4ab0c4e" name="a45705c727d8388c014471504b4ab0c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45705c727d8388c014471504b4ab0c4e">&#9670;&#160;</a></span>foldLogicCastConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldLogicCastConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>Logic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CastInst.html">CastInst</a> *&#160;</td>
          <td class="paramname"><em>Cast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold {and,or,xor} (cast X), C. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01627">1627</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombiner_8h_source.html#l00060">llvm::InstCombiner::Builder</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="IRBuilder_8h_source.html#l01660">llvm::IRBuilderBase::CreateBinOp()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00235">llvm::InstCombinerImpl::getLosslessSignedTrunc()</a>, <a class="el" href="InstCombineInternal_8h_source.html#l00231">llvm::InstCombinerImpl::getLosslessUnsignedTrunc()</a>, <a class="el" href="InstrTypes_8h_source.html#l00402">llvm::BinaryOperator::getOpcode()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="InstrTypes_8h_source.html#l00728">llvm::CastInst::getSrcTy()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l01749">llvm::PatternMatch::m_SExt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01755">llvm::PatternMatch::m_ZExt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

</div>
</div>
<a id="a6c138f9e5e8e5c6a477b297d39d22094" name="a6c138f9e5e8e5c6a477b297d39d22094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c138f9e5e8e5c6a477b297d39d22094">&#9670;&#160;</a></span>foldLogOpOfMaskedICmps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldLogOpOfMaskedICmps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsAnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsLogical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to fold (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y). </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00483">483</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00104">AMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00105">AMask_NotAllOnes</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00106">BMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00112">BMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00107">BMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00113">BMask_NotMixed</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="RISCVRedundantCopyElimination_8cpp_source.html#l00079">CC</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00168">conjugateICmpMask()</a>, <a class="el" href="IRBuilder_8h_source.html#l01469">llvm::IRBuilderBase::CreateAnd()</a>, <a class="el" href="IRBuilder_8h_source.html#l02334">llvm::IRBuilderBase::CreateICmp()</a>, <a class="el" href="IRBuilder_8h_source.html#l01491">llvm::IRBuilderBase::CreateOr()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00450">foldLogOpOfMaskedICmpsAsymmetric()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="InstrTypes_8h_source.html#l00894">llvm::CmpInst::getInversePredicate()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00198">getMaskedTypeForICmpPair()</a>, <a class="el" href="Constants_8cpp_source.html#l00356">llvm::Constant::getNullValue()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00802">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="Instructions_8h_source.html#l01283">llvm::ICmpInst::isEquality()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l06927">llvm::isGuaranteedNotToBeUndefOrPoison()</a>, <a class="el" href="APInt_8h_source.html#l01229">llvm::APInt::isSubsetOf()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00075">LHS</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00108">Mask_AllZeros</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00109">Mask_NotAllZeros</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>.</p>

</div>
</div>
<a id="a30194649427f98c3ceaf7092c83911dc" name="a30194649427f98c3ceaf7092c83911dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30194649427f98c3ceaf7092c83911dc">&#9670;&#160;</a></span>foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsAnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate&#160;</td>
          <td class="paramname"><em>PredL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate&#160;</td>
          <td class="paramname"><em>PredR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to fold (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y), where the left-hand side is of type Mask_NotAllZeros and the right hand side is of type BMask_Mixed. </p>
<p>For example, (icmp (A &amp; 12) != 0) &amp; (icmp (A &amp; 15) == 8) -&gt; (icmp (A &amp; 15) == 8). Also used for logical and/or, must be poison safe. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00328">328</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="IRBuilder_8h_source.html#l01469">llvm::IRBuilderBase::CreateAnd()</a>, <a class="el" href="IRBuilder_8h_source.html#l02334">llvm::IRBuilderBase::CreateICmp()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00802">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="APInt_8h_source.html#l00358">llvm::APInt::isZero()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00075">LHS</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00450">foldLogOpOfMaskedICmpsAsymmetric()</a>.</p>

</div>
</div>
<a id="a6ea6a6eec165567da33302ad84811f84" name="a6ea6a6eec165567da33302ad84811f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea6a6eec165567da33302ad84811f84">&#9670;&#160;</a></span>foldLogOpOfMaskedICmpsAsymmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldLogOpOfMaskedICmpsAsymmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsAnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate&#160;</td>
          <td class="paramname"><em>PredL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate&#160;</td>
          <td class="paramname"><em>PredR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>LHSMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>RHSMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to fold (icmp(A &amp; B) ==/!= 0) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y), where the left-hand side and the right hand side aren't of the common mask pattern type. </p>
<p>Also used for logical and/or, must be poison safe. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00450">450</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00112">BMask_Mixed</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00168">conjugateICmpMask()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00328">foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed()</a>, <a class="el" href="Instructions_8h_source.html#l01283">llvm::ICmpInst::isEquality()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00075">LHS</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00109">Mask_NotAllZeros</a>, and <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00483">foldLogOpOfMaskedICmps()</a>.</p>

</div>
</div>
<a id="a5532e05d5caa4fb5e2b8512aa3095f1e" name="a5532e05d5caa4fb5e2b8512aa3095f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5532e05d5caa4fb5e2b8512aa3095f1e">&#9670;&#160;</a></span>foldNegativePower2AndShiftedMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldNegativePower2AndShiftedMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate&#160;</td>
          <td class="paramname"><em>PredL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate&#160;</td>
          <td class="paramname"><em>PredR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to fold (icmp(A &amp; B) == 0) &amp; (icmp(A &amp; D) != E) into (icmp A u&lt; D) iff B is a contiguous set of ones starting from the most significant bit (negative power of 2), D and E are equal, and D is a contiguous set of ones starting at the most significant zero bit in B. </p>
<p>Parameter B supports masking using undef/poison in either scalar or vector values. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00925">925</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="APInt_8h_source.html#l01568">llvm::APInt::countLeadingOnes()</a>, <a class="el" href="APInt_8h_source.html#l01550">llvm::APInt::countLeadingZeros()</a>, <a class="el" href="IRBuilder_8h_source.html#l02334">llvm::IRBuilderBase::CreateICmp()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00802">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="InstrTypes_8h_source.html#l00805">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="Instructions_8h_source.html#l01283">llvm::ICmpInst::isEquality()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00284">llvm::PatternMatch::m_APIntAllowUndef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00560">llvm::PatternMatch::m_NegatedPower2()</a>, <a class="el" href="PatternMatch_8h_source.html#l00452">llvm::PatternMatch::m_ShiftedMask()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00991">foldPowerOf2AndShiftedMask()</a>.</p>

</div>
</div>
<a id="a0e07326546257c169a5aff0d8b822a00" name="a0e07326546257c169a5aff0d8b822a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e07326546257c169a5aff0d8b822a00">&#9670;&#160;</a></span>foldNotXor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldNotXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04140">4140</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="IRBuilder_8h_source.html#l01748">llvm::IRBuilderBase::CreateNot()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l01096">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02442">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l01102">llvm::PatternMatch::m_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01108">llvm::PatternMatch::m_Xor()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

</div>
</div>
<a id="a26257c73e483eab4b0e15d53340de986" name="a26257c73e483eab4b0e15d53340de986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26257c73e483eab4b0e15d53340de986">&#9670;&#160;</a></span>foldOrToXor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldOrToXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01786">1786</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="IRBuilder_8h_source.html#l01469">llvm::IRBuilderBase::CreateAnd()</a>, <a class="el" href="Instructions_8cpp_source.html#l03008">llvm::BinaryOperator::CreateNot()</a>, <a class="el" href="IRBuilder_8h_source.html#l01513">llvm::IRBuilderBase::CreateXor()</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l01096">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02402">llvm::PatternMatch::m_c_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02409">llvm::PatternMatch::m_c_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l02442">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01108">llvm::PatternMatch::m_Xor()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03344">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="a609a05f40709dea74bb5cd248c5816fd" name="a609a05f40709dea74bb5cd248c5816fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609a05f40709dea74bb5cd248c5816fd">&#9670;&#160;</a></span>foldPowerOf2AndShiftedMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldPowerOf2AndShiftedMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>Cmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>Cmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>JoinedByAnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to fold ((icmp X u&lt; P) &amp; (icmp(X &amp; M) != M)) or ((icmp X s&gt; -1) &amp; (icmp(X &amp; M) != M)) into (icmp X u&lt; M). </p>
<p>Where P is a power of 2, M &lt; P, and M is a contiguous shifted mask starting at the right most significant zero bit in P. SGT is supported as when P is the largest representable power of 2, an earlier optimization converts the expression into (icmp X s&gt; -1). Parameter P supports masking using undef/poison in either scalar or vector values. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00991">991</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00107">BMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00113">BMask_NotMixed</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00925">foldNegativePower2AndShiftedMask()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00198">getMaskedTypeForICmpPair()</a>, <a class="el" href="InstrTypes_8h_source.html#l00870">llvm::CmpInst::getPredicate()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00108">Mask_AllZeros</a>.</p>

</div>
</div>
<a id="a1f569ebf4402ad560d7c147f688ac05a" name="a1f569ebf4402ad560d7c147f688ac05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f569ebf4402ad560d7c147f688ac05a">&#9670;&#160;</a></span>foldSignedTruncationCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldSignedTruncationCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>ICmp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>ICmp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;&#160;</td>
          <td class="paramname"><em>CxtI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General pattern: X &amp; Y. </p>
<p>Where Y is checking that all the high bits (covered by a mask 4294967168) are uniform, i.e. arg &amp; 4294967168 can be either 4294967168 or 0 Pattern can be one of: t = add i32 arg, 128 r = icmp ult i32 t, 256 Or t0 = shl i32 arg, 24 t1 = ashr i32 t0, 24 r = icmp eq i32 t1, arg Or t0 = trunc i32 arg to i8 t1 = sext i8 t0 to i32 r = icmp eq i32 t1, arg This pattern is a signed truncation check.</p>
<p>And X is checking that some bit in that same mask is zero. I.e. can be one of: r = icmp sgt i32 arg, -1 Or t = and i32 arg, 2147483648 r = icmp eq i32 t, 0</p>
<p>Since we are checking that all the bits in that mask are the same, and a particular bit is zero, what we are really checking is that all the masked bits are zero. So this should be transformed to: r = icmp ult i32 arg, 128 </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00774">774</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="IRBuilder_8h_source.html#l02240">llvm::IRBuilderBase::CreateICmpULT()</a>, <a class="el" href="CmpInstAnalysis_8cpp_source.html#l00076">llvm::decomposeBitTestICmp()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="Value_8cpp_source.html#l00309">llvm::Value::getName()</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00239">llvm::Instruction::getOpcode()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="InstrTypes_8h_source.html#l00870">llvm::CmpInst::getPredicate()</a>, <a class="el" href="classllvm_1_1Type.html#a766db71cb4bfd7e802ac613ed98fc6b5">llvm::Type::getScalarSizeInBits()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00805">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="APInt_8h_source.html#l01221">llvm::APInt::intersects()</a>, <a class="el" href="APInt_8h_source.html#l00418">llvm::APInt::isPowerOf2()</a>, <a class="el" href="APInt_8h_source.html#l01229">llvm::APInt::isSubsetOf()</a>, <a class="el" href="APInt_8h_source.html#l00358">llvm::APInt::isZero()</a>, <a class="el" href="PatternMatch_8h_source.html#l00982">llvm::PatternMatch::m_Add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01096">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l01433">llvm::PatternMatch::m_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00552">llvm::PatternMatch::m_Power2()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l01737">llvm::PatternMatch::m_Trunc()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00545">llvm::PatternMatch::m_Zero()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="APInt_8h_source.html#l00851">llvm::APInt::shl()</a>, <a class="el" href="APInt_8h_source.html#l02181">llvm::APIntOps::umin()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="APInt_8cpp_source.html#l00981">llvm::APInt::zext()</a>.</p>

</div>
</div>
<a id="a24dce8fa354f0f1d52209e805f0ae6a3" name="a24dce8fa354f0f1d52209e805f0ae6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dce8fa354f0f1d52209e805f0ae6a3">&#9670;&#160;</a></span>foldUnsignedUnderflowCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * foldUnsignedUnderflowCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>ZeroICmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>UnsignedICmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsAnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1SimplifyQuery.html">SimplifyQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commuted variants are assumed to be handled by calling this function again with the parameters swapped. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01024">1024</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SimplifyQuery_8h_source.html#l00064">llvm::SimplifyQuery::AC</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="IRBuilder_8h_source.html#l02236">llvm::IRBuilderBase::CreateICmpUGE()</a>, <a class="el" href="IRBuilder_8h_source.html#l02240">llvm::IRBuilderBase::CreateICmpULT()</a>, <a class="el" href="IRBuilder_8h_source.html#l01715">llvm::IRBuilderBase::CreateNeg()</a>, <a class="el" href="SimplifyQuery_8h_source.html#l00065">llvm::SimplifyQuery::CxtI</a>, <a class="el" href="SimplifyQuery_8h_source.html#l00061">llvm::SimplifyQuery::DL</a>, <a class="el" href="SimplifyQuery_8h_source.html#l00063">llvm::SimplifyQuery::DT</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00802">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="InstrTypes_8h_source.html#l00804">llvm::CmpInst::ICMP_UGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00805">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="Instructions_8h_source.html#l01283">llvm::ICmpInst::isEquality()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l00279">llvm::isKnownNonZero()</a>, <a class="el" href="PatternMatch_8h_source.html#l02388">llvm::PatternMatch::m_c_Add()</a>, <a class="el" href="PatternMatch_8h_source.html#l02374">llvm::PatternMatch::m_c_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l01433">llvm::PatternMatch::m_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00545">llvm::PatternMatch::m_Zero()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="namespacellvm.html#a9eb4f5b98b70ee4fab9614ed58282c1fa6311ae17c1ee52b36e68aaf4ad066387">llvm::Other</a>, and <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>.</p>

</div>
</div>
<a id="a3b3df3036740dfcdeb37c3ad977b039a" name="a3b3df3036740dfcdeb37c3ad977b039a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3df3036740dfcdeb37c3ad977b039a">&#9670;&#160;</a></span>foldXorToXor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldXorToXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A ^ B can be specified using other logic ops in a variety of patterns. </p>
<p>We can fold these early and efficiently by morphing an existing instruction. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03919">3919</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="Instructions_8cpp_source.html#l03008">llvm::BinaryOperator::CreateNot()</a>, <a class="el" href="IRBuilder_8h_source.html#l01513">llvm::IRBuilderBase::CreateXor()</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l01096">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02402">llvm::PatternMatch::m_c_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02409">llvm::PatternMatch::m_c_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l02416">llvm::PatternMatch::m_c_Xor()</a>, <a class="el" href="PatternMatch_8h_source.html#l00798">llvm::PatternMatch::m_Deferred()</a>, <a class="el" href="PatternMatch_8h_source.html#l02442">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l01102">llvm::PatternMatch::m_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01108">llvm::PatternMatch::m_Xor()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04511">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
<a id="a6bf246a84f7e8596777a0231fa7d7bc9" name="a6bf246a84f7e8596777a0231fa7d7bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf246a84f7e8596777a0231fa7d7bc9">&#9670;&#160;</a></span>freelyInvert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * freelyInvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td>
          <td class="paramname"><em>IgnoredUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04212">4212</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombiner_8h_source.html#l00060">llvm::InstCombiner::Builder</a>, <a class="el" href="IRBuilder_8h_source.html#l01748">llvm::IRBuilderBase::CreateNot()</a>, <a class="el" href="InstructionCombining_8cpp_source.html#l01338">llvm::InstCombinerImpl::freelyInvertAllUsersOf()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="IRBuilder_8h_source.html#l00180">llvm::IRBuilderBase::SetInsertPoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04228">llvm::InstCombinerImpl::sinkNotIntoLogicalOp()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04274">llvm::InstCombinerImpl::sinkNotIntoOtherHandOfLogicalOp()</a>.</p>

</div>
</div>
<a id="ab72e7003829df7704d63a8d830742a35" name="ab72e7003829df7704d63a8d830742a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72e7003829df7704d63a8d830742a35">&#9670;&#160;</a></span>getFCmpValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * getFCmpValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the complement of getFCmpCode, which turns an opcode and two operands into either a FCmp instruction, or a true/false constant. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00041">41</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="IRBuilder_8h_source.html#l02344">llvm::IRBuilderBase::CreateFCmp()</a>, <a class="el" href="CmpInstAnalysis_8cpp_source.html#l00064">llvm::getPredForFCmpCode()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00075">LHS</a>, and <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>.</p>

</div>
</div>
<a id="a39257c6c73db3440e6d05b9eec5999a0" name="a39257c6c73db3440e6d05b9eec5999a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39257c6c73db3440e6d05b9eec5999a0">&#9670;&#160;</a></span>getMaskedICmpType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> getMaskedICmpType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate&#160;</td>
          <td class="paramname"><em>Pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the set of patterns (from MaskedICmpType) that (icmp SCC (A &amp; B), C) satisfies. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00118">118</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00104">AMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00110">AMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00105">AMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00111">AMask_NotMixed</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00106">BMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00112">BMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00107">BMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00113">BMask_NotMixed</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="APInt_8h_source.html#l00418">llvm::APInt::isPowerOf2()</a>, <a class="el" href="APInt_8h_source.html#l01229">llvm::APInt::isSubsetOf()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00108">Mask_AllZeros</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00109">Mask_NotAllZeros</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00198">getMaskedTypeForICmpPair()</a>.</p>

</div>
</div>
<a id="a9216b6f91863c6f4c51e03aa7147c019" name="a9216b6f91863c6f4c51e03aa7147c019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9216b6f91863c6f4c51e03aa7147c019">&#9670;&#160;</a></span>getMaskedTypeForICmpPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt; getMaskedTypeForICmpPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate &amp;&#160;</td>
          <td class="paramname"><em>PredL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate &amp;&#160;</td>
          <td class="paramname"><em>PredR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E). </p>
<p>Return the pattern classes (from MaskedICmpType) for the left hand side and the right hand side as a pair. LHS and RHS are the left hand side and the right hand side ICmps and PredL and PredR are their predicates, respectively. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00198">198</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="CmpInstAnalysis_8cpp_source.html#l00076">llvm::decomposeBitTestICmp()</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="Constants_8cpp_source.html#l00403">llvm::Constant::getAllOnesValue()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00118">getMaskedICmpType()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="Instructions_8h_source.html#l01283">llvm::ICmpInst::isEquality()</a>, <a class="el" href="Type_8h_source.html#l00234">llvm::Type::isIntOrIntVectorTy()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00075">LHS</a>, <a class="el" href="PatternMatch_8h_source.html#l01096">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="MathExtras_8h.html#a9211f62d8e1e6de999eaa63ec0f6ae02">R2</a>, and <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00483">foldLogOpOfMaskedICmps()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00991">foldPowerOf2AndShiftedMask()</a>.</p>

</div>
</div>
<a id="a89cfa00019cb17baa05532705ea198e0" name="a89cfa00019cb17baa05532705ea198e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cfa00019cb17baa05532705ea198e0">&#9670;&#160;</a></span>getNewICmpValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * getNewICmpValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>Sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the complement of getICmpCode, which turns an opcode and two operands into either a constant true or false, or a brand new ICmp instruction. </p>
<p>The sign is passed in to determine which kind of predicate to use in the new icmp instruction. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00031">31</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="IRBuilder_8h_source.html#l02334">llvm::IRBuilderBase::CreateICmp()</a>, <a class="el" href="CmpInstAnalysis_8cpp_source.html#l00040">llvm::getPredForICmpCode()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00075">LHS</a>, and <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>.</p>

</div>
</div>
<a id="a2d3ce43f7795a8f4f6925bffbcc90279" name="a2d3ce43f7795a8f4f6925bffbcc90279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3ce43f7795a8f4f6925bffbcc90279">&#9670;&#160;</a></span>matchDeMorgansLaws()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * matchDeMorgansLaws </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match variations of De Morgan's Laws: (~A &amp; ~B) == (~(A | B)) (~A | ~B) == (~(A &amp; B)) </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01574">1574</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="InstCombiner_8h_source.html#l00060">llvm::InstCombiner::Builder</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="Instructions_8cpp_source.html#l02952">llvm::BinaryOperator::Create()</a>, <a class="el" href="IRBuilder_8h_source.html#l01660">llvm::IRBuilderBase::CreateBinOp()</a>, <a class="el" href="Instructions_8cpp_source.html#l03008">llvm::BinaryOperator::CreateNot()</a>, <a class="el" href="IRBuilder_8h_source.html#l01748">llvm::IRBuilderBase::CreateNot()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="InstCombiner_8h_source.html#l00270">llvm::InstCombiner::isFreeToInvert()</a>, <a class="el" href="PatternMatch_8h_source.html#l02366">llvm::PatternMatch::m_c_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l02442">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02185">llvm::InstCombinerImpl::visitAnd()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03344">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="a22aecfb391040860cfe8c6fa6227ba4a" name="a22aecfb391040860cfe8c6fa6227ba4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22aecfb391040860cfe8c6fa6227ba4a">&#9670;&#160;</a></span>matchFunnelShift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * matchFunnelShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;&#160;</td>
          <td class="paramname"><em>Or</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> &amp;&#160;</td>
          <td class="paramname"><em>DT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match UB-safe variants of the funnel shift intrinsic. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02730">2730</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="InstCombiner_8h_source.html#l00469">llvm::InstCombiner::computeKnownBits()</a>, <a class="el" href="Instructions_8h_source.html#l01519">llvm::CallInst::Create()</a>, <a class="el" href="Dominators_8cpp_source.html#l00122">llvm::DominatorTree::dominates()</a>, <a class="el" href="SmallVector_8h_source.html#l00094">llvm::SmallVectorBase&lt; Size_T &gt;::empty()</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="Constants_8cpp_source.html#l02453">llvm::ConstantExpr::getAdd()</a>, <a class="el" href="Function_8cpp_source.html#l01444">llvm::Intrinsic::getDeclaration()</a>, <a class="el" href="KnownBits_8h_source.html#l00136">llvm::KnownBits::getMaxValue()</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00239">llvm::Instruction::getOpcode()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="NVVMIntrRange_8cpp_source.html#l00061">High</a>, <a class="el" href="InstrTypes_8h_source.html#l00805">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="MathExtras_8h_source.html#l00264">llvm::isPowerOf2_32()</a>, <a class="el" href="namespacellvm.html#a05609d049bfe3c5c2f64711566131a86a28d0edd045e05cf5af64e35ae0c4c6ef">llvm::Low</a>, <a class="el" href="PatternMatch_8h_source.html#l01096">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00284">llvm::PatternMatch::m_APIntAllowUndef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00144">llvm::PatternMatch::m_Constant()</a>, <a class="el" href="PatternMatch_8h_source.html#l00724">llvm::PatternMatch::m_Instruction()</a>, <a class="el" href="PatternMatch_8h_source.html#l01350">llvm::PatternMatch::m_LogicalShift()</a>, <a class="el" href="PatternMatch_8h_source.html#l02424">llvm::PatternMatch::m_Neg()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l01102">llvm::PatternMatch::m_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l01114">llvm::PatternMatch::m_Shl()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00862">llvm::PatternMatch::m_SpecificInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00606">llvm::PatternMatch::m_SpecificInt_ICMP()</a>, <a class="el" href="PatternMatch_8h_source.html#l00870">llvm::PatternMatch::m_SpecificIntAllowUndef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00994">llvm::PatternMatch::m_Sub()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01755">llvm::PatternMatch::m_ZExt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="Constants_8cpp_source.html#l00777">llvm::Constant::mergeUndefsWith()</a>, <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830ea3a2d5fe857d8f9541136a124c2edec6c">llvm::Or</a>, <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>, <a class="el" href="APInt_8h_source.html#l01193">llvm::APInt::uge()</a>, <a class="el" href="APInt_8h_source.html#l01154">llvm::APInt::ugt()</a>, <a class="el" href="APInt_8h_source.html#l01122">llvm::APInt::ule()</a>, <a class="el" href="APInt_8h_source.html#l01083">llvm::APInt::ult()</a>, <a class="el" href="Value_8h_source.html#l00421">llvm::Value::users()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="AggressiveInstCombine_8cpp_source.html#l00053">foldGuardedFunnelShift()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03344">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="a7662d7ee7f100c9455f4a2c7e4992929" name="a7662d7ee7f100c9455f4a2c7e4992929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7662d7ee7f100c9455f4a2c7e4992929">&#9670;&#160;</a></span>matchIntPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt; <a class="el" href="structIntPart.html">IntPart</a> &gt; matchIntPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match an extraction of bits from an integer. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01074">1074</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="APInt_8h_source.html#l01485">llvm::APInt::getZExtValue()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l01120">llvm::PatternMatch::m_LShr()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l01737">llvm::PatternMatch::m_Trunc()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="APInt_8h_source.html#l01122">llvm::APInt::ule()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

</div>
</div>
<a id="a5946d75decfd106d2b75af6d59009f34" name="a5946d75decfd106d2b75af6d59009f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5946d75decfd106d2b75af6d59009f34">&#9670;&#160;</a></span>matchIsFiniteTest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * matchIsFiniteTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1FCmpInst.html">FCmpInst</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1FCmpInst.html">FCmpInst</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>and (fcmp ord x, 0), (fcmp u* x, inf) -&gt; fcmp o* x, inf </p>
<p>Clang emits this pattern for doing an isfinite check in __builtin_isnormal. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01316">1316</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="IRBuilder_8h_source.html#l02344">llvm::IRBuilderBase::CreateFCmp()</a>, <a class="el" href="InstrTypes_8h_source.html#l00905">llvm::CmpInst::getOrderedPredicate()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00075">LHS</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01303">matchIsNotNaN()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01308">matchUnorderedInfCompare()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>, and <a class="el" href="IRBuilder_8h_source.html#l00305">llvm::IRBuilderBase::setFastMathFlags()</a>.</p>

</div>
</div>
<a id="a151e95d3f063067aa27c74930296a25e" name="a151e95d3f063067aa27c74930296a25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151e95d3f063067aa27c74930296a25e">&#9670;&#160;</a></span>matchIsFPClassLikeFCmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> matchIsFPClassLikeFCmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>ClassVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuint64__t.html">uint64_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ClassMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match an fcmp against a special value that performs a test possible by llvm.is.fpclass. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01427">1427</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueTracking_8cpp_source.html#l04000">llvm::fcmpToClassTest()</a>.</p>

</div>
</div>
<a id="a9e92e028c2dd81bf7d518dfc3960624a" name="a9e92e028c2dd81bf7d518dfc3960624a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e92e028c2dd81bf7d518dfc3960624a">&#9670;&#160;</a></span>matchIsNotNaN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> matchIsNotNaN </td>
          <td>(</td>
          <td class="paramtype">FCmpInst::Predicate&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches canonical form of isnan, fcmp ord x, 0. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01303">1303</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstrTypes_8h_source.html#l00789">llvm::CmpInst::FCMP_ORD</a>, <a class="el" href="PatternMatch_8h_source.html#l00672">llvm::PatternMatch::m_AnyZeroFP()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, and <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01316">matchIsFiniteTest()</a>.</p>

</div>
</div>
<a id="a9e6840885acb4ffa3e94e81a70b392fc" name="a9e6840885acb4ffa3e94e81a70b392fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6840885acb4ffa3e94e81a70b392fc">&#9670;&#160;</a></span>matchOrConcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * matchOrConcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;&#160;</td>
          <td class="paramname"><em>Or</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to combine or(zext(x),shl(zext(y),bw/2) concat packing patterns. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02909">2909</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="IRBuilder_8h_source.html#l02395">llvm::IRBuilderBase::CreateCall()</a>, <a class="el" href="IRBuilder_8h_source.html#l01491">llvm::IRBuilderBase::CreateOr()</a>, <a class="el" href="IRBuilder_8h_source.html#l01410">llvm::IRBuilderBase::CreateShl()</a>, <a class="el" href="IRBuilder_8h_source.html#l02010">llvm::IRBuilderBase::CreateZExt()</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="Function_8cpp_source.html#l01444">llvm::Intrinsic::getDeclaration()</a>, <a class="el" href="classllvm_1_1Type.html#a766db71cb4bfd7e802ac613ed98fc6b5">llvm::Type::getScalarSizeInBits()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="namespacellvm.html#a9ac8e4e13ad96a39c3f8db9ed633ad2bac1a5298f939e87e8f962a5edfc206918">llvm::Hi</a>, <a class="el" href="namespacellvm.html#a9ac8e4e13ad96a39c3f8db9ed633ad2baff50b4aa1c9cc2197ef898436641c911">llvm::Lo</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l02301">llvm::PatternMatch::m_BitReverse()</a>, <a class="el" href="PatternMatch_8h_source.html#l02306">llvm::PatternMatch::m_BSwap()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l01114">llvm::PatternMatch::m_Shl()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01755">llvm::PatternMatch::m_ZExt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830ea3a2d5fe857d8f9541136a124c2edec6c">llvm::Or</a>, and <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03344">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="a9977c80be67ea7e51bb37ee242d1cc4c" name="a9977c80be67ea7e51bb37ee242d1cc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9977c80be67ea7e51bb37ee242d1cc4c">&#9670;&#160;</a></span>matchUnorderedInfCompare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> matchUnorderedInfCompare </td>
          <td>(</td>
          <td class="paramtype">FCmpInst::Predicate&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches fcmp u__ x, +/-inf. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01308">1308</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8cpp_source.html#l04411">llvm::CmpInst::isUnordered()</a>, <a class="el" href="PatternMatch_8h_source.html#l00634">llvm::PatternMatch::m_Inf()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, and <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01316">matchIsFiniteTest()</a>.</p>

</div>
</div>
<a id="a8208d3cd3c60073f5c9ceefec06ab2e3" name="a8208d3cd3c60073f5c9ceefec06ab2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8208d3cd3c60073f5c9ceefec06ab2e3">&#9670;&#160;</a></span>reassociateFCmps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * reassociateFCmps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>BO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This a limited reassociation for a special case (see above) where we are checking if two values are either both NAN (unordered) or not-NAN (ordered). </p>
<p>This could be handled more generally in '-reassociation', but it seems like an unlikely pattern for a large number of logic ops and fcmps. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01529">1529</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Instructions_8cpp_source.html#l02952">llvm::BinaryOperator::Create()</a>, <a class="el" href="IRBuilder_8h_source.html#l02344">llvm::IRBuilderBase::CreateFCmp()</a>, <a class="el" href="InstrTypes_8h_source.html#l00789">llvm::CmpInst::FCMP_ORD</a>, <a class="el" href="InstrTypes_8h_source.html#l00790">llvm::CmpInst::FCMP_UNO</a>, <a class="el" href="InstrTypes_8h_source.html#l00402">llvm::BinaryOperator::getOpcode()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="PatternMatch_8h_source.html#l00672">llvm::PatternMatch::m_AnyZeroFP()</a>, <a class="el" href="PatternMatch_8h_source.html#l00084">llvm::PatternMatch::m_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l01439">llvm::PatternMatch::m_FCmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02185">llvm::InstCombinerImpl::visitAnd()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03344">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="ac80e92048884e85b87ddd733785e44d9" name="ac80e92048884e85b87ddd733785e44d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80e92048884e85b87ddd733785e44d9">&#9670;&#160;</a></span>reassociateForUses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * reassociateForUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>BO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombinerImpl::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to reassociate a pair of binops so that values with one use only are part of the same instruction. </p>
<p>This may enable folds that are limited with multi-use restrictions and makes it more likely to match other patterns that are looking for a common operand. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02013">2013</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8cpp_source.html#l02952">llvm::BinaryOperator::Create()</a>, <a class="el" href="IRBuilder_8h_source.html#l01660">llvm::IRBuilderBase::CreateBinOp()</a>, <a class="el" href="InstrTypes_8h_source.html#l00402">llvm::BinaryOperator::getOpcode()</a>, <a class="el" href="PatternMatch_8h_source.html#l00084">llvm::PatternMatch::m_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l02366">llvm::PatternMatch::m_c_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02185">llvm::InstCombinerImpl::visitAnd()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03344">llvm::InstCombinerImpl::visitOr()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04511">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
<a id="a67ccec2dd2fc482ea50af1764f1db598" name="a67ccec2dd2fc482ea50af1764f1db598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ccec2dd2fc482ea50af1764f1db598">&#9670;&#160;</a></span>stripSignOnlyFPOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a> * stripSignOnlyFPOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ignore all operations which only change the sign of a value, returning the underlying magnitude value. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01295">1295</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l02350">llvm::PatternMatch::m_CopySign()</a>, <a class="el" href="PatternMatch_8h_source.html#l02311">llvm::PatternMatch::m_FAbs()</a>, <a class="el" href="PatternMatch_8h_source.html#l01036">llvm::PatternMatch::m_FNeg()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

</div>
</div>
<a id="a1ff7fad11ba04c97f0a4b679c74cb394" name="a1ff7fad11ba04c97f0a4b679c74cb394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff7fad11ba04c97f0a4b679c74cb394">&#9670;&#160;</a></span>visitMaskedMerge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * visitMaskedMerge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#a19c4df37b96c2a73991556b696924584">InstCombiner::BuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we have a masked merge, in the canonical form of: (assuming that A only has one use.) | A | |B| ((x ^ y) &amp; M) ^ y | D |. </p>
<ul>
<li>If M is inverted: | D | ((x ^ y) &amp; ~M) ^ y We can canonicalize by swapping the final xor operand to eliminate the 'not' of the mask. ((x ^ y) &amp; M) ^ x</li>
<li>If M is a constant, and D has one use, we transform to 'and' / 'or' ops because that shortens the dependency chain and improves analysis: (x &amp; M) | (y &amp; ~M) </li>
</ul>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04107">4107</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="IRBuilder_8h_source.html#l01469">llvm::IRBuilderBase::CreateAnd()</a>, <a class="el" href="IRBuilder_8h_source.html#l01748">llvm::IRBuilderBase::CreateNot()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="Constants_8cpp_source.html#l00403">llvm::Constant::getAllOnesValue()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00075">LHS</a>, <a class="el" href="PatternMatch_8h_source.html#l02402">llvm::PatternMatch::m_c_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02416">llvm::PatternMatch::m_c_Xor()</a>, <a class="el" href="PatternMatch_8h_source.html#l00224">llvm::PatternMatch::m_CombineAnd()</a>, <a class="el" href="PatternMatch_8h_source.html#l00144">llvm::PatternMatch::m_Constant()</a>, <a class="el" href="PatternMatch_8h_source.html#l00798">llvm::PatternMatch::m_Deferred()</a>, <a class="el" href="PatternMatch_8h_source.html#l02442">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="Constants_8cpp_source.html#l00753">llvm::Constant::replaceUndefsWith()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04511">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 8 2024 17:12:31 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
