<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;13.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1e8ad0574bd6e387992681ee57691a07.html">CodeGen</a></li><li class="navelem"><a class="el" href="dir_49f0d8a15731052f086a3a1176b385c7.html">LiveDebugValues</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">InstrRefBasedImpl.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This is a separate implementation of <a class="el" href="classLiveDebugValues.html" title="Generic LiveDebugValues pass.">LiveDebugValues</a>, see <a class="el" href="LiveDebugValues_8cpp.html" title="The LiveDebugValues pass extends the range of variable locations (specified by DBG_VALUE instructions...">LiveDebugValues.cpp</a> and <a class="el" href="VarLocBasedImpl_8cpp.html">VarLocBasedImpl.cpp</a> for more information.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="DenseMap_8h_source.html">llvm/ADT/DenseMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PostOrderIterator_8h_source.html">llvm/ADT/PostOrderIterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="STLExtras_8h_source.html">llvm/ADT/STLExtras.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallPtrSet_8h_source.html">llvm/ADT/SmallPtrSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallSet_8h_source.html">llvm/ADT/SmallSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallVector_8h_source.html">llvm/ADT/SmallVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Statistic_8h_source.html">llvm/ADT/Statistic.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="UniqueVector_8h_source.html">llvm/ADT/UniqueVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LexicalScopes_8h_source.html">llvm/CodeGen/LexicalScopes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MachineBasicBlock_8h_source.html">llvm/CodeGen/MachineBasicBlock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MachineFrameInfo_8h_source.html">llvm/CodeGen/MachineFrameInfo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MachineFunction_8h_source.html">llvm/CodeGen/MachineFunction.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MachineFunctionPass_8h_source.html">llvm/CodeGen/MachineFunctionPass.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MachineInstr_8h_source.html">llvm/CodeGen/MachineInstr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MachineInstrBuilder_8h_source.html">llvm/CodeGen/MachineInstrBuilder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MachineInstrBundle_8h_source.html">llvm/CodeGen/MachineInstrBundle.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MachineMemOperand_8h_source.html">llvm/CodeGen/MachineMemOperand.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MachineOperand_8h_source.html">llvm/CodeGen/MachineOperand.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PseudoSourceValue_8h_source.html">llvm/CodeGen/PseudoSourceValue.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="RegisterScavenging_8h_source.html">llvm/CodeGen/RegisterScavenging.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TargetFrameLowering_8h_source.html">llvm/CodeGen/TargetFrameLowering.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TargetInstrInfo_8h_source.html">llvm/CodeGen/TargetInstrInfo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TargetLowering_8h_source.html">llvm/CodeGen/TargetLowering.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TargetPassConfig_8h_source.html">llvm/CodeGen/TargetPassConfig.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TargetRegisterInfo_8h_source.html">llvm/CodeGen/TargetRegisterInfo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TargetSubtargetInfo_8h_source.html">llvm/CodeGen/TargetSubtargetInfo.h</a>&quot;</code><br />
<code>#include &quot;llvm/Config/llvm-config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="DIBuilder_8h_source.html">llvm/IR/DIBuilder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DebugInfoMetadata_8h_source.html">llvm/IR/DebugInfoMetadata.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DebugLoc_8h_source.html">llvm/IR/DebugLoc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Function_8h_source.html">llvm/IR/Function.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Module_8h_source.html">llvm/IR/Module.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InitializePasses_8h_source.html">llvm/InitializePasses.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MCRegisterInfo_8h_source.html">llvm/MC/MCRegisterInfo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Pass_8h_source.html">llvm/Pass.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Casting_8h_source.html">llvm/Support/Casting.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Compiler_8h_source.html">llvm/Support/Compiler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Debug_8h_source.html">llvm/Support/Debug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeSize_8h_source.html">llvm/Support/TypeSize.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="raw__ostream_8h_source.html">llvm/Support/raw_ostream.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="llvm_2Target_2TargetMachine_8h_source.html">llvm/Target/TargetMachine.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SSAUpdaterImpl_8h_source.html">llvm/Transforms/Utils/SSAUpdaterImpl.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;queue&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &quot;<a class="el" href="LiveDebugValues_8h_source.html">LiveDebugValues.h</a>&quot;</code><br />
</div>
<p><a href="InstrRefBasedImpl_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SSAUpdaterTraits_3_01LDVSSAUpdater_01_4.html">llvm::SSAUpdaterTraits&lt; LDVSSAUpdater &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization to give <a class="el" href="classllvm_1_1SSAUpdater.html" title="Helper class for SSA formation on a set of values defined in multiple blocks.">SSAUpdater</a> access to CFG and value information.  <a href="classllvm_1_1SSAUpdaterTraits_3_01LDVSSAUpdater_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1SSAUpdaterTraits_3_01LDVSSAUpdater_01_4_1_1PHI__iterator.html">llvm::SSAUpdaterTraits&lt; LDVSSAUpdater &gt;::PHI_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for PHI operands.  <a href="classllvm_1_1SSAUpdaterTraits_3_01LDVSSAUpdater_01_4_1_1PHI__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacellvm" id="r_namespacellvm"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html">llvm</a></td></tr>
<tr class="memdesc:namespacellvm"><td class="mdescLeft">&#160;</td><td class="mdescRight">---------------------&mdash; PointerInfo ------------------------------------&mdash; <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;livedebugvalues&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09551aadf1cfb2c7160bcd6314b9f748" id="r_a09551aadf1cfb2c7160bcd6314b9f748"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09551aadf1cfb2c7160bcd6314b9f748">NUM_LOC_BITS</a>&#160;&#160;&#160;24</td></tr>
<tr class="separator:a09551aadf1cfb2c7160bcd6314b9f748"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afba85f0d2bfd9c12500fa7c93a6e3f91" id="r_afba85f0d2bfd9c12500fa7c93a6e3f91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afba85f0d2bfd9c12500fa7c93a6e3f91">EmulateOldLDV</a> (&quot;emulate-<a class="el" href="classllvm_1_1ilist__node__impl.html">old</a>-<a class="el" href="classllvm_1_1ilist__node__impl.html">livedebugvalues&quot;</a>, cl::Hidden, <a class="el" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(&quot;Act <a class="el" href="classllvm_1_1ilist__node__impl.html">like</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">old</a> <a class="el" href="classLiveDebugValues.html">LiveDebugValues</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">did&quot;</a>), cl::init(false))</td></tr>
<tr class="separator:afba85f0d2bfd9c12500fa7c93a6e3f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a separate implementation of <a class="el" href="classLiveDebugValues.html" title="Generic LiveDebugValues pass.">LiveDebugValues</a>, see <a class="el" href="LiveDebugValues_8cpp.html" title="The LiveDebugValues pass extends the range of variable locations (specified by DBG_VALUE instructions...">LiveDebugValues.cpp</a> and <a class="el" href="VarLocBasedImpl_8cpp.html">VarLocBasedImpl.cpp</a> for more information. </p>
<p>This pass propagates variable locations between basic blocks, resolving control flow conflicts between them. The problem is much like SSA construction, where each DBG_VALUE instruction assigns the <em>value</em> that a variable has, and every instruction where the variable is in scope uses that variable. The resulting map of instruction-to-value is then translated into a register (or spill) location for each variable over each instruction.</p>
<p>This pass determines which DBG_VALUE dominates which instructions, or if none do, where values must be merged (like PHI nodes). The added complication is that because codegen has already finished, a PHI node may be needed for a variable location to be correct, but no register or spill slot merges the necessary values. In these circumstances, the variable location is dropped.</p>
<p>What makes this analysis non-trivial is loops: we cannot tell in advance whether a variable location is live throughout a loop, or whether its location is clobbered (or redefined by another DBG_VALUE), without exploring all the way through.</p>
<p>To make this simpler we perform two kinds of analysis. First, we identify every value defined by every instruction (ignoring those that only move another value), then compute a map of which values are available for each instruction. This is stronger than a reaching-def analysis, as we create PHI values where other values merge.</p>
<p>Secondly, for each variable, we effectively re-construct SSA using each DBG_VALUE as a def. The DBG_VALUEs read a value-number computed by the first analysis from the location they refer to. We can then compute the dominance frontiers of where a variable has a value, and create PHI nodes where they merge. This isn't precisely SSA-construction though, because the function shape is pre-defined. If a variable location requires a PHI node, but no PHI for the relevant values is present in the function (as computed by the first analysis), the location must be dropped.</p>
<p>Once both are complete, we can pass back over all instructions knowing:</p><ul>
<li>What <em>value</em> each variable should contain, either defined by an instruction or where control flow merges</li>
<li>What the location of that value is (if any). Allowing us to create appropriate live-in DBG_VALUEs, and DBG_VALUEs when a value moves location. After this pass runs, all variable locations within a block should be specified by DBG_VALUEs within that block, allowing DbgEntityHistoryCalculator to focus on individual blocks.</li>
</ul>
<p>This pass is able to go fast because the size of the first reaching-definition analysis is proportional to the working-set size of the function, which the compiler tries to keep small. (It's also proportional to the number of blocks). Additionally, we repeatedly perform the second reaching-definition analysis with only the variables and blocks in a single lexical scope, exploiting their locality.</p>
<p>Determining where PHIs happen is trickier with this approach, and it comes to a head in the major problem for <a class="el" href="classLiveDebugValues.html" title="Generic LiveDebugValues pass.">LiveDebugValues</a>: is a value live-through a loop, or not? Your garden-variety dataflow analysis aims to build a set of facts about a function, however this analysis needs to generate new value numbers at joins.</p>
<p>To do this, consider a lattice of all definition values, from instructions and from PHIs. Each PHI is characterised by the RPO number of the block it occurs in. Each value pair A, B can be ordered by <a class="el" href="FunctionAttrs_8cpp.html#a2444ac2842dce1c6ce602951541038ee">RPO(A)</a> &lt; <a class="el" href="FunctionAttrs_8cpp.html#a2444ac2842dce1c6ce602951541038ee">RPO(B)</a>: with non-PHI values at the top, and any PHI value in the last block (by RPO order) at the bottom.</p>
<p>(Awkwardly: lower-down-the <em>lattice</em> means a greater RPO <em>number</em>. Below, "rank" always refers to the former).</p>
<p>At any join, for each register, we consider:</p><ul>
<li>All incoming values, and</li>
<li>The PREVIOUS live-in value at this join. If all incoming values agree: that's the live-in value. If they do not, the incoming values are ranked according to the partial order, and the NEXT LOWEST rank after the PREVIOUS live-in value is picked (multiple values of the same rank are ignored as conflicting). If there are no candidate values, or if the rank of the live-in would be lower than the rank of the current blocks PHIs, create a new PHI value.</li>
</ul>
<p>Intuitively: if it's not immediately obvious what value a join should result in, we iteratively descend from instruction-definitions down through PHI values, getting closer to the current block each time. If the current block is a loop head, this ordering is effectively searching outer levels of loops, to find a value that's live-through the current loop.</p>
<p>If there is no value that's live-through this loop, a PHI is created for this location instead. We can't use a lower-ranked PHI because by definition it doesn't dominate the current block. We can't create a PHI value any earlier, because we risk creating a PHI value at a location where values do not in fact merge, thus misrepresenting the truth, and not making the true live-through value for variable locations.</p>
<p>This algorithm applies to both calculating the availability of values in the first analysis, and the location of variables in the second. However for the second we add an extra dimension of pain: creating a variable location PHI is only valid if, for each incoming edge,</p><ul>
<li>There is a value for the variable on the incoming edge, and</li>
<li>All the edges have that value in the same register. Or put another way: we can only create a variable-location PHI if there is a matching machine-location PHI, each input to which is the variables value in the predecessor block.</li>
</ul>
<p>To accommodate this difference, each point on the lattice is split in two: a "proposed" PHI and "definite" PHI. Any PHI that can immediately have a location determined are "definite" PHIs, and no further work is needed. Otherwise, a location that all non-backedge predecessors agree on is picked and propagated as a "proposed" PHI value. If that PHI value is truly live-through, it'll appear on the loop backedges on the next dataflow iteration, after which the block live-in moves to be a "definite" PHI. If it's not truly live-through, the variable value will be downgraded further as we explore the lattice, or remains "proposed" and is considered invalid once dataflow completes.</p>
<h3><a class="anchor" id="autotoc_md50"></a>
Terminology</h3>
<p>A machine location is a register or spill slot, a value is something that's defined by an instruction or PHI node, while a variable value is the value assigned to a variable. A variable location is a machine location, that must contain the appropriate variable value. A value that is a PHI node is occasionally called an mphi.</p>
<p>The first dataflow problem is the "machine value location" problem, because we're determining which machine locations contain which values. The "locations" are constant: what's unknown is what value they contain.</p>
<p>The second dataflow problem (the one for variables) is the "variable value
problem", because it's determining what values a variable has, rather than what location those values are placed in. Unfortunately, it's not that simple, because producing a PHI value always involves picking a location. This is an imperfection that we just have to accept, at least for now.</p>
<p>TODO: Overlapping fragments Entry values Add back DEBUG statements for debugging this Collect statistics </p>

<p class="definition">Definition in file <a class="el" href="InstrRefBasedImpl_8cpp_source.html">InstrRefBasedImpl.cpp</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;livedebugvalues&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstrRefBasedImpl_8cpp_source.html#l00208">208</a> of file <a class="el" href="InstrRefBasedImpl_8cpp_source.html">InstrRefBasedImpl.cpp</a>.</p>

</div>
</div>
<a id="a09551aadf1cfb2c7160bcd6314b9f748" name="a09551aadf1cfb2c7160bcd6314b9f748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09551aadf1cfb2c7160bcd6314b9f748">&#9670;&#160;</a></span>NUM_LOC_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_LOC_BITS&#160;&#160;&#160;24</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstrRefBasedImpl_8cpp_source.html#l00243">243</a> of file <a class="el" href="InstrRefBasedImpl_8cpp_source.html">InstrRefBasedImpl.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="afba85f0d2bfd9c12500fa7c93a6e3f91" name="afba85f0d2bfd9c12500fa7c93a6e3f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba85f0d2bfd9c12500fa7c93a6e3f91">&#9670;&#160;</a></span>EmulateOldLDV</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; EmulateOldLDV(&quot;emulate-<a class="el" href="classllvm_1_1ilist__node__impl.html">old</a>-<a class="el" href="classllvm_1_1ilist__node__impl.html">livedebugvalues&quot;</a>, cl::Hidden, <a class="el" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(&quot;Act <a class="el" href="classllvm_1_1ilist__node__impl.html">like</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">old</a> <a class="el" href="classLiveDebugValues.html">LiveDebugValues</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">did&quot;</a>), cl::init(false)) </td>
          <td>(</td>
          <td class="paramtype">&quot;emulate-<a class="el" href="classllvm_1_1ilist__node__impl.html">old</a>-<a class="el" href="classllvm_1_1ilist__node__impl.html">livedebugvalues&quot;</a></td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::Hidden</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(&quot;Act <a class="el" href="classllvm_1_1ilist__node__impl.html">like</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">old</a> <a class="el" href="classLiveDebugValues.html">LiveDebugValues</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">did&quot;</a>)</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::init(false)</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 20 2024 17:56:05 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
