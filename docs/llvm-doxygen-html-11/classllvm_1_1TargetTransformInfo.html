<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: llvm::TargetTransformInfo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;11.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacellvm.html">llvm</a></li><li class="navelem"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classllvm_1_1TargetTransformInfo-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">llvm::TargetTransformInfo Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This pass provides access to the codegen interfaces that are needed for IR-level transformations.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="TargetTransformInfo_8h_source.html">llvm/Analysis/TargetTransformInfo.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1LSRCost.html">LSRCost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1MemCmpExpansionOptions.html">MemCmpExpansionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns options for expansion of memcmp. IsZeroCmp is.  <a href="structllvm_1_1TargetTransformInfo_1_1MemCmpExpansionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1PeelingPreferences.html">PeelingPreferences</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1ReductionData.html">ReductionData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains opcode + LHS/RHS parts of the reduction operations.  <a href="structllvm_1_1TargetTransformInfo_1_1ReductionData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1ReductionFlags.html">ReductionFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags describing the kind of vector reduction.  <a href="structllvm_1_1TargetTransformInfo_1_1ReductionFlags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html">UnrollingPreferences</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters that control the generic loop unrolling transformation.  <a href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af1bf12b2f33b7e30f8f361a1e7642079" id="r_af1bf12b2f33b7e30f8f361a1e7642079"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:af1bf12b2f33b7e30f8f361a1e7642079"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1bf12b2f33b7e30f8f361a1e7642079">TargetTransformInfo</a> (<a class="el" href="classT.html">T</a> Impl)</td></tr>
<tr class="memdesc:af1bf12b2f33b7e30f8f361a1e7642079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a TTI object using a type implementing the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below.  <br /></td></tr>
<tr class="separator:af1bf12b2f33b7e30f8f361a1e7642079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b62dddca1c89d43af02d0e2ab06030" id="r_ac7b62dddca1c89d43af02d0e2ab06030"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7b62dddca1c89d43af02d0e2ab06030">TargetTransformInfo</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;<a class="el" href="AArch64SLSHardening_8cpp.html#ad467c4ab9119043f9b7750ab986be61a">DL</a>)</td></tr>
<tr class="memdesc:ac7b62dddca1c89d43af02d0e2ab06030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a baseline TTI object using a minimal implementation of the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below.  <br /></td></tr>
<tr class="separator:ac7b62dddca1c89d43af02d0e2ab06030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab158463a734f57c86e685364527ebaa4" id="r_ab158463a734f57c86e685364527ebaa4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab158463a734f57c86e685364527ebaa4">TargetTransformInfo</a> (<a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;<a class="el" href="AMDGPULibCalls_8cpp.html#afecf1cc1292b07f57d343c0f4d682044">Arg</a>)</td></tr>
<tr class="separator:ab158463a734f57c86e685364527ebaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d955ca0eda3479b562ccc505575049b" id="r_a6d955ca0eda3479b562ccc505575049b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d955ca0eda3479b562ccc505575049b">operator=</a> (<a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;RHS)</td></tr>
<tr class="separator:a6d955ca0eda3479b562ccc505575049b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e9d106cef4491370c43c4f136fc050" id="r_af9e9d106cef4491370c43c4f136fc050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9e9d106cef4491370c43c4f136fc050">~TargetTransformInfo</a> ()</td></tr>
<tr class="separator:af9e9d106cef4491370c43c4f136fc050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2528c700b439460d668d188813ebf08c" id="r_a2528c700b439460d668d188813ebf08c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2528c700b439460d668d188813ebf08c">invalidate</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1PreservedAnalyses.html">PreservedAnalyses</a> &amp;, <a class="el" href="classllvm_1_1AnalysisManager_1_1Invalidator.html">FunctionAnalysisManager::Invalidator</a> &amp;)</td></tr>
<tr class="memdesc:a2528c700b439460d668d188813ebf08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the invalidation of this information.  <br /></td></tr>
<tr class="separator:a2528c700b439460d668d188813ebf08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vector Predication Information</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Whether the target supports the evl parameter of VP intrinsic efficiently in hardware.</p>
<p>(see LLVM Language Reference - "Vector Predication
Intrinsics") <a class="el" href="classllvm_1_1Use.html" title="A Use represents the edge between a Value definition and its users.">Use</a> of evl is discouraged when that is not the case. </p>
</div></td></tr>
<tr class="memitem:aa2374d75320454634f43cb4146236e95" id="r_aa2374d75320454634f43cb4146236e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2374d75320454634f43cb4146236e95">hasActiveVectorLength</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aa2374d75320454634f43cb4146236e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Generic Target Information</h2></td></tr>
<tr class="memitem:a706f223f760b55668fbae74202b816bb" id="r_a706f223f760b55668fbae74202b816bb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> { <a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TCK_RecipThroughput</a>
, <a class="el" href="#a706f223f760b55668fbae74202b816bba81b2c6f1f1e13e4a575e6d1c8b29b6e1">TCK_Latency</a>
, <a class="el" href="#a706f223f760b55668fbae74202b816bba737cfc93e5a2ff961677d57186167e7c">TCK_CodeSize</a>
, <a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TCK_SizeAndLatency</a>
 }</td></tr>
<tr class="memdesc:a706f223f760b55668fbae74202b816bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of cost model.  <a href="#a706f223f760b55668fbae74202b816bb">More...</a><br /></td></tr>
<tr class="separator:a706f223f760b55668fbae74202b816bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44f6b9fdbb5f9cc199f8329cb0b272c" id="r_ac44f6b9fdbb5f9cc199f8329cb0b272c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac44f6b9fdbb5f9cc199f8329cb0b272c">TargetCostConstants</a> { <a class="el" href="#ac44f6b9fdbb5f9cc199f8329cb0b272ca89f768b1267e3083b4eb05b4ab77e717">TCC_Free</a> = 0
, <a class="el" href="#ac44f6b9fdbb5f9cc199f8329cb0b272cae46c9eecc49bd2dc253c607e78a0fb86">TCC_Basic</a> = 1
, <a class="el" href="#ac44f6b9fdbb5f9cc199f8329cb0b272ca022565d444ccf496c0414bccefbcd9c8">TCC_Expensive</a> = 4
 }</td></tr>
<tr class="memdesc:ac44f6b9fdbb5f9cc199f8329cb0b272c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying constants for 'cost' values in this interface.  <a href="#ac44f6b9fdbb5f9cc199f8329cb0b272c">More...</a><br /></td></tr>
<tr class="separator:ac44f6b9fdbb5f9cc199f8329cb0b272c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b4e8542880166eab65f6552524b385" id="r_a13b4e8542880166eab65f6552524b385"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13b4e8542880166eab65f6552524b385">getInstructionCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> kind) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a13b4e8542880166eab65f6552524b385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the cost of a specified instruction.  <br /></td></tr>
<tr class="separator:a13b4e8542880166eab65f6552524b385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fb6bdf8c0631c76b6180f855cf0876" id="r_ac1fb6bdf8c0631c76b6180f855cf0876"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1fb6bdf8c0631c76b6180f855cf0876">getGEPCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">PointeeType</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; <a class="el" href="MIRNamerPass_8cpp.html#a05e4be4ec3e2c3587dda0e376bb6822c">Operands</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TCK_SizeAndLatency</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac1fb6bdf8c0631c76b6180f855cf0876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of a GEP operation when lowered.  <br /></td></tr>
<tr class="separator:ac1fb6bdf8c0631c76b6180f855cf0876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab827381fb7034818435387572088683" id="r_aab827381fb7034818435387572088683"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab827381fb7034818435387572088683">getInliningThresholdMultiplier</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aab827381fb7034818435387572088683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30e16357eef0a6bb3dc98fb7fd67684" id="r_aa30e16357eef0a6bb3dc98fb7fd67684"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa30e16357eef0a6bb3dc98fb7fd67684">getInlinerVectorBonusPercent</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aa30e16357eef0a6bb3dc98fb7fd67684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfde6fed613809d141d1f84ff3c4cf8d" id="r_abfde6fed613809d141d1f84ff3c4cf8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfde6fed613809d141d1f84ff3c4cf8d">getMemcpyCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:abfde6fed613809d141d1f84ff3c4cf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b0a3c3724fe2cb1b335007c068179d" id="r_a64b0a3c3724fe2cb1b335007c068179d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64b0a3c3724fe2cb1b335007c068179d">getEstimatedNumberOfCaseClusters</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SwitchInst.html">SwitchInst</a> &amp;SI, <a class="el" href="classunsigned.html">unsigned</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">JTSize</a>, <a class="el" href="classllvm_1_1ProfileSummaryInfo.html">ProfileSummaryInfo</a> *PSI, <a class="el" href="classllvm_1_1BlockFrequencyInfo.html">BlockFrequencyInfo</a> *BFI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a64b0a3c3724fe2cb1b335007c068179d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4561fdeb3aa9e2787cba13dd4ad3244" id="r_ab4561fdeb3aa9e2787cba13dd4ad3244"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4561fdeb3aa9e2787cba13dd4ad3244">getUserCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1User.html">User</a> *U, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; <a class="el" href="MIRNamerPass_8cpp.html#a05e4be4ec3e2c3587dda0e376bb6822c">Operands</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab4561fdeb3aa9e2787cba13dd4ad3244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of a given IR user when lowered.  <br /></td></tr>
<tr class="separator:ab4561fdeb3aa9e2787cba13dd4ad3244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab732975bf823facb36f2d20b26c3478c" id="r_ab732975bf823facb36f2d20b26c3478c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab732975bf823facb36f2d20b26c3478c">getUserCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1User.html">User</a> *U, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab732975bf823facb36f2d20b26c3478c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function which calls the two-argument getUserCost with <code>Operands</code> which are the current operands U has.  <br /></td></tr>
<tr class="separator:ab732975bf823facb36f2d20b26c3478c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b137bcf194671c30aba4e2fab073d" id="r_a1c0b137bcf194671c30aba4e2fab073d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c0b137bcf194671c30aba4e2fab073d">hasBranchDivergence</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a1c0b137bcf194671c30aba4e2fab073d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if branch divergence exists.  <br /></td></tr>
<tr class="separator:a1c0b137bcf194671c30aba4e2fab073d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf36efea43204c6a4c9b219c8f9acaf5" id="r_aaf36efea43204c6a4c9b219c8f9acaf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf36efea43204c6a4c9b219c8f9acaf5">useGPUDivergenceAnalysis</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aaf36efea43204c6a4c9b219c8f9acaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target prefers to use GPU divergence analysis to replace the legacy version.  <br /></td></tr>
<tr class="separator:aaf36efea43204c6a4c9b219c8f9acaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787ddce53dcb1b93b5c173dbbba4d3f0" id="r_a787ddce53dcb1b93b5c173dbbba4d3f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a787ddce53dcb1b93b5c173dbbba4d3f0">isSourceOfDivergence</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *V) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a787ddce53dcb1b93b5c173dbbba4d3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether V is a source of divergence.  <br /></td></tr>
<tr class="separator:a787ddce53dcb1b93b5c173dbbba4d3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b21625ceb4a9d9eb225fa18cbf951de" id="r_a1b21625ceb4a9d9eb225fa18cbf951de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b21625ceb4a9d9eb225fa18cbf951de">isAlwaysUniform</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *V) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a1b21625ceb4a9d9eb225fa18cbf951de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e74cc1819ce2f8f151a1900284ce89" id="r_a93e74cc1819ce2f8f151a1900284ce89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93e74cc1819ce2f8f151a1900284ce89">getFlatAddressSpace</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a93e74cc1819ce2f8f151a1900284ce89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address space ID for a target's 'flat' address space.  <br /></td></tr>
<tr class="separator:a93e74cc1819ce2f8f151a1900284ce89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7313158dcc10a1569a2333c78cde8621" id="r_a7313158dcc10a1569a2333c78cde8621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7313158dcc10a1569a2333c78cde8621">collectFlatAddressOperands</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int &gt; &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">OpIndexes</a>, <a class="el" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a> IID) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7313158dcc10a1569a2333c78cde8621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return any intrinsic address operand indexes which may be rewritten if they use a flat address space pointer.  <br /></td></tr>
<tr class="separator:a7313158dcc10a1569a2333c78cde8621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c845c07da9fd93a05ec29509486166" id="r_a50c845c07da9fd93a05ec29509486166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50c845c07da9fd93a05ec29509486166">isNoopAddrSpaceCast</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">FromAS</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ToAS</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a50c845c07da9fd93a05ec29509486166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bd45e10d1f1069da1b4d216d0f5f73" id="r_a88bd45e10d1f1069da1b4d216d0f5f73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88bd45e10d1f1069da1b4d216d0f5f73">rewriteIntrinsicWithAddressSpace</a> (<a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *II, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">OldV</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">NewV</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a88bd45e10d1f1069da1b4d216d0f5f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite intrinsic call <code>II</code> such that <code>OldV</code> will be replaced with <code>NewV</code>, which has a different address space.  <br /></td></tr>
<tr class="separator:a88bd45e10d1f1069da1b4d216d0f5f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b08fb48c8c58e63aa231a1099475d9" id="r_aa8b08fb48c8c58e63aa231a1099475d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8b08fb48c8c58e63aa231a1099475d9">isLoweredToCall</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa8b08fb48c8c58e63aa231a1099475d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether calls to a function lower to actual program function calls.  <br /></td></tr>
<tr class="separator:aa8b08fb48c8c58e63aa231a1099475d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6c1c398e1c18db2de1bacbd80e332f" id="r_add6c1c398e1c18db2de1bacbd80e332f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add6c1c398e1c18db2de1bacbd80e332f">getUnrollingPreferences</a> (<a class="el" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html">UnrollingPreferences</a> &amp;UP) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:add6c1c398e1c18db2de1bacbd80e332f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target-customized preferences for the generic loop unrolling transformation.  <br /></td></tr>
<tr class="separator:add6c1c398e1c18db2de1bacbd80e332f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae1d7de61213a91194e93174081ab4d" id="r_aaae1d7de61213a91194e93174081ab4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaae1d7de61213a91194e93174081ab4d">isHardwareLoopProfitable</a> (<a class="el" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> &amp;AC, <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *LibInfo, <a class="el" href="structllvm_1_1HardwareLoopInfo.html">HardwareLoopInfo</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">HWLoopInfo</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aaae1d7de61213a91194e93174081ab4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target whether it would be profitable to convert the given loop into a hardware loop.  <br /></td></tr>
<tr class="separator:aaae1d7de61213a91194e93174081ab4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7384797683527a3c112a0bc709d5c659" id="r_a7384797683527a3c112a0bc709d5c659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7384797683527a3c112a0bc709d5c659">preferPredicateOverEpilogue</a> (<a class="el" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="el" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *LI, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> &amp;AC, <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *TLI, <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LoopAccessInfo.html">LoopAccessInfo</a> *LAI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7384797683527a3c112a0bc709d5c659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target whether it would be prefered to create a predicated vector loop, which can avoid the need to emit a scalar epilogue loop.  <br /></td></tr>
<tr class="separator:a7384797683527a3c112a0bc709d5c659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0140d82d8d964cfee71b718641bf4aa8" id="r_a0140d82d8d964cfee71b718641bf4aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0140d82d8d964cfee71b718641bf4aa8">emitGetActiveLaneMask</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0140d82d8d964cfee71b718641bf4aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target whether lowering of the llvm.get.active.lane.mask intrinsic is supported.  <br /></td></tr>
<tr class="separator:a0140d82d8d964cfee71b718641bf4aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af513fb5e9b4731b5b8315d757d5a252f" id="r_af513fb5e9b4731b5b8315d757d5a252f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af513fb5e9b4731b5b8315d757d5a252f">getPeelingPreferences</a> (<a class="el" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1PeelingPreferences.html">PeelingPreferences</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">PP</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af513fb5e9b4731b5b8315d757d5a252f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target-customized preferences for the generic loop peeling transformation.  <br /></td></tr>
<tr class="separator:af513fb5e9b4731b5b8315d757d5a252f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Scalar Target Information</h2></td></tr>
<tr class="memitem:aa4c17e89b1ef061ed69f42b7cee93dbe" id="r_aa4c17e89b1ef061ed69f42b7cee93dbe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbe">PopcntSupportKind</a> { <a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbea0ce99a3a4fe2b7f2771a7b288a99ed2c">PSK_Software</a>
, <a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbea01deb9d0bc6399399b0d8377bd09201d">PSK_SlowHardware</a>
, <a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbeac71465fd61f1ba8aa2c7c397722b5e05">PSK_FastHardware</a>
 }</td></tr>
<tr class="memdesc:aa4c17e89b1ef061ed69f42b7cee93dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags indicating the kind of support for population count.  <a href="#aa4c17e89b1ef061ed69f42b7cee93dbe">More...</a><br /></td></tr>
<tr class="separator:aa4c17e89b1ef061ed69f42b7cee93dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5c32f4b5bd13b1279016cd9a6db37b" id="r_a7f5c32f4b5bd13b1279016cd9a6db37b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f5c32f4b5bd13b1279016cd9a6db37b">isLegalAddImmediate</a> (int64_t Imm) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7f5c32f4b5bd13b1279016cd9a6db37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified immediate is legal add immediate, that is the target has add instructions which can add a register with the immediate without having to materialize the immediate into a register.  <br /></td></tr>
<tr class="separator:a7f5c32f4b5bd13b1279016cd9a6db37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ff38d597ee5f9da28bb64c812520d8" id="r_a78ff38d597ee5f9da28bb64c812520d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78ff38d597ee5f9da28bb64c812520d8">isLegalICmpImmediate</a> (int64_t Imm) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a78ff38d597ee5f9da28bb64c812520d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified immediate is legal icmp immediate, that is the target has icmp instructions which can compare a register against the immediate without having to materialize the immediate into a register.  <br /></td></tr>
<tr class="separator:a78ff38d597ee5f9da28bb64c812520d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c84ca19e254840865cd33cc5aaedb81" id="r_a5c84ca19e254840865cd33cc5aaedb81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c84ca19e254840865cd33cc5aaedb81">isLegalAddressingMode</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *BaseGV, int64_t BaseOffset, <a class="el" href="classbool.html">bool</a> HasBaseReg, int64_t Scale, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace=0, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5c84ca19e254840865cd33cc5aaedb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the addressing mode represented by AM is legal for this target, for a load/store of the specified type.  <br /></td></tr>
<tr class="separator:a5c84ca19e254840865cd33cc5aaedb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d868fd1e5fa04b220b13bb42d0b90e" id="r_a90d868fd1e5fa04b220b13bb42d0b90e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90d868fd1e5fa04b220b13bb42d0b90e">isLSRCostLess</a> (<a class="el" href="structllvm_1_1TargetTransformInfo_1_1LSRCost.html">TargetTransformInfo::LSRCost</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">C1</a>, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1LSRCost.html">TargetTransformInfo::LSRCost</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">C2</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a90d868fd1e5fa04b220b13bb42d0b90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if LSR cost of C1 is lower than C1.  <br /></td></tr>
<tr class="separator:a90d868fd1e5fa04b220b13bb42d0b90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5b11c76ffc12a4dde038d77dc4d5ae" id="r_a2c5b11c76ffc12a4dde038d77dc4d5ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c5b11c76ffc12a4dde038d77dc4d5ae">isProfitableLSRChainElement</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a2c5b11c76ffc12a4dde038d77dc4d5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5711c8e7ef4d1848c44e839242316c3" id="r_ad5711c8e7ef4d1848c44e839242316c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5711c8e7ef4d1848c44e839242316c3">canMacroFuseCmp</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad5711c8e7ef4d1848c44e839242316c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target can fuse a compare and branch.  <br /></td></tr>
<tr class="separator:ad5711c8e7ef4d1848c44e839242316c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884326e08a0f3d72b4f5006cf31eb76f" id="r_a884326e08a0f3d72b4f5006cf31eb76f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a884326e08a0f3d72b4f5006cf31eb76f">canSaveCmp</a> (<a class="el" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="el" href="classllvm_1_1BranchInst.html">BranchInst</a> **BI, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE, <a class="el" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *LI, <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC, <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *LibInfo) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a884326e08a0f3d72b4f5006cf31eb76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target can save a compare for loop count, for example hardware loop saves a compare.  <br /></td></tr>
<tr class="separator:a884326e08a0f3d72b4f5006cf31eb76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d223e0e64b5c839d91db0ca11bc4390" id="r_a5d223e0e64b5c839d91db0ca11bc4390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d223e0e64b5c839d91db0ca11bc4390">shouldFavorPostInc</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a5d223e0e64b5c839d91db0ca11bc4390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44209c5b1486b375c5d2ee304fc2b535" id="r_a44209c5b1486b375c5d2ee304fc2b535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44209c5b1486b375c5d2ee304fc2b535">shouldFavorBackedgeIndex</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Loop.html">Loop</a> *L) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a44209c5b1486b375c5d2ee304fc2b535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if LSR should make efforts to generate indexed addressing modes that operate across loop iterations.  <br /></td></tr>
<tr class="separator:a44209c5b1486b375c5d2ee304fc2b535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bcc7733985bba3ab58e5c2abbc129e" id="r_ab9bcc7733985bba3ab58e5c2abbc129e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9bcc7733985bba3ab58e5c2abbc129e">isLegalMaskedStore</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab9bcc7733985bba3ab58e5c2abbc129e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked store.  <br /></td></tr>
<tr class="separator:ab9bcc7733985bba3ab58e5c2abbc129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5a70644f05b7731348861016ff2af1" id="r_aff5a70644f05b7731348861016ff2af1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff5a70644f05b7731348861016ff2af1">isLegalMaskedLoad</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aff5a70644f05b7731348861016ff2af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked load.  <br /></td></tr>
<tr class="separator:aff5a70644f05b7731348861016ff2af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923b761c973df44658c12ab18b29365c" id="r_a923b761c973df44658c12ab18b29365c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a923b761c973df44658c12ab18b29365c">isLegalNTStore</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a923b761c973df44658c12ab18b29365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports nontemporal store.  <br /></td></tr>
<tr class="separator:a923b761c973df44658c12ab18b29365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdad414050f44dd51fe2c193b7992b6" id="r_a7bdad414050f44dd51fe2c193b7992b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bdad414050f44dd51fe2c193b7992b6">isLegalNTLoad</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7bdad414050f44dd51fe2c193b7992b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports nontemporal load.  <br /></td></tr>
<tr class="separator:a7bdad414050f44dd51fe2c193b7992b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a973aabc3b5429e5e05beee35892de0" id="r_a0a973aabc3b5429e5e05beee35892de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a973aabc3b5429e5e05beee35892de0">isLegalMaskedScatter</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0a973aabc3b5429e5e05beee35892de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked scatter.  <br /></td></tr>
<tr class="separator:a0a973aabc3b5429e5e05beee35892de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac7704be5bd5455f78caf0b5371012" id="r_a33ac7704be5bd5455f78caf0b5371012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33ac7704be5bd5455f78caf0b5371012">isLegalMaskedGather</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a33ac7704be5bd5455f78caf0b5371012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked gather.  <br /></td></tr>
<tr class="separator:a33ac7704be5bd5455f78caf0b5371012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f71d89b22106738d72d963725f0860" id="r_a78f71d89b22106738d72d963725f0860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78f71d89b22106738d72d963725f0860">isLegalMaskedCompressStore</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a78f71d89b22106738d72d963725f0860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked compress store.  <br /></td></tr>
<tr class="separator:a78f71d89b22106738d72d963725f0860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa143359355225ce76a666b1758bb2d3d" id="r_aa143359355225ce76a666b1758bb2d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa143359355225ce76a666b1758bb2d3d">isLegalMaskedExpandLoad</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa143359355225ce76a666b1758bb2d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked expand load.  <br /></td></tr>
<tr class="separator:aa143359355225ce76a666b1758bb2d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31bf22f119c5a99c36646d8e0eb2c0f" id="r_ac31bf22f119c5a99c36646d8e0eb2c0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac31bf22f119c5a99c36646d8e0eb2c0f">hasDivRemOp</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="classbool.html">bool</a> IsSigned) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac31bf22f119c5a99c36646d8e0eb2c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target has a unified operation to calculate division and remainder.  <br /></td></tr>
<tr class="separator:ac31bf22f119c5a99c36646d8e0eb2c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33e1370498d06e0760c2861ff25e43a" id="r_ab33e1370498d06e0760c2861ff25e43a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab33e1370498d06e0760c2861ff25e43a">hasVolatileVariant</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab33e1370498d06e0760c2861ff25e43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given instruction (assumed to be a memory access instruction) has a volatile variant.  <br /></td></tr>
<tr class="separator:ab33e1370498d06e0760c2861ff25e43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215ea3605f88c5b21ffbdf76a72a8554" id="r_a215ea3605f88c5b21ffbdf76a72a8554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a215ea3605f88c5b21ffbdf76a72a8554">prefersVectorizedAddressing</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a215ea3605f88c5b21ffbdf76a72a8554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if target doesn't mind addresses in vectors.  <br /></td></tr>
<tr class="separator:a215ea3605f88c5b21ffbdf76a72a8554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae66a93e348639259141a46230239c13" id="r_aae66a93e348639259141a46230239c13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae66a93e348639259141a46230239c13">getScalingFactorCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *BaseGV, int64_t BaseOffset, <a class="el" href="classbool.html">bool</a> HasBaseReg, int64_t Scale, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace=0) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aae66a93e348639259141a46230239c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cost of the scaling factor used in the addressing mode represented by AM for this target, for a load/store of the specified type.  <br /></td></tr>
<tr class="separator:aae66a93e348639259141a46230239c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4746d964f754f53ce75d48a418196674" id="r_a4746d964f754f53ce75d48a418196674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4746d964f754f53ce75d48a418196674">LSRWithInstrQueries</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a4746d964f754f53ce75d48a418196674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the loop strength reduce pass should make Instruction* based TTI queries to <a class="el" href="#a5c84ca19e254840865cd33cc5aaedb81" title="Return true if the addressing mode represented by AM is legal for this target, for a load/store of th...">isLegalAddressingMode()</a>.  <br /></td></tr>
<tr class="separator:a4746d964f754f53ce75d48a418196674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e55cf13c60a8b90145f1411367b975" id="r_ae3e55cf13c60a8b90145f1411367b975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3e55cf13c60a8b90145f1411367b975">isTruncateFree</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Ty1</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Ty2</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae3e55cf13c60a8b90145f1411367b975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it's free to truncate a value of type Ty1 to type Ty2.  <br /></td></tr>
<tr class="separator:ae3e55cf13c60a8b90145f1411367b975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcbf4e3010950dd8ea0be1c4b0d3281" id="r_aafcbf4e3010950dd8ea0be1c4b0d3281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafcbf4e3010950dd8ea0be1c4b0d3281">isProfitableToHoist</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aafcbf4e3010950dd8ea0be1c4b0d3281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is profitable to hoist instruction in the then/else to before if.  <br /></td></tr>
<tr class="separator:aafcbf4e3010950dd8ea0be1c4b0d3281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98deb6721fb0ac45c41f71b800700596" id="r_a98deb6721fb0ac45c41f71b800700596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98deb6721fb0ac45c41f71b800700596">useAA</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a98deb6721fb0ac45c41f71b800700596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a84209b8495d8fd3d2799eb01f1ab2b" id="r_a7a84209b8495d8fd3d2799eb01f1ab2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a84209b8495d8fd3d2799eb01f1ab2b">isTypeLegal</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7a84209b8495d8fd3d2799eb01f1ab2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this type is legal.  <br /></td></tr>
<tr class="separator:a7a84209b8495d8fd3d2799eb01f1ab2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5b47e1f017620a784b726852915d58" id="r_a0d5b47e1f017620a784b726852915d58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d5b47e1f017620a784b726852915d58">shouldBuildLookupTables</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0d5b47e1f017620a784b726852915d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if switches should be turned into lookup tables for the target.  <br /></td></tr>
<tr class="separator:a0d5b47e1f017620a784b726852915d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265e334c170d96e5cbcf8b420db520d4" id="r_a265e334c170d96e5cbcf8b420db520d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a265e334c170d96e5cbcf8b420db520d4">shouldBuildLookupTablesForConstant</a> (<a class="el" href="classllvm_1_1Constant.html">Constant</a> *<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a265e334c170d96e5cbcf8b420db520d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if switches should be turned into lookup tables containing this constant value for the target.  <br /></td></tr>
<tr class="separator:a265e334c170d96e5cbcf8b420db520d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30e432e7796aa46c87440cb54de2243" id="r_ad30e432e7796aa46c87440cb54de2243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad30e432e7796aa46c87440cb54de2243">useColdCCForColdCall</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad30e432e7796aa46c87440cb54de2243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the input function which is cold at all call sites, should use coldcc calling convention.  <br /></td></tr>
<tr class="separator:ad30e432e7796aa46c87440cb54de2243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3460783b1205071ee74d9db510dad0c8" id="r_a3460783b1205071ee74d9db510dad0c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3460783b1205071ee74d9db510dad0c8">getScalarizationOverhead</a> (<a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *Ty, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">DemandedElts</a>, <a class="el" href="classbool.html">bool</a> Insert, <a class="el" href="classbool.html">bool</a> Extract) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a3460783b1205071ee74d9db510dad0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the overhead of scalarizing an instruction.  <br /></td></tr>
<tr class="separator:a3460783b1205071ee74d9db510dad0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9746bddf7711816a2e7853dea177cef1" id="r_a9746bddf7711816a2e7853dea177cef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9746bddf7711816a2e7853dea177cef1">getOperandsScalarizationOverhead</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; Args, <a class="el" href="classunsigned.html">unsigned</a> VF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a9746bddf7711816a2e7853dea177cef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the overhead of scalarizing an instructions unique non-constant operands.  <br /></td></tr>
<tr class="separator:a9746bddf7711816a2e7853dea177cef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af0805a1dd7afabb0aa6cc1832b5011" id="r_a1af0805a1dd7afabb0aa6cc1832b5011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1af0805a1dd7afabb0aa6cc1832b5011">supportsEfficientVectorElementLoadStore</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a1af0805a1dd7afabb0aa6cc1832b5011"><td class="mdescLeft">&#160;</td><td class="mdescRight">If target has efficient vector element load/store instructions, it can return true here so that insertion/extraction costs are not added to the scalarization cost of a load/store.  <br /></td></tr>
<tr class="separator:a1af0805a1dd7afabb0aa6cc1832b5011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f25864d2ad4955cb285d871a36345b" id="r_a12f25864d2ad4955cb285d871a36345b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12f25864d2ad4955cb285d871a36345b">enableAggressiveInterleaving</a> (<a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">LoopHasReductions</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a12f25864d2ad4955cb285d871a36345b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't restrict interleaved unrolling to small loops.  <br /></td></tr>
<tr class="separator:a12f25864d2ad4955cb285d871a36345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24629c2792a37162cf0ef4b1c38ba00c" id="r_a24629c2792a37162cf0ef4b1c38ba00c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1MemCmpExpansionOptions.html">MemCmpExpansionOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24629c2792a37162cf0ef4b1c38ba00c">enableMemCmpExpansion</a> (<a class="el" href="classbool.html">bool</a> OptSize, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsZeroCmp</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a24629c2792a37162cf0ef4b1c38ba00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac501bf52c07df51c9e1242117cfc7b2f" id="r_ac501bf52c07df51c9e1242117cfc7b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac501bf52c07df51c9e1242117cfc7b2f">enableInterleavedAccessVectorization</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac501bf52c07df51c9e1242117cfc7b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable matching of interleaved access groups.  <br /></td></tr>
<tr class="separator:ac501bf52c07df51c9e1242117cfc7b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0734de892207738014317d233c72ad" id="r_a6b0734de892207738014317d233c72ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b0734de892207738014317d233c72ad">enableMaskedInterleavedAccessVectorization</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6b0734de892207738014317d233c72ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable matching of interleaved access groups that contain predicated accesses or gaps and therefore vectorized using masked vector loads/stores.  <br /></td></tr>
<tr class="separator:a6b0734de892207738014317d233c72ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75d51988243f8ea9086b110401f8758" id="r_ab75d51988243f8ea9086b110401f8758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab75d51988243f8ea9086b110401f8758">isFPVectorizationPotentiallyUnsafe</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab75d51988243f8ea9086b110401f8758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that it is potentially unsafe to automatically vectorize floating-point operations because the semantics of vector and scalar floating-point semantics may differ.  <br /></td></tr>
<tr class="separator:ab75d51988243f8ea9086b110401f8758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e46d884e3caf08aea26e0616fafa39" id="r_a31e46d884e3caf08aea26e0616fafa39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31e46d884e3caf08aea26e0616fafa39">allowsMisalignedMemoryAccesses</a> (<a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;<a class="el" href="NVVMIntrRange_8cpp.html#afad351d7bf10ac0446b64e7827634e94">Context</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#abee0df5f7f703bb4462aba260ba0a60f">BitWidth</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>=0, <a class="el" href="classunsigned.html">unsigned</a> Alignment=1, <a class="el" href="classbool.html">bool</a> *Fast=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a31e46d884e3caf08aea26e0616fafa39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the target supports unaligned memory accesses.  <br /></td></tr>
<tr class="separator:a31e46d884e3caf08aea26e0616fafa39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6480799b120b617b9b34f1313afe6661" id="r_a6480799b120b617b9b34f1313afe6661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbe">PopcntSupportKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6480799b120b617b9b34f1313afe6661">getPopcntSupport</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IntTyWidthInBit</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6480799b120b617b9b34f1313afe6661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return hardware support for population count.  <br /></td></tr>
<tr class="separator:a6480799b120b617b9b34f1313afe6661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef998bb15ea045fc769232b62ad0d968" id="r_aef998bb15ea045fc769232b62ad0d968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef998bb15ea045fc769232b62ad0d968">haveFastSqrt</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aef998bb15ea045fc769232b62ad0d968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the hardware has a fast square-root instruction.  <br /></td></tr>
<tr class="separator:aef998bb15ea045fc769232b62ad0d968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199e3382d45514816f88cb65310decb4" id="r_a199e3382d45514816f88cb65310decb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a199e3382d45514816f88cb65310decb4">isFCmpOrdCheaperThanFCmpZero</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a199e3382d45514816f88cb65310decb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is faster to check if a floating-point value is NaN (or not-NaN) versus a comparison against a constant FP zero value.  <br /></td></tr>
<tr class="separator:a199e3382d45514816f88cb65310decb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ac98bceb9d018f191156fc6ed5d921" id="r_ac0ac98bceb9d018f191156fc6ed5d921"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0ac98bceb9d018f191156fc6ed5d921">getFPOpCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac0ac98bceb9d018f191156fc6ed5d921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected cost of supporting the floating point operation of the specified type.  <br /></td></tr>
<tr class="separator:ac0ac98bceb9d018f191156fc6ed5d921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7393c92b10697eeaf3855bf94cd38208" id="r_a7393c92b10697eeaf3855bf94cd38208"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7393c92b10697eeaf3855bf94cd38208">getIntImmCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Imm, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7393c92b10697eeaf3855bf94cd38208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected cost of materializing for the given integer immediate of the specified type.  <br /></td></tr>
<tr class="separator:a7393c92b10697eeaf3855bf94cd38208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad36e85f0146b637ea451a7799a3ad6" id="r_a5ad36e85f0146b637ea451a7799a3ad6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ad36e85f0146b637ea451a7799a3ad6">getIntImmCostInst</a> (<a class="el" href="classunsigned.html">unsigned</a> Opc, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="DeadArgumentElimination_8cpp.html#a39a491a969849f634027f20be70a5c57">Idx</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Imm, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5ad36e85f0146b637ea451a7799a3ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected cost of materialization for the given integer immediate of the specified type for a given instruction.  <br /></td></tr>
<tr class="separator:a5ad36e85f0146b637ea451a7799a3ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb345652eeddb72145390f0cfd08eb39" id="r_acb345652eeddb72145390f0cfd08eb39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb345652eeddb72145390f0cfd08eb39">getIntImmCostIntrin</a> (<a class="el" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a> IID, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="DeadArgumentElimination_8cpp.html#a39a491a969849f634027f20be70a5c57">Idx</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Imm, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:acb345652eeddb72145390f0cfd08eb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6df646941dd85d0ed3e7389212956c4" id="r_ae6df646941dd85d0ed3e7389212956c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6df646941dd85d0ed3e7389212956c4">getIntImmCodeSizeCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opc, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="DeadArgumentElimination_8cpp.html#a39a491a969849f634027f20be70a5c57">Idx</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Imm, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae6df646941dd85d0ed3e7389212956c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected cost for the given integer when optimising for size.  <br /></td></tr>
<tr class="separator:ae6df646941dd85d0ed3e7389212956c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Vector Target Information</h2></td></tr>
<tr class="memitem:af46433d0e36d3f80afc3a8c67b5c53ec" id="r_af46433d0e36d3f80afc3a8c67b5c53ec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ec">ShuffleKind</a> { <br />
&#160;&#160;<a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ecab1ac8982cdb119f39a5fe74610a46796">SK_Broadcast</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ecaea788d98147161f25d5adc3ec6ce7e1f">SK_Reverse</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53eca64d439485545faa793c20de7fbfd274c">SK_Select</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53eca7cc176c1463af0d9820e7981c32db478">SK_Transpose</a>
, <br />
&#160;&#160;<a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53eca466a4d581cf3a553414b9c2e889b944a">SK_InsertSubvector</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ecafd6c03f570400fcb24d861aa21ddffe9">SK_ExtractSubvector</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ecab4616961a3bfdaec42aedc4fc426ccfe">SK_PermuteTwoSrc</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53eca7beec9815d0197f2d31fac9968e9205b">SK_PermuteSingleSrc</a>
<br />
 }</td></tr>
<tr class="memdesc:af46433d0e36d3f80afc3a8c67b5c53ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The various kinds of shuffle patterns for vector queries.  <a href="#af46433d0e36d3f80afc3a8c67b5c53ec">More...</a><br /></td></tr>
<tr class="separator:af46433d0e36d3f80afc3a8c67b5c53ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be22489ac8251d2241bd4ed1633c8a9" id="r_a2be22489ac8251d2241bd4ed1633c8a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2be22489ac8251d2241bd4ed1633c8a9">ReductionKind</a> { <a class="el" href="#a2be22489ac8251d2241bd4ed1633c8a9ace1452d9f3b341add97155f45f7a07ba">RK_None</a>
, <a class="el" href="#a2be22489ac8251d2241bd4ed1633c8a9afceeea598c41d99faa14659eb9c07b34">RK_Arithmetic</a>
, <a class="el" href="#a2be22489ac8251d2241bd4ed1633c8a9a2aa7828048940f8285fe253bd5165572">RK_MinMax</a>
, <a class="el" href="#a2be22489ac8251d2241bd4ed1633c8a9ac511c612bbe9fe2daea4c9e84a0b6c88">RK_UnsignedMinMax</a>
 }</td></tr>
<tr class="memdesc:a2be22489ac8251d2241bd4ed1633c8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kind of the reduction data.  <a href="#a2be22489ac8251d2241bd4ed1633c8a9">More...</a><br /></td></tr>
<tr class="separator:a2be22489ac8251d2241bd4ed1633c8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa38851d75434d1476444ac93f94cb4c" id="r_afa38851d75434d1476444ac93f94cb4c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a> { <a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a>
, <a class="el" href="#afa38851d75434d1476444ac93f94cb4ca7aa61d9e9d33bdf28478754c69c59640">OK_UniformValue</a>
, <a class="el" href="#afa38851d75434d1476444ac93f94cb4ca76d8855d96b8e66b9411ed74737ca8f7">OK_UniformConstantValue</a>
, <a class="el" href="#afa38851d75434d1476444ac93f94cb4cacf63326297610dfbedd0ad408b54e3e4">OK_NonUniformConstantValue</a>
 }</td></tr>
<tr class="memdesc:afa38851d75434d1476444ac93f94cb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional information about an operand's possible values.  <a href="#afa38851d75434d1476444ac93f94cb4c">More...</a><br /></td></tr>
<tr class="separator:afa38851d75434d1476444ac93f94cb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733fb237f3037c95ed59de6055b176c5" id="r_a733fb237f3037c95ed59de6055b176c5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a> { <a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a> = 0
, <a class="el" href="#a733fb237f3037c95ed59de6055b176c5a974f46ced0fd416db695ce5da6059dcc">OP_PowerOf2</a> = 1
 }</td></tr>
<tr class="memdesc:a733fb237f3037c95ed59de6055b176c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional properties of an operand's values.  <a href="#a733fb237f3037c95ed59de6055b176c5">More...</a><br /></td></tr>
<tr class="separator:a733fb237f3037c95ed59de6055b176c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbde4c30736df440ecdeee35a0608f6b" id="r_afbde4c30736df440ecdeee35a0608f6b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">CacheLevel</a> { <a class="el" href="#afbde4c30736df440ecdeee35a0608f6ba4ea39ed13dabbda09e2782f5529eb1ac">L1D</a>
, <a class="el" href="#afbde4c30736df440ecdeee35a0608f6baecc9f58d2b1c17e94659be202c01b55b">L2D</a>
 }</td></tr>
<tr class="memdesc:afbde4c30736df440ecdeee35a0608f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible cache levels.  <a href="#afbde4c30736df440ecdeee35a0608f6b">More...</a><br /></td></tr>
<tr class="separator:afbde4c30736df440ecdeee35a0608f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5cc8324c33cb1f59869456263f9f4b" id="r_acf5cc8324c33cb1f59869456263f9f4b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">MemIndexedMode</a> { <br />
&#160;&#160;<a class="el" href="#acf5cc8324c33cb1f59869456263f9f4ba24234938a33e357e0c86f1d71295a2f6">MIM_Unindexed</a>
, <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4baf049517e9a49117b5225ee67455f5dea">MIM_PreInc</a>
, <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4ba7367f3267f2bfe1a200655097784f4a1">MIM_PreDec</a>
, <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4ba3a471f30b7a193785b57c081776ad3cb">MIM_PostInc</a>
, <br />
&#160;&#160;<a class="el" href="#acf5cc8324c33cb1f59869456263f9f4ba57dbcb88640a74d04f7e0ddeefa76d1b">MIM_PostDec</a>
<br />
 }</td></tr>
<tr class="memdesc:acf5cc8324c33cb1f59869456263f9f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of load/store indexing.  <a href="#acf5cc8324c33cb1f59869456263f9f4b">More...</a><br /></td></tr>
<tr class="separator:acf5cc8324c33cb1f59869456263f9f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e8ca52658f54e5cc6214eb1a291ef" id="r_aae0e8ca52658f54e5cc6214eb1a291ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae0e8ca52658f54e5cc6214eb1a291ef">getNumberOfRegisters</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ClassID</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aae0e8ca52658f54e5cc6214eb1a291ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623cced59353f83cc5eaba4068c57694" id="r_a623cced59353f83cc5eaba4068c57694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a623cced59353f83cc5eaba4068c57694">getRegisterClassForType</a> (<a class="el" href="classbool.html">bool</a> <a class="el" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39a57dea6f5039281b7fee517fc43bf3110">Vector</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a623cced59353f83cc5eaba4068c57694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97503ae3ef00c5f1eaffa5bbeb0a4357" id="r_a97503ae3ef00c5f1eaffa5bbeb0a4357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97503ae3ef00c5f1eaffa5bbeb0a4357">getRegisterClassName</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ClassID</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a97503ae3ef00c5f1eaffa5bbeb0a4357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993b6b21885bc9a48c53230a3d8b3072" id="r_a993b6b21885bc9a48c53230a3d8b3072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a993b6b21885bc9a48c53230a3d8b3072">getRegisterBitWidth</a> (<a class="el" href="classbool.html">bool</a> <a class="el" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39a57dea6f5039281b7fee517fc43bf3110">Vector</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a993b6b21885bc9a48c53230a3d8b3072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa8b3631e74e836453f972aac6b4b65" id="r_a8fa8b3631e74e836453f972aac6b4b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fa8b3631e74e836453f972aac6b4b65">getMinVectorRegisterBitWidth</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a8fa8b3631e74e836453f972aac6b4b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6631468caf2fe616dcd85f80f5a51801" id="r_a6631468caf2fe616dcd85f80f5a51801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6631468caf2fe616dcd85f80f5a51801">shouldMaximizeVectorBandwidth</a> (<a class="el" href="classbool.html">bool</a> OptSize) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a6631468caf2fe616dcd85f80f5a51801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab346e9f55e10dbcffdd133e9651b9405" id="r_ab346e9f55e10dbcffdd133e9651b9405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab346e9f55e10dbcffdd133e9651b9405">getMinimumVF</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ElemWidth</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ab346e9f55e10dbcffdd133e9651b9405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9880b7512930d879440db073b536d362" id="r_a9880b7512930d879440db073b536d362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9880b7512930d879440db073b536d362">shouldConsiderAddressTypePromotion</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classbool.html">bool</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">AllowPromotionWithoutCommonHeader</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a9880b7512930d879440db073b536d362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d04cbecfee76b1c4a5ea83aa6bb113c" id="r_a9d04cbecfee76b1c4a5ea83aa6bb113c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d04cbecfee76b1c4a5ea83aa6bb113c">getCacheLineSize</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a9d04cbecfee76b1c4a5ea83aa6bb113c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e8f29aef00ec6b5ffe4bfcc9e965f4" id="r_a11e8f29aef00ec6b5ffe4bfcc9e965f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11e8f29aef00ec6b5ffe4bfcc9e965f4">getCacheSize</a> (<a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">CacheLevel</a> Level) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a11e8f29aef00ec6b5ffe4bfcc9e965f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6945585b0648776b5b7893d1c13cce56" id="r_a6945585b0648776b5b7893d1c13cce56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6945585b0648776b5b7893d1c13cce56">getCacheAssociativity</a> (<a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">CacheLevel</a> Level) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a6945585b0648776b5b7893d1c13cce56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3f3a3d549cf057479e744e7ecfd7e1" id="r_a1e3f3a3d549cf057479e744e7ecfd7e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e3f3a3d549cf057479e744e7ecfd7e1">getPrefetchDistance</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a1e3f3a3d549cf057479e744e7ecfd7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcadecc95e9e49f77a70ab8b99a8c35" id="r_a8dcadecc95e9e49f77a70ab8b99a8c35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dcadecc95e9e49f77a70ab8b99a8c35">getMinPrefetchStride</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">NumMemAccesses</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">NumStridedMemAccesses</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">NumPrefetches</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">HasCall</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a8dcadecc95e9e49f77a70ab8b99a8c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some HW prefetchers can handle accesses up to a certain constant stride.  <br /></td></tr>
<tr class="separator:a8dcadecc95e9e49f77a70ab8b99a8c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cb8d0f215f1b7b66e4a7d6581b3a16" id="r_a66cb8d0f215f1b7b66e4a7d6581b3a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66cb8d0f215f1b7b66e4a7d6581b3a16">getMaxPrefetchIterationsAhead</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a66cb8d0f215f1b7b66e4a7d6581b3a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec5838370bf4a0d0af43e443ee99325" id="r_a4ec5838370bf4a0d0af43e443ee99325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ec5838370bf4a0d0af43e443ee99325">enableWritePrefetching</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a4ec5838370bf4a0d0af43e443ee99325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed57eef29fa5e077bd059050c293723" id="r_a4ed57eef29fa5e077bd059050c293723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ed57eef29fa5e077bd059050c293723">getMaxInterleaveFactor</a> (<a class="el" href="classunsigned.html">unsigned</a> VF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a4ed57eef29fa5e077bd059050c293723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4ccf555d90ee23430099f1305b5559" id="r_a5c4ccf555d90ee23430099f1305b5559"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c4ccf555d90ee23430099f1305b5559">getArithmeticInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, <a class="el" href="#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">Opd1Info</a>=<a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a>, <a class="el" href="#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">Opd2Info</a>=<a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a>, <a class="el" href="#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">Opd1PropInfo</a>=<a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a>, <a class="el" href="#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">Opd2PropInfo</a>=<a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; Args=<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;(), <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5c4ccf555d90ee23430099f1305b5559"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an approximation of reciprocal throughput of a math/logic op.  <br /></td></tr>
<tr class="separator:a5c4ccf555d90ee23430099f1305b5559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917e3117709a8e81dee75edb5e7d3459" id="r_a917e3117709a8e81dee75edb5e7d3459"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a917e3117709a8e81dee75edb5e7d3459">getShuffleCost</a> (<a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ec">ShuffleKind</a> Kind, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Tp</a>, int Index=0, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">SubTp</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a917e3117709a8e81dee75edb5e7d3459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe563f493649264d6eca3f8d35cf64b2" id="r_afe563f493649264d6eca3f8d35cf64b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe563f493649264d6eca3f8d35cf64b2">getCastInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Dst, <a class="el" href="classllvm_1_1Type.html">Type</a> *Src, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:afe563f493649264d6eca3f8d35cf64b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87247352d5aa1adf0dc5ff4d95bc29cf" id="r_a87247352d5aa1adf0dc5ff4d95bc29cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87247352d5aa1adf0dc5ff4d95bc29cf">getExtractWithExtendCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Dst, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy, <a class="el" href="classunsigned.html">unsigned</a> Index=-1) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a87247352d5aa1adf0dc5ff4d95bc29cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecc78f5988700032cf36c4d14312cd5" id="r_a0ecc78f5988700032cf36c4d14312cd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ecc78f5988700032cf36c4d14312cd5">getCFInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a0ecc78f5988700032cf36c4d14312cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3ca06a81b22e94903157e652cb227c" id="r_aca3ca06a81b22e94903157e652cb227c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca3ca06a81b22e94903157e652cb227c">getCmpSelInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *ValTy, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">CondTy</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aca3ca06a81b22e94903157e652cb227c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe5a68d990207678993ce77ffb6da78" id="r_a4fe5a68d990207678993ce77ffb6da78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fe5a68d990207678993ce77ffb6da78">getVectorInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Val, <a class="el" href="classunsigned.html">unsigned</a> Index=-1) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a4fe5a68d990207678993ce77ffb6da78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae942e05b7d4e3620c953d6cef1455ea" id="r_aae942e05b7d4e3620c953d6cef1455ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae942e05b7d4e3620c953d6cef1455ea">getMemoryOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Src, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aae942e05b7d4e3620c953d6cef1455ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9593fa2b845a20c0fc8211b745a2c39" id="r_ae9593fa2b845a20c0fc8211b745a2c39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9593fa2b845a20c0fc8211b745a2c39">getMaskedMemoryOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Src, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ae9593fa2b845a20c0fc8211b745a2c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46829cb9cfbba1d9f4f82487dd85c010" id="r_a46829cb9cfbba1d9f4f82487dd85c010"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46829cb9cfbba1d9f4f82487dd85c010">getGatherScatterOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *DataTy, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">VariableMask</a>, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a46829cb9cfbba1d9f4f82487dd85c010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba3bfea3d59d0bd4f6d949da9b465de" id="r_afba3bfea3d59d0bd4f6d949da9b465de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afba3bfea3d59d0bd4f6d949da9b465de">getInterleavedMemoryOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *VecTy, <a class="el" href="classunsigned.html">unsigned</a> Factor, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; Indices, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">UseMaskForCond</a>=false, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">UseMaskForGaps</a>=false) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:afba3bfea3d59d0bd4f6d949da9b465de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4e07c2d1c76ec690c39e46a5028cc8" id="r_a2b4e07c2d1c76ec690c39e46a5028cc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b4e07c2d1c76ec690c39e46a5028cc8">getArithmeticReductionCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *Ty, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsPairwiseForm</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a2b4e07c2d1c76ec690c39e46a5028cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cost of performing a vector reduction.  <br /></td></tr>
<tr class="separator:a2b4e07c2d1c76ec690c39e46a5028cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c3f091dcb70a1f299fe00947684554" id="r_a81c3f091dcb70a1f299fe00947684554"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81c3f091dcb70a1f299fe00947684554">getMinMaxReductionCost</a> (<a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *Ty, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">CondTy</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsPairwiseForm</a>, <a class="el" href="classbool.html">bool</a> IsUnsigned, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a81c3f091dcb70a1f299fe00947684554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c041300ad39485270ae0cae5e04ca3" id="r_a46c041300ad39485270ae0cae5e04ca3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46c041300ad39485270ae0cae5e04ca3">getIntrinsicInstrCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1IntrinsicCostAttributes.html">IntrinsicCostAttributes</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">ICA</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a46c041300ad39485270ae0cae5e04ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96af894d6656d485edb262dda5358605" id="r_a96af894d6656d485edb262dda5358605"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96af894d6656d485edb262dda5358605">getCallInstrCost</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="DeadArgumentElimination_8cpp.html#ae9e8b37f293199ceac2a52f811e26a3e">RetTy</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; <a class="el" href="classllvm_1_1ilist__node__impl.html">Tys</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a96af894d6656d485edb262dda5358605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67b7e389a52ada1d5264e23d09f4cbe" id="r_ad67b7e389a52ada1d5264e23d09f4cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad67b7e389a52ada1d5264e23d09f4cbe">getNumberOfParts</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Tp</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ad67b7e389a52ada1d5264e23d09f4cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffff43e8df36ddc2e166c6eac605b2b" id="r_aeffff43e8df36ddc2e166c6eac605b2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeffff43e8df36ddc2e166c6eac605b2b">getAddressComputationCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *Ptr=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aeffff43e8df36ddc2e166c6eac605b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af170c52c54210c4f104f74279c2b6c9b" id="r_af170c52c54210c4f104f74279c2b6c9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af170c52c54210c4f104f74279c2b6c9b">getCostOfKeepingLiveOverCall</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; <a class="el" href="classllvm_1_1ilist__node__impl.html">Tys</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:af170c52c54210c4f104f74279c2b6c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e4dcfc435f179592619b03330f643b" id="r_a02e4dcfc435f179592619b03330f643b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02e4dcfc435f179592619b03330f643b">getTgtMemIntrinsic</a> (<a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *Inst, <a class="el" href="structllvm_1_1MemIntrinsicInfo.html">MemIntrinsicInfo</a> &amp;<a class="el" href="CSEInfo_8cpp.html#a75f8a8519c2c9b30e7c06dc5e256fffa">Info</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a02e4dcfc435f179592619b03330f643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422b020a05731c432411d574a7728af5" id="r_a422b020a05731c432411d574a7728af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a422b020a05731c432411d574a7728af5">getAtomicMemIntrinsicMaxElementSize</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a422b020a05731c432411d574a7728af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e18a8730e428b4967b375d57c2e401" id="r_ad5e18a8730e428b4967b375d57c2e401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5e18a8730e428b4967b375d57c2e401">getOrCreateResultFromMemIntrinsic</a> (<a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *Inst, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">ExpectedType</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ad5e18a8730e428b4967b375d57c2e401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3897d734249f9b6418e23af2ac90f519" id="r_a3897d734249f9b6418e23af2ac90f519"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3897d734249f9b6418e23af2ac90f519">getMemcpyLoopLoweringType</a> (<a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;<a class="el" href="NVVMIntrRange_8cpp.html#afad351d7bf10ac0446b64e7827634e94">Context</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *Length, <a class="el" href="classunsigned.html">unsigned</a> SrcAddrSpace, <a class="el" href="classunsigned.html">unsigned</a> DestAddrSpace, <a class="el" href="classunsigned.html">unsigned</a> SrcAlign, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">DestAlign</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a3897d734249f9b6418e23af2ac90f519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a7d1c2f35967ddf0c71595681c28b1" id="r_a48a7d1c2f35967ddf0c71595681c28b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48a7d1c2f35967ddf0c71595681c28b1">getMemcpyLoopResidualLoweringType</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">OpsOut</a>, <a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;<a class="el" href="NVVMIntrRange_8cpp.html#afad351d7bf10ac0446b64e7827634e94">Context</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">RemainingBytes</a>, <a class="el" href="classunsigned.html">unsigned</a> SrcAddrSpace, <a class="el" href="classunsigned.html">unsigned</a> DestAddrSpace, <a class="el" href="classunsigned.html">unsigned</a> SrcAlign, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">DestAlign</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a48a7d1c2f35967ddf0c71595681c28b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e1f19379514bb06cdcedb2bae8748d" id="r_ad2e1f19379514bb06cdcedb2bae8748d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2e1f19379514bb06cdcedb2bae8748d">areInlineCompatible</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *Caller, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="AMDGPULibCalls_8cpp.html#a537c835c34f0b44b6ad2696643754390">Callee</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ad2e1f19379514bb06cdcedb2bae8748d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6d8c70a0c8814bedea753b3e39586b" id="r_a8b6d8c70a0c8814bedea753b3e39586b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b6d8c70a0c8814bedea753b3e39586b">areFunctionArgsABICompatible</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *Caller, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="AMDGPULibCalls_8cpp.html#a537c835c34f0b44b6ad2696643754390">Callee</a>, <a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classllvm_1_1Argument.html">Argument</a> * &gt; &amp;Args) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a8b6d8c70a0c8814bedea753b3e39586b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7716bda26c61738e624214efa149e83e" id="r_a7716bda26c61738e624214efa149e83e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7716bda26c61738e624214efa149e83e">isIndexedLoadLegal</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">MemIndexedMode</a> <a class="el" href="SIWholeQuadMode_8cpp.html#a0c198437833c48138f49e3589bd08773">Mode</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a7716bda26c61738e624214efa149e83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a768ef7bcf1b5059f409327c1f83591" id="r_a5a768ef7bcf1b5059f409327c1f83591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a768ef7bcf1b5059f409327c1f83591">isIndexedStoreLegal</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">MemIndexedMode</a> <a class="el" href="SIWholeQuadMode_8cpp.html#a0c198437833c48138f49e3589bd08773">Mode</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a5a768ef7bcf1b5059f409327c1f83591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9d2da3e41e4cc90c7a552258166277" id="r_a5c9d2da3e41e4cc90c7a552258166277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c9d2da3e41e4cc90c7a552258166277">getLoadStoreVecRegBitWidth</a> (<a class="el" href="classunsigned.html">unsigned</a> AddrSpace) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a5c9d2da3e41e4cc90c7a552258166277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aaf2f1c4d2a4bb801bc9aeea94de3c" id="r_a03aaf2f1c4d2a4bb801bc9aeea94de3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03aaf2f1c4d2a4bb801bc9aeea94de3c">isLegalToVectorizeLoad</a> (<a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a03aaf2f1c4d2a4bb801bc9aeea94de3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de4290b00b162ec20705cad42047b64" id="r_a0de4290b00b162ec20705cad42047b64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0de4290b00b162ec20705cad42047b64">isLegalToVectorizeStore</a> (<a class="el" href="classllvm_1_1StoreInst.html">StoreInst</a> *SI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a0de4290b00b162ec20705cad42047b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa75efd79296070e4c5f24fa3ea6f01" id="r_aaaa75efd79296070e4c5f24fa3ea6f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaa75efd79296070e4c5f24fa3ea6f01">isLegalToVectorizeLoadChain</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ChainSizeInBytes</a>, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aaaa75efd79296070e4c5f24fa3ea6f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b0dcd9d3ef39aa308b7d7371e5da88" id="r_a58b0dcd9d3ef39aa308b7d7371e5da88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58b0dcd9d3ef39aa308b7d7371e5da88">isLegalToVectorizeStoreChain</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ChainSizeInBytes</a>, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a58b0dcd9d3ef39aa308b7d7371e5da88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e51850e7e39c4bd2424ad98c12e700" id="r_a84e51850e7e39c4bd2424ad98c12e700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84e51850e7e39c4bd2424ad98c12e700">getLoadVectorFactor</a> (<a class="el" href="classunsigned.html">unsigned</a> VF, <a class="el" href="classunsigned.html">unsigned</a> LoadSize, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ChainSizeInBytes</a>, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a84e51850e7e39c4bd2424ad98c12e700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47da5df7f765cada1df9036a3433e1a4" id="r_a47da5df7f765cada1df9036a3433e1a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47da5df7f765cada1df9036a3433e1a4">getStoreVectorFactor</a> (<a class="el" href="classunsigned.html">unsigned</a> VF, <a class="el" href="classunsigned.html">unsigned</a> StoreSize, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ChainSizeInBytes</a>, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a47da5df7f765cada1df9036a3433e1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196b604c795c4a56383c68a9e343cc3f" id="r_a196b604c795c4a56383c68a9e343cc3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a196b604c795c4a56383c68a9e343cc3f">useReductionIntrinsic</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1ReductionFlags.html">ReductionFlags</a> Flags) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a196b604c795c4a56383c68a9e343cc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeefc63fa057f5050b78547c6cdf0e1" id="r_aefeefc63fa057f5050b78547c6cdf0e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefeefc63fa057f5050b78547c6cdf0e1">shouldExpandReduction</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *II) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aefeefc63fa057f5050b78547c6cdf0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2f1ef61f1c352da3b8121d4ea2c585" id="r_acd2f1ef61f1c352da3b8121d4ea2c585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd2f1ef61f1c352da3b8121d4ea2c585">getGISelRematGlobalCost</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:acd2f1ef61f1c352da3b8121d4ea2c585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7b3a4d1ce161b7ec5d97ac690cd5b7" id="r_a9d7b3a4d1ce161b7ec5d97ac690cd5b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="#a2be22489ac8251d2241bd4ed1633c8a9">ReductionKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d7b3a4d1ce161b7ec5d97ac690cd5b7">matchPairwiseReduction</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ExtractElementInst.html">ExtractElementInst</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">ReduxRoot</a>, <a class="el" href="classunsigned.html">unsigned</a> &amp;Opcode, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *&amp;Ty)</td></tr>
<tr class="separator:a9d7b3a4d1ce161b7ec5d97ac690cd5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf9887087e88a3b6af81593e2630550" id="r_a0cf9887087e88a3b6af81593e2630550"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="#a2be22489ac8251d2241bd4ed1633c8a9">ReductionKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cf9887087e88a3b6af81593e2630550">matchVectorSplittingReduction</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ExtractElementInst.html">ExtractElementInst</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">ReduxRoot</a>, <a class="el" href="classunsigned.html">unsigned</a> &amp;Opcode, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *&amp;Ty)</td></tr>
<tr class="separator:a0cf9887087e88a3b6af81593e2630550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a884ac711aafcdbc1715b68975cd7ec" id="r_a0a884ac711aafcdbc1715b68975cd7ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a884ac711aafcdbc1715b68975cd7ec">getOperandInfo</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">OpProps</a>)</td></tr>
<tr class="memdesc:a0a884ac711aafcdbc1715b68975cd7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect properties of V used in cost analysis, e.g. OP_PowerOf2.  <br /></td></tr>
<tr class="separator:a0a884ac711aafcdbc1715b68975cd7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This pass provides access to the codegen interfaces that are needed for IR-level transformations. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00174">174</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afbde4c30736df440ecdeee35a0608f6b" name="afbde4c30736df440ecdeee35a0608f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbde4c30736df440ecdeee35a0608f6b">&#9670;&#160;</a></span>CacheLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> <a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">llvm::TargetTransformInfo::CacheLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The possible cache levels. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afbde4c30736df440ecdeee35a0608f6ba4ea39ed13dabbda09e2782f5529eb1ac" name="afbde4c30736df440ecdeee35a0608f6ba4ea39ed13dabbda09e2782f5529eb1ac"></a>L1D&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afbde4c30736df440ecdeee35a0608f6baecc9f58d2b1c17e94659be202c01b55b" name="afbde4c30736df440ecdeee35a0608f6baecc9f58d2b1c17e94659be202c01b55b"></a>L2D&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00907">907</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="acf5cc8324c33cb1f59869456263f9f4b" name="acf5cc8324c33cb1f59869456263f9f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5cc8324c33cb1f59869456263f9f4b">&#9670;&#160;</a></span>MemIndexedMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">llvm::TargetTransformInfo::MemIndexedMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of load/store indexing. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acf5cc8324c33cb1f59869456263f9f4ba24234938a33e357e0c86f1d71295a2f6" name="acf5cc8324c33cb1f59869456263f9f4ba24234938a33e357e0c86f1d71295a2f6"></a>MIM_Unindexed&#160;</td><td class="fielddoc"><p>No indexing. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf5cc8324c33cb1f59869456263f9f4baf049517e9a49117b5225ee67455f5dea" name="acf5cc8324c33cb1f59869456263f9f4baf049517e9a49117b5225ee67455f5dea"></a>MIM_PreInc&#160;</td><td class="fielddoc"><p>Pre-incrementing. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf5cc8324c33cb1f59869456263f9f4ba7367f3267f2bfe1a200655097784f4a1" name="acf5cc8324c33cb1f59869456263f9f4ba7367f3267f2bfe1a200655097784f4a1"></a>MIM_PreDec&#160;</td><td class="fielddoc"><p>Pre-decrementing. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf5cc8324c33cb1f59869456263f9f4ba3a471f30b7a193785b57c081776ad3cb" name="acf5cc8324c33cb1f59869456263f9f4ba3a471f30b7a193785b57c081776ad3cb"></a>MIM_PostInc&#160;</td><td class="fielddoc"><p>Post-incrementing. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf5cc8324c33cb1f59869456263f9f4ba57dbcb88640a74d04f7e0ddeefa76d1b" name="acf5cc8324c33cb1f59869456263f9f4ba57dbcb88640a74d04f7e0ddeefa76d1b"></a>MIM_PostDec&#160;</td><td class="fielddoc"><p>Post-decrementing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l01167">1167</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="afa38851d75434d1476444ac93f94cb4c" name="afa38851d75434d1476444ac93f94cb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa38851d75434d1476444ac93f94cb4c">&#9670;&#160;</a></span>OperandValueKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#afa38851d75434d1476444ac93f94cb4c">llvm::TargetTransformInfo::OperandValueKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Additional information about an operand's possible values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac" name="afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac"></a>OK_AnyValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afa38851d75434d1476444ac93f94cb4ca7aa61d9e9d33bdf28478754c69c59640" name="afa38851d75434d1476444ac93f94cb4ca7aa61d9e9d33bdf28478754c69c59640"></a>OK_UniformValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afa38851d75434d1476444ac93f94cb4ca76d8855d96b8e66b9411ed74737ca8f7" name="afa38851d75434d1476444ac93f94cb4ca76d8855d96b8e66b9411ed74737ca8f7"></a>OK_UniformConstantValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afa38851d75434d1476444ac93f94cb4cacf63326297610dfbedd0ad408b54e3e4" name="afa38851d75434d1476444ac93f94cb4cacf63326297610dfbedd0ad408b54e3e4"></a>OK_NonUniformConstantValue&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00849">849</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="a733fb237f3037c95ed59de6055b176c5" name="a733fb237f3037c95ed59de6055b176c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733fb237f3037c95ed59de6055b176c5">&#9670;&#160;</a></span>OperandValueProperties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#a733fb237f3037c95ed59de6055b176c5">llvm::TargetTransformInfo::OperandValueProperties</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Additional properties of an operand's values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072" name="a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072"></a>OP_None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a733fb237f3037c95ed59de6055b176c5a974f46ced0fd416db695ce5da6059dcc" name="a733fb237f3037c95ed59de6055b176c5a974f46ced0fd416db695ce5da6059dcc"></a>OP_PowerOf2&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00857">857</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="aa4c17e89b1ef061ed69f42b7cee93dbe" name="aa4c17e89b1ef061ed69f42b7cee93dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c17e89b1ef061ed69f42b7cee93dbe">&#9670;&#160;</a></span>PopcntSupportKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbe">llvm::TargetTransformInfo::PopcntSupportKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags indicating the kind of support for population count. </p>
<p>Compared to the SW implementation, HW support is supposed to significantly boost the performance when the population is dense, and it may or may not degrade performance if the population is sparse. A HW support is considered as "Fast" if it can outperform, or is on a par with, SW implementation when the population is sparse; otherwise, it is considered as "Slow". </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa4c17e89b1ef061ed69f42b7cee93dbea0ce99a3a4fe2b7f2771a7b288a99ed2c" name="aa4c17e89b1ef061ed69f42b7cee93dbea0ce99a3a4fe2b7f2771a7b288a99ed2c"></a>PSK_Software&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa4c17e89b1ef061ed69f42b7cee93dbea01deb9d0bc6399399b0d8377bd09201d" name="aa4c17e89b1ef061ed69f42b7cee93dbea01deb9d0bc6399399b0d8377bd09201d"></a>PSK_SlowHardware&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa4c17e89b1ef061ed69f42b7cee93dbeac71465fd61f1ba8aa2c7c397722b5e05" name="aa4c17e89b1ef061ed69f42b7cee93dbeac71465fd61f1ba8aa2c7c397722b5e05"></a>PSK_FastHardware&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00558">558</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="a2be22489ac8251d2241bd4ed1633c8a9" name="a2be22489ac8251d2241bd4ed1633c8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be22489ac8251d2241bd4ed1633c8a9">&#9670;&#160;</a></span>ReductionKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#a2be22489ac8251d2241bd4ed1633c8a9">llvm::TargetTransformInfo::ReductionKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kind of the reduction data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2be22489ac8251d2241bd4ed1633c8a9ace1452d9f3b341add97155f45f7a07ba" name="a2be22489ac8251d2241bd4ed1633c8a9ace1452d9f3b341add97155f45f7a07ba"></a>RK_None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2be22489ac8251d2241bd4ed1633c8a9afceeea598c41d99faa14659eb9c07b34" name="a2be22489ac8251d2241bd4ed1633c8a9afceeea598c41d99faa14659eb9c07b34"></a>RK_Arithmetic&#160;</td><td class="fielddoc"><p>Not a reduction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2be22489ac8251d2241bd4ed1633c8a9a2aa7828048940f8285fe253bd5165572" name="a2be22489ac8251d2241bd4ed1633c8a9a2aa7828048940f8285fe253bd5165572"></a>RK_MinMax&#160;</td><td class="fielddoc"><p>Binary reduction data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2be22489ac8251d2241bd4ed1633c8a9ac511c612bbe9fe2daea4c9e84a0b6c88" name="a2be22489ac8251d2241bd4ed1633c8a9ac511c612bbe9fe2daea4c9e84a0b6c88"></a>RK_UnsignedMinMax&#160;</td><td class="fielddoc"><p>Min/max reduction data. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00819">819</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="af46433d0e36d3f80afc3a8c67b5c53ec" name="af46433d0e36d3f80afc3a8c67b5c53ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46433d0e36d3f80afc3a8c67b5c53ec">&#9670;&#160;</a></span>ShuffleKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ec">llvm::TargetTransformInfo::ShuffleKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The various kinds of shuffle patterns for vector queries. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53ecab1ac8982cdb119f39a5fe74610a46796" name="af46433d0e36d3f80afc3a8c67b5c53ecab1ac8982cdb119f39a5fe74610a46796"></a>SK_Broadcast&#160;</td><td class="fielddoc"><p>Broadcast element 0 to all other elements. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53ecaea788d98147161f25d5adc3ec6ce7e1f" name="af46433d0e36d3f80afc3a8c67b5c53ecaea788d98147161f25d5adc3ec6ce7e1f"></a>SK_Reverse&#160;</td><td class="fielddoc"><p>Reverse the order of the vector. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53eca64d439485545faa793c20de7fbfd274c" name="af46433d0e36d3f80afc3a8c67b5c53eca64d439485545faa793c20de7fbfd274c"></a>SK_Select&#160;</td><td class="fielddoc"><p>Selects elements from the corresponding lane of either source operand. </p>
<p>This is equivalent to a vector select with a constant condition operand. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53eca7cc176c1463af0d9820e7981c32db478" name="af46433d0e36d3f80afc3a8c67b5c53eca7cc176c1463af0d9820e7981c32db478"></a>SK_Transpose&#160;</td><td class="fielddoc"><p>Transpose two vectors. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53eca466a4d581cf3a553414b9c2e889b944a" name="af46433d0e36d3f80afc3a8c67b5c53eca466a4d581cf3a553414b9c2e889b944a"></a>SK_InsertSubvector&#160;</td><td class="fielddoc"><p>InsertSubvector. Index indicates start offset. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53ecafd6c03f570400fcb24d861aa21ddffe9" name="af46433d0e36d3f80afc3a8c67b5c53ecafd6c03f570400fcb24d861aa21ddffe9"></a>SK_ExtractSubvector&#160;</td><td class="fielddoc"><p>ExtractSubvector Index indicates start offset. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53ecab4616961a3bfdaec42aedc4fc426ccfe" name="af46433d0e36d3f80afc3a8c67b5c53ecab4616961a3bfdaec42aedc4fc426ccfe"></a>SK_PermuteTwoSrc&#160;</td><td class="fielddoc"><p>Merge elements from two source vectors into one with any shuffle mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53eca7beec9815d0197f2d31fac9968e9205b" name="af46433d0e36d3f80afc3a8c67b5c53eca7beec9815d0197f2d31fac9968e9205b"></a>SK_PermuteSingleSrc&#160;</td><td class="fielddoc"><p>Shuffle elements of single source vector with any shuffle mask. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00803">803</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="ac44f6b9fdbb5f9cc199f8329cb0b272c" name="ac44f6b9fdbb5f9cc199f8329cb0b272c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44f6b9fdbb5f9cc199f8329cb0b272c">&#9670;&#160;</a></span>TargetCostConstants</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#ac44f6b9fdbb5f9cc199f8329cb0b272c">llvm::TargetTransformInfo::TargetCostConstants</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Underlying constants for 'cost' values in this interface. </p>
<p>Many APIs in this interface return a cost. This enum defines the fundamental values that should be used to interpret (and produce) those costs. The costs are returned as an int rather than a member of this enumeration because it is expected that the cost of one IR instruction may have a multiplicative factor to it or otherwise won't fit directly into the enum. Moreover, it is common to sum or average costs which works better as simple integral values. Thus this enum only provides constants. Also note that the returned costs are signed integers to make it natural to add, subtract, and test with zero (a common boundary condition). It is not expected that 2^32 is a realistic cost to be modeling at any point.</p>
<p>Note that these costs should usually reflect the intersection of code-size cost and execution cost. A free instruction is typically one that folds into another instruction. For example, reg-to-reg moves can often be skipped by renaming the registers in the CPU, but they still are encoded and thus wouldn't be considered 'free' here. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac44f6b9fdbb5f9cc199f8329cb0b272ca89f768b1267e3083b4eb05b4ab77e717" name="ac44f6b9fdbb5f9cc199f8329cb0b272ca89f768b1267e3083b4eb05b4ab77e717"></a>TCC_Free&#160;</td><td class="fielddoc"><p><a class="el" href="classllvm_1_1Expected.html" title="Tagged union holding either a T or a Error.">Expected</a> to fold away in lowering. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac44f6b9fdbb5f9cc199f8329cb0b272cae46c9eecc49bd2dc253c607e78a0fb86" name="ac44f6b9fdbb5f9cc199f8329cb0b272cae46c9eecc49bd2dc253c607e78a0fb86"></a>TCC_Basic&#160;</td><td class="fielddoc"><p>The cost of a typical 'add' instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac44f6b9fdbb5f9cc199f8329cb0b272ca022565d444ccf496c0414bccefbcd9c8" name="ac44f6b9fdbb5f9cc199f8329cb0b272ca022565d444ccf496c0414bccefbcd9c8"></a>TCC_Expensive&#160;</td><td class="fielddoc"><p>The cost of a 'div' instruction on x86. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00264">264</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="a706f223f760b55668fbae74202b816bb" name="a706f223f760b55668fbae74202b816bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706f223f760b55668fbae74202b816bb">&#9670;&#160;</a></span>TargetCostKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#a706f223f760b55668fbae74202b816bb">llvm::TargetTransformInfo::TargetCostKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The kind of cost model. </p>
<p>There are several different cost models that can be customized by the target. The normalization of each cost model may be target specific. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b" name="a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b"></a>TCK_RecipThroughput&#160;</td><td class="fielddoc"><p>Reciprocal throughput. </p>
</td></tr>
<tr><td class="fieldname"><a id="a706f223f760b55668fbae74202b816bba81b2c6f1f1e13e4a575e6d1c8b29b6e1" name="a706f223f760b55668fbae74202b816bba81b2c6f1f1e13e4a575e6d1c8b29b6e1"></a>TCK_Latency&#160;</td><td class="fielddoc"><p>The latency of instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a706f223f760b55668fbae74202b816bba737cfc93e5a2ff961677d57186167e7c" name="a706f223f760b55668fbae74202b816bba737cfc93e5a2ff961677d57186167e7c"></a>TCK_CodeSize&#160;</td><td class="fielddoc"><p><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> code size. </p>
</td></tr>
<tr><td class="fieldname"><a id="a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8" name="a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8"></a>TCK_SizeAndLatency&#160;</td><td class="fielddoc"><p>The weighted sum of size and latency. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00217">217</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af1bf12b2f33b7e30f8f361a1e7642079" name="af1bf12b2f33b7e30f8f361a1e7642079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bf12b2f33b7e30f8f361a1e7642079">&#9670;&#160;</a></span>TargetTransformInfo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">llvm::TargetTransformInfo::TargetTransformInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classT.html">T</a></td>          <td class="paramname"><span class="paramname"><em>Impl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a TTI object using a type implementing the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below. </p>
<p>This is used by targets to construct a TTI wrapping their target-specific implementation that encodes appropriate costs for their target. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l02000">2000</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="ac7b62dddca1c89d43af02d0e2ab06030" name="ac7b62dddca1c89d43af02d0e2ab06030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b62dddca1c89d43af02d0e2ab06030">&#9670;&#160;</a></span>TargetTransformInfo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TargetTransformInfo::TargetTransformInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DL</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a baseline TTI object using a minimal implementation of the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below. </p>
<p>The TTI implementation will reflect the information in the <a class="el" href="classllvm_1_1DataLayout.html" title="A parsed version of the target data layout string in and methods for querying it.">DataLayout</a> provided if non-null. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00227">227</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ab158463a734f57c86e685364527ebaa4" name="ab158463a734f57c86e685364527ebaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab158463a734f57c86e685364527ebaa4">&#9670;&#160;</a></span>TargetTransformInfo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TargetTransformInfo::TargetTransformInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00232">232</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="af9e9d106cef4491370c43c4f136fc050" name="af9e9d106cef4491370c43c4f136fc050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e9d106cef4491370c43c4f136fc050">&#9670;&#160;</a></span>~TargetTransformInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TargetTransformInfo::~TargetTransformInfo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00230">230</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a31e46d884e3caf08aea26e0616fafa39" name="a31e46d884e3caf08aea26e0616fafa39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e46d884e3caf08aea26e0616fafa39">&#9670;&#160;</a></span>allowsMisalignedMemoryAccesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::allowsMisalignedMemoryAccesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>BitWidth</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddressSpace</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>Fast</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the target supports unaligned memory accesses. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00507">507</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="BitmaskEnum_8h_source.html#l00147">llvm::BitWidth</a>.</p>

</div>
</div>
<a id="a8b6d8c70a0c8814bedea753b3e39586b" name="a8b6d8c70a0c8814bedea753b3e39586b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6d8c70a0c8814bedea753b3e39586b">&#9670;&#160;</a></span>areFunctionArgsABICompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::areFunctionArgsABICompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>Caller</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>Callee</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classllvm_1_1Argument.html">Argument</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Args</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the caller and callee agree on how <code>Args</code> will be passed to the callee. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Args</td><td>The list of compatible arguments. The implementation may filter out any incompatible args from this list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00889">889</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00220">Callee</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArgumentPromotion_8cpp_source.html#l00842">llvm::ArgumentPromotionPass::areFunctionArgsABICompatible()</a>.</p>

</div>
</div>
<a id="ad2e1f19379514bb06cdcedb2bae8748d" name="ad2e1f19379514bb06cdcedb2bae8748d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e1f19379514bb06cdcedb2bae8748d">&#9670;&#160;</a></span>areInlineCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::areInlineCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>Caller</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>Callee</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the two functions have compatible attributes for inlining purposes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00884">884</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00220">Callee</a>.</p>

<p class="reference">Referenced by <a class="el" href="InlineCost_8cpp_source.html#l02241">functionsHaveCompatibleAttributes()</a>.</p>

</div>
</div>
<a id="ad5711c8e7ef4d1848c44e839242316c3" name="ad5711c8e7ef4d1848c44e839242316c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5711c8e7ef4d1848c44e839242316c3">&#9670;&#160;</a></span>canMacroFuseCmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::canMacroFuseCmp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target can fuse a compare and branch. </p>
<p>Loop-strength-reduction (LSR) uses that knowledge to adjust its cost calculation for the instructions in a loop. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00360">360</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a884326e08a0f3d72b4f5006cf31eb76f" name="a884326e08a0f3d72b4f5006cf31eb76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884326e08a0f3d72b4f5006cf31eb76f">&#9670;&#160;</a></span>canSaveCmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::canSaveCmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Loop.html">Loop</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BranchInst.html">BranchInst</a> **</td>          <td class="paramname"><span class="paramname"><em>BI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *</td>          <td class="paramname"><span class="paramname"><em>SE</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>LI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *</td>          <td class="paramname"><span class="paramname"><em>DT</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *</td>          <td class="paramname"><span class="paramname"><em>AC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>LibInfo</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target can save a compare for loop count, for example hardware loop saves a compare. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00364">364</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a7313158dcc10a1569a2333c78cde8621" name="a7313158dcc10a1569a2333c78cde8621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7313158dcc10a1569a2333c78cde8621">&#9670;&#160;</a></span>collectFlatAddressOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::collectFlatAddressOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OpIndexes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a></td>          <td class="paramname"><span class="paramname"><em>IID</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return any intrinsic address operand indexes which may be rewritten if they use a flat address space pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the intrinsic was handled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00289">289</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a0140d82d8d964cfee71b718641bf4aa8" name="a0140d82d8d964cfee71b718641bf4aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0140d82d8d964cfee71b718641bf4aa8">&#9670;&#160;</a></span>emitGetActiveLaneMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::emitGetActiveLaneMask </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target whether lowering of the llvm.get.active.lane.mask intrinsic is supported. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00321">321</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l06815">llvm::VPRecipeBuilder::createBlockInMask()</a>.</p>

</div>
</div>
<a id="a12f25864d2ad4955cb285d871a36345b" name="a12f25864d2ad4955cb285d871a36345b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f25864d2ad4955cb285d871a36345b">&#9670;&#160;</a></span>enableAggressiveInterleaving()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::enableAggressiveInterleaving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>LoopHasReductions</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Don't restrict interleaved unrolling to small loops. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00485">485</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l05243">llvm::LoopVectorizationCostModel::selectInterleaveCount()</a>.</p>

</div>
</div>
<a id="ac501bf52c07df51c9e1242117cfc7b2f" name="ac501bf52c07df51c9e1242117cfc7b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac501bf52c07df51c9e1242117cfc7b2f">&#9670;&#160;</a></span>enableInterleavedAccessVectorization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::enableInterleavedAccessVectorization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable matching of interleaved access groups. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00495">495</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l07712">llvm::LoopVectorizePass::processLoop()</a>.</p>

</div>
</div>
<a id="a6b0734de892207738014317d233c72ad" name="a6b0734de892207738014317d233c72ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0734de892207738014317d233c72ad">&#9670;&#160;</a></span>enableMaskedInterleavedAccessVectorization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::enableMaskedInterleavedAccessVectorization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable matching of interleaved access groups that contain predicated accesses or gaps and therefore vectorized using masked vector loads/stores. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00499">499</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l02156">useMaskedInterleavedAccesses()</a>.</p>

</div>
</div>
<a id="a24629c2792a37162cf0ef4b1c38ba00c" name="a24629c2792a37162cf0ef4b1c38ba00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24629c2792a37162cf0ef4b1c38ba00c">&#9670;&#160;</a></span>enableMemCmpExpansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1MemCmpExpansionOptions.html">TargetTransformInfo::MemCmpExpansionOptions</a> TargetTransformInfo::enableMemCmpExpansion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>OptSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsZeroCmp</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00491">491</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a4ec5838370bf4a0d0af43e443ee99325" name="a4ec5838370bf4a0d0af43e443ee99325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec5838370bf4a0d0af43e443ee99325">&#9670;&#160;</a></span>enableWritePrefetching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::enableWritePrefetching </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if prefetching should also be done for writes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00632">632</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="aeffff43e8df36ddc2e166c6eac605b2b" name="aeffff43e8df36ddc2e166c6eac605b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffff43e8df36ddc2e166c6eac605b2b">&#9670;&#160;</a></span>getAddressComputationCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getAddressComputationCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *</td>          <td class="paramname"><span class="paramname"><em>SE</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *</td>          <td class="paramname"><span class="paramname"><em>Ptr</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of the address computation. For most targets this can be merged into the instruction indexing mode. Some targets might want to distinguish between address computation for memory operations on vector types and scalar types. Such targets should override this function. The 'SE' parameter holds pointer for the scalar evolution object which is used in order to get the Ptr step value in case of constant stride. The 'Ptr' parameter holds <a class="el" href="classllvm_1_1SCEV.html" title="This class represents an analyzed expression in the program.">SCEV</a> of the access pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00815">815</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RewriteStatepointsForGC_8cpp_source.html#l02017">chainToBasePointerCost()</a>.</p>

</div>
</div>
<a id="a5c4ccf555d90ee23430099f1305b5559" name="a5c4ccf555d90ee23430099f1305b5559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4ccf555d90ee23430099f1305b5559">&#9670;&#160;</a></span>getArithmeticInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getArithmeticInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a></td>          <td class="paramname"><span class="paramname"><em>Opd1Info</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a></td>          <td class="paramname"><span class="paramname"><em>Opd2Info</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a></td>          <td class="paramname"><span class="paramname"><em>Opd1PropInfo</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a></td>          <td class="paramname"><span class="paramname"><em>Opd2PropInfo</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Args</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a>&#160;<a class="el" href="classllvm_1_1Value.html">Value</a>&#160;*&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>CxtI</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an approximation of reciprocal throughput of a math/logic op. </p>
<p>A higher cost indicates less expected throughput. From Agner Fog's guides, reciprocal throughput is "the average number of
clock cycles per instruction when the instructions are not part of a
limiting dependency chain." Therefore, costs should be scaled to account for multiple execution units on the target that can process this type of instruction. For example, if there are 5 scalar integer units and 2 vector integer units that can calculate an 'add' in a single cycle, this model should indicate that the cost of the vector add instruction is 2.5 times the cost of the scalar add instruction. <code>Args</code> is an optional argument which holds the instruction operands values so the TTI can analyze those values searching for special cases or optimizations based on those values. <code>CxtI</code> is the optional original context instruction, if one exists, to provide even more information. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00690">690</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>.</p>

<p class="reference">Referenced by <a class="el" href="IndVarSimplify_8cpp_source.html#l00573">visitIVCast()</a>.</p>

</div>
</div>
<a id="a2b4e07c2d1c76ec690c39e46a5028cc8" name="a2b4e07c2d1c76ec690c39e46a5028cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4e07c2d1c76ec690c39e46a5028cc8">&#9670;&#160;</a></span>getArithmeticReductionCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getArithmeticReductionCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsPairwiseForm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the cost of performing a vector reduction. </p>
<p>This is the cost of reducing the vector value of type <code>Ty</code> to a scalar value using the operation denoted by <code>Opcode</code>. The form of the reduction can either be a pairwise reduction or a reduction that splits the vector at every reduction level.</p>
<p>Pairwise: (v0, v1, v2, v3) ((v0+v1), (v2+v3), undef, undef) Split: (v0, v1, v2, v3) ((v0+v2), (v1+v3), undef, undef) </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00829">829</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>.</p>

</div>
</div>
<a id="a422b020a05731c432411d574a7728af5" name="a422b020a05731c432411d574a7728af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422b020a05731c432411d574a7728af5">&#9670;&#160;</a></span>getAtomicMemIntrinsicMaxElementSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getAtomicMemIntrinsicMaxElementSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The maximum element size, in bytes, for an element unordered-atomic memory intrinsic. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00859">859</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a6945585b0648776b5b7893d1c13cce56" name="a6945585b0648776b5b7893d1c13cce56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6945585b0648776b5b7893d1c13cce56">&#9670;&#160;</a></span>getCacheAssociativity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; TargetTransformInfo::getCacheAssociativity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">CacheLevel</a></td>          <td class="paramname"><span class="paramname"><em>Level</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The associativity of the cache level, if available. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00613">613</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a9d04cbecfee76b1c4a5ea83aa6bb113c" name="a9d04cbecfee76b1c4a5ea83aa6bb113c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d04cbecfee76b1c4a5ea83aa6bb113c">&#9670;&#160;</a></span>getCacheLineSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getCacheLineSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size of a cache line in bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00603">603</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a11e8f29aef00ec6b5ffe4bfcc9e965f4" name="a11e8f29aef00ec6b5ffe4bfcc9e965f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e8f29aef00ec6b5ffe4bfcc9e965f4">&#9670;&#160;</a></span>getCacheSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; TargetTransformInfo::getCacheSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">CacheLevel</a></td>          <td class="paramname"><span class="paramname"><em>Level</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size of the cache level in bytes, if available. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00608">608</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a96af894d6656d485edb262dda5358605" name="a96af894d6656d485edb262dda5358605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96af894d6656d485edb262dda5358605">&#9670;&#160;</a></span>getCallInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getCallInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>F</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>RetTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Tys</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of Call instructions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00803">803</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>, <a class="el" href="MD5_8cpp_source.html#l00056">F</a>, and <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00350">RetTy</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l03287">llvm::LoopVectorizationCostModel::getVectorCallCost()</a>, and <a class="el" href="SLPVectorizer_8cpp_source.html#l03257">getVectorCallCosts()</a>.</p>

</div>
</div>
<a id="afe563f493649264d6eca3f8d35cf64b2" name="afe563f493649264d6eca3f8d35cf64b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe563f493649264d6eca3f8d35cf64b2">&#9670;&#160;</a></span>getCastInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getCastInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The expected cost of cast instructions, such as bitcast, trunc, zext, etc. If there is an existing instruction that holds Opcode, it may be passed in the 'I' parameter. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00710">710</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>, and <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="RewriteStatepointsForGC_8cpp_source.html#l02017">chainToBasePointerCost()</a>, and <a class="el" href="BasicTTIImpl_8h_source.html#l00693">llvm::BasicTTIImplBase&lt; T &gt;::getCastInstrCost()</a>.</p>

</div>
</div>
<a id="a0ecc78f5988700032cf36c4d14312cd5" name="a0ecc78f5988700032cf36c4d14312cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecc78f5988700032cf36c4d14312cd5">&#9670;&#160;</a></span>getCFInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getCFInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The expected cost of control-flow related instructions such as Phi, Ret, Br. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00728">728</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>.</p>

</div>
</div>
<a id="aca3ca06a81b22e94903157e652cb227c" name="aca3ca06a81b22e94903157e652cb227c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3ca06a81b22e94903157e652cb227c">&#9670;&#160;</a></span>getCmpSelInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getCmpSelInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>ValTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>CondTy</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The expected cost of compare and select instructions. If there is an existing instruction that holds Opcode, it may be passed in the 'I' parameter. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00735">735</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>, and <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

</div>
</div>
<a id="af170c52c54210c4f104f74279c2b6c9b" name="af170c52c54210c4f104f74279c2b6c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af170c52c54210c4f104f74279c2b6c9b">&#9670;&#160;</a></span>getCostOfKeepingLiveOverCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getCostOfKeepingLiveOverCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Tys</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost, if any, of keeping values of the given types alive over a callsite.</dd></dl>
<p>Some types may require the use of register classes that do not have any callee-saved registers, so would require a spill and fill. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00850">850</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l03759">llvm::slpvectorizer::BoUpSLP::getSpillCost()</a>.</p>

</div>
</div>
<a id="a64b0a3c3724fe2cb1b335007c068179d" name="a64b0a3c3724fe2cb1b335007c068179d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b0a3c3724fe2cb1b335007c068179d">&#9670;&#160;</a></span>getEstimatedNumberOfCaseClusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getEstimatedNumberOfCaseClusters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SwitchInst.html">SwitchInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>JTSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ProfileSummaryInfo.html">ProfileSummaryInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>PSI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BlockFrequencyInfo.html">BlockFrequencyInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>BFI</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The estimated number of case clusters when lowering <code>'<a class="el" href="namespacellvm_1_1SI.html">SI</a>'</code>. <code>JTSize</code> Set a jump table size only when <code><a class="el" href="namespacellvm_1_1SI.html">SI</a></code> is suitable for a jump table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00254">254</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SIInstrInfo_8cpp_source.html#l06827">SI</a>.</p>

</div>
</div>
<a id="a87247352d5aa1adf0dc5ff4d95bc29cf" name="a87247352d5aa1adf0dc5ff4d95bc29cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87247352d5aa1adf0dc5ff4d95bc29cf">&#9670;&#160;</a></span>getExtractWithExtendCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getExtractWithExtendCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>VecTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Index</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The expected cost of a sign- or zero-extended vector extract. <a class="el" href="classllvm_1_1Use.html" title="A Use represents the edge between a Value definition and its users.">Use</a> -1 to indicate that there is no information about the index value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00720">720</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l03828">llvm::slpvectorizer::BoUpSLP::getTreeCost()</a>.</p>

</div>
</div>
<a id="a93e74cc1819ce2f8f151a1900284ce89" name="a93e74cc1819ce2f8f151a1900284ce89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e74cc1819ce2f8f151a1900284ce89">&#9670;&#160;</a></span>getFlatAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getFlatAddressSpace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the address space ID for a target's 'flat' address space. </p>
<p>Note this is not necessarily the same as addrspace(0), which LLVM sometimes refers to as the generic address space. The flat address space is a generic address space that can be used access multiple segments of memory with different address spaces. Access of a memory location through a pointer with this address space is expected to be legal but slower compared to the same memory location accessed through a pointer with a different address space. This is for targets with different pointer representations which can be converted with the addrspacecast instruction. If a pointer is converted to this address space, optimizations should attempt to replace the access with the source address space.</p>
<dl class="section return"><dt>Returns</dt><dd>~0u if the target does not have such a flat address space to optimize away. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00285">285</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ac0ac98bceb9d018f191156fc6ed5d921" name="ac0ac98bceb9d018f191156fc6ed5d921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ac98bceb9d018f191156fc6ed5d921">&#9670;&#160;</a></span>getFPOpCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getFPOpCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the expected cost of supporting the floating point operation of the specified type. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00529">529</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>.</p>

</div>
</div>
<a id="a46829cb9cfbba1d9f4f82487dd85c010" name="a46829cb9cfbba1d9f4f82487dd85c010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46829cb9cfbba1d9f4f82487dd85c010">&#9670;&#160;</a></span>getGatherScatterOpCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getGatherScatterOpCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>VariableMask</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of Gather or Scatter operation <code>Opcode</code> - is a type of memory access Load or Store <code>DataTy</code> - a vector type of the data to be loaded or stored <code>Ptr</code> - pointer [or vector of pointers] - address[es] in memory <code>VariableMask</code> - true when the memory access is predicated with a mask that is not a compile-time constant <code>Alignment</code> - alignment of single element <code>I</code> - the optional original context instruction, if one exists, e.g. the load/store to transform or the call to the gather/scatter intrinsic </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00775">775</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>, and <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

</div>
</div>
<a id="ac1fb6bdf8c0631c76b6180f855cf0876" name="ac1fb6bdf8c0631c76b6180f855cf0876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fb6bdf8c0631c76b6180f855cf0876">&#9670;&#160;</a></span>getGEPCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getGEPCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>PointeeType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Operands</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TCK_SizeAndLatency</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the cost of a GEP operation when lowered. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00248">248</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>, and <a class="el" href="MIRNamerPass_8cpp_source.html#l00078">Operands</a>.</p>

<p class="reference">Referenced by <a class="el" href="NaryReassociate_8cpp_source.html#l00298">isGEPFoldable()</a>, and <a class="el" href="StraightLineStrengthReduce_8cpp_source.html#l00273">isGEPFoldable()</a>.</p>

</div>
</div>
<a id="acd2f1ef61f1c352da3b8121d4ea2c585" name="acd2f1ef61f1c352da3b8121d4ea2c585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2f1ef61f1c352da3b8121d4ea2c585">&#9670;&#160;</a></span>getGISelRematGlobalCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getGISelRematGlobalCost </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size cost of rematerializing a <a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> address relative to a stack reload. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00952">952</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetLoweringBase_8cpp_source.html#l02128">llvm::TargetLoweringBase::shouldLocalize()</a>.</p>

</div>
</div>
<a id="aa30e16357eef0a6bb3dc98fb7fd67684" name="aa30e16357eef0a6bb3dc98fb7fd67684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30e16357eef0a6bb3dc98fb7fd67684">&#9670;&#160;</a></span>getInlinerVectorBonusPercent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getInlinerVectorBonusPercent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Vector bonus in percent.</dd></dl>
<p>Vector bonuses: We want to more aggressively inline vector-dense kernels and apply this bonus based on the percentage of vector instructions. A bonus is applied if the vector instructions exceed 50% and half that amount is applied if it exceeds 10%. Note that these bonuses are some what arbitrary and evolved over time by accident as much as because they are principled bonuses. FIXME: It would be nice to base the bonus values on something more scientific. A target may has no bonus on vector instructions. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00244">244</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="aab827381fb7034818435387572088683" name="aab827381fb7034818435387572088683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab827381fb7034818435387572088683">&#9670;&#160;</a></span>getInliningThresholdMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getInliningThresholdMultiplier </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A value by which our inlining threshold should be multiplied. This is primarily used to bump up the inlining threshold wholesale on targets where calls are unusually expensive.</dd></dl>
<p>TODO: This is a rather blunt instrument. Perhaps altering the costs of individual classes of instructions would be better. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00240">240</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a13b4e8542880166eab65f6552524b385" name="a13b4e8542880166eab65f6552524b385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b4e8542880166eab65f6552524b385">&#9670;&#160;</a></span>getInstructionCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int llvm::TargetTransformInfo::getInstructionCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the cost of a specified instruction. </p>
<p>Clients should use this interface to query the cost of an existing instruction. The instruction must have a valid parent (basic block).</p>
<p>Note, this method does not cache the cost calculation and it can be expensive in some cases. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00231">231</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

<p class="reference">References <a class="el" href="TargetTransformInfo_8cpp_source.html#l00260">getUserCost()</a>, <a class="el" href="MD5_8cpp_source.html#l00059">I</a>, <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00136">llvm_unreachable</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l00220">TCK_CodeSize</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l00219">TCK_Latency</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l00218">TCK_RecipThroughput</a>, and <a class="el" href="TargetTransformInfo_8h_source.html#l00221">TCK_SizeAndLatency</a>.</p>

<p class="reference">Referenced by <a class="el" href="CallSiteSplitting_8cpp_source.html#l00186">canSplitCallSite()</a>, and <a class="el" href="HotColdSplitting_8cpp_source.html#l00224">getOutliningBenefit()</a>.</p>

</div>
</div>
<a id="afba3bfea3d59d0bd4f6d949da9b465de" name="afba3bfea3d59d0bd4f6d949da9b465de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba3bfea3d59d0bd4f6d949da9b465de">&#9670;&#160;</a></span>getInterleavedMemoryOpCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getInterleavedMemoryOpCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>VecTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Factor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Indices</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddressSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>UseMaskForCond</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>UseMaskForGaps</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of the interleaved memory operation. <code>Opcode</code> is the memory operation code <code>VecTy</code> is the vector type of the interleaved access. <code>Factor</code> is the interleave factor <code>Indices</code> is the indices for interleaved load members (as interleaved load allows gaps) <code>Alignment</code> is the alignment of the memory operation <code>AddressSpace</code> is address space of the pointer. <code>UseMaskForCond</code> indicates if the memory access is predicated. <code>UseMaskForGaps</code> indicates if gaps should be masked. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00784">784</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>.</p>

</div>
</div>
<a id="ae6df646941dd85d0ed3e7389212956c4" name="ae6df646941dd85d0ed3e7389212956c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6df646941dd85d0ed3e7389212956c4">&#9670;&#160;</a></span>getIntImmCodeSizeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getIntImmCodeSizeCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Idx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Imm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the expected cost for the given integer when optimising for size. </p>
<p>This is different than the other integer immediate cost functions in that it is subtarget agnostic. This is useful when you e.g. target one ISA such as Aarch32 but smaller encodings could be possible with another such as Thumb. This return value is used as a penalty when the total costs for a constant is calculated (the bigger the cost, the more beneficial constant hoisting is). </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00535">535</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00341">Idx</a>.</p>

</div>
</div>
<a id="a7393c92b10697eeaf3855bf94cd38208" name="a7393c92b10697eeaf3855bf94cd38208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7393c92b10697eeaf3855bf94cd38208">&#9670;&#160;</a></span>getIntImmCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getIntImmCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Imm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the expected cost of materializing for the given integer immediate of the specified type. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00543">543</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>.</p>

<p class="reference">Referenced by <a class="el" href="SpeculateAroundPHIs_8cpp_source.html#l00202">isSafeAndProfitableToSpeculateAroundPHI()</a>, and <a class="el" href="CodeGenPrepare_8cpp_source.html#l07337">tryUnmergingGEPsAcrossIndirectBr()</a>.</p>

</div>
</div>
<a id="a5ad36e85f0146b637ea451a7799a3ad6" name="a5ad36e85f0146b637ea451a7799a3ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad36e85f0146b637ea451a7799a3ad6">&#9670;&#160;</a></span>getIntImmCostInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getIntImmCostInst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Idx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Imm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the expected cost of materialization for the given integer immediate of the specified type for a given instruction. </p>
<p>The cost can be zero if the immediate can be folded into the specified instruction. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00551">551</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>, and <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00341">Idx</a>.</p>

<p class="reference">Referenced by <a class="el" href="SpeculateAroundPHIs_8cpp_source.html#l00202">isSafeAndProfitableToSpeculateAroundPHI()</a>.</p>

</div>
</div>
<a id="acb345652eeddb72145390f0cfd08eb39" name="acb345652eeddb72145390f0cfd08eb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb345652eeddb72145390f0cfd08eb39">&#9670;&#160;</a></span>getIntImmCostIntrin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getIntImmCostIntrin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a></td>          <td class="paramname"><span class="paramname"><em>IID</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Idx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Imm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00560">560</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>, and <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00341">Idx</a>.</p>

<p class="reference">Referenced by <a class="el" href="SpeculateAroundPHIs_8cpp_source.html#l00202">isSafeAndProfitableToSpeculateAroundPHI()</a>.</p>

</div>
</div>
<a id="a46c041300ad39485270ae0cae5e04ca3" name="a46c041300ad39485270ae0cae5e04ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c041300ad39485270ae0cae5e04ca3">&#9670;&#160;</a></span>getIntrinsicInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getIntrinsicInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1IntrinsicCostAttributes.html">IntrinsicCostAttributes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ICA</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of <a class="el" href="namespacellvm_1_1Intrinsic.html" title="This namespace contains an enum with a value for every intrinsic/builtin function known by LLVM.">Intrinsic</a> instructions. Analyses the real arguments. Three cases are handled: 1. scalar instruction 2. vector instruction<ol type="1">
<li>scalar instruction which is to be vectorized. </li>
</ol>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00796">796</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l03257">getVectorCallCosts()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l03335">llvm::LoopVectorizationCostModel::getVectorIntrinsicCost()</a>.</p>

</div>
</div>
<a id="a5c9d2da3e41e4cc90c7a552258166277" name="a5c9d2da3e41e4cc90c7a552258166277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9d2da3e41e4cc90c7a552258166277">&#9670;&#160;</a></span>getLoadStoreVecRegBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getLoadStoreVecRegBitWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The bitwidth of the largest vector type that should be used to load/store in the given address space. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00905">905</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a84e51850e7e39c4bd2424ad98c12e700" name="a84e51850e7e39c4bd2424ad98c12e700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e51850e7e39c4bd2424ad98c12e700">&#9670;&#160;</a></span>getLoadVectorFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getLoadVectorFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>VF</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>LoadSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ChainSizeInBytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>VecTy</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The new vector factor value if the target doesn't support <code>SizeInBytes</code> loads or has a better vector factor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00929">929</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ae9593fa2b845a20c0fc8211b745a2c39" name="ae9593fa2b845a20c0fc8211b745a2c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9593fa2b845a20c0fc8211b745a2c39">&#9670;&#160;</a></span>getMaskedMemoryOpCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getMaskedMemoryOpCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddressSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of masked Load and Store instructions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00765">765</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>.</p>

</div>
</div>
<a id="a4ed57eef29fa5e077bd059050c293723" name="a4ed57eef29fa5e077bd059050c293723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed57eef29fa5e077bd059050c293723">&#9670;&#160;</a></span>getMaxInterleaveFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMaxInterleaveFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>VF</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The maximum interleave factor that any transform should try to perform for this target. This number depends on the level of parallelism and the number of execution units in the CPU. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00636">636</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l08008">llvm::LoopVectorizePass::runImpl()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l05243">llvm::LoopVectorizationCostModel::selectInterleaveCount()</a>.</p>

</div>
</div>
<a id="a66cb8d0f215f1b7b66e4a7d6581b3a16" name="a66cb8d0f215f1b7b66e4a7d6581b3a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cb8d0f215f1b7b66e4a7d6581b3a16">&#9670;&#160;</a></span>getMaxPrefetchIterationsAhead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMaxPrefetchIterationsAhead </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The maximum number of iterations to prefetch ahead. If the required number of iterations is more than this number, no prefetching is performed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00628">628</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="abfde6fed613809d141d1f84ff3c4cf8d" name="abfde6fed613809d141d1f84ff3c4cf8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfde6fed613809d141d1f84ff3c4cf8d">&#9670;&#160;</a></span>getMemcpyCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getMemcpyCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the expected cost of a memcpy, which could e.g. depend on the source/destination type and alignment and the number of bytes copied. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00823">823</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

</div>
</div>
<a id="a3897d734249f9b6418e23af2ac90f519" name="a3897d734249f9b6418e23af2ac90f519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3897d734249f9b6418e23af2ac90f519">&#9670;&#160;</a></span>getMemcpyLoopLoweringType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Type.html">Type</a> * TargetTransformInfo::getMemcpyLoopLoweringType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>SrcAddrSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DestAddrSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>SrcAlign</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DestAlign</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type to use in a loop expansion of a memcpy call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00868">868</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerMemIntrinsics_8cpp_source.html#l00017">llvm::createMemCpyLoopKnownSize()</a>, and <a class="el" href="LowerMemIntrinsics_8cpp_source.html#l00133">llvm::createMemCpyLoopUnknownSize()</a>.</p>

</div>
</div>
<a id="a48a7d1c2f35967ddf0c71595681c28b1" name="a48a7d1c2f35967ddf0c71595681c28b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a7d1c2f35967ddf0c71595681c28b1">&#9670;&#160;</a></span>getMemcpyLoopResidualLoweringType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> TargetTransformInfo::getMemcpyLoopResidualLoweringType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OpsOut</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>RemainingBytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>SrcAddrSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DestAddrSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>SrcAlign</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DestAlign</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">OpsOut</td><td>The operand types to copy RemainingBytes of memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">RemainingBytes</td><td>The number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>Calculates the operand types to use when copying <code>RemainingBytes</code> of memory, where source and destination alignments are <code>SrcAlign</code> and <code>DestAlign</code> respectively. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00875">875</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerMemIntrinsics_8cpp_source.html#l00017">llvm::createMemCpyLoopKnownSize()</a>.</p>

</div>
</div>
<a id="aae942e05b7d4e3620c953d6cef1455ea" name="aae942e05b7d4e3620c953d6cef1455ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae942e05b7d4e3620c953d6cef1455ea">&#9670;&#160;</a></span>getMemoryOpCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getMemoryOpCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddressSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of Load and Store instructions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00753">753</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>, and <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

</div>
</div>
<a id="ab346e9f55e10dbcffdd133e9651b9405" name="ab346e9f55e10dbcffdd133e9651b9405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab346e9f55e10dbcffdd133e9651b9405">&#9670;&#160;</a></span>getMinimumVF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMinimumVF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ElemWidth</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The minimum vectorization factor for types of given element bit width, or 0 if there is no minimum VF. The returned value only applies when shouldMaximizeVectorBandwidth returns true. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00593">593</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a81c3f091dcb70a1f299fe00947684554" name="a81c3f091dcb70a1f299fe00947684554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c3f091dcb70a1f299fe00947684554">&#9670;&#160;</a></span>getMinMaxReductionCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getMinMaxReductionCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>CondTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsPairwiseForm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsUnsigned</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00839">839</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>.</p>

</div>
</div>
<a id="a8dcadecc95e9e49f77a70ab8b99a8c35" name="a8dcadecc95e9e49f77a70ab8b99a8c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcadecc95e9e49f77a70ab8b99a8c35">&#9670;&#160;</a></span>getMinPrefetchStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMinPrefetchStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumMemAccesses</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumStridedMemAccesses</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumPrefetches</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>HasCall</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some HW prefetchers can handle accesses up to a certain constant stride. </p>
<p>Sometimes prefetching is beneficial even below the HW prefetcher limit, and the arguments provided are meant to serve as a basis for deciding this for a particular loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumMemAccesses</td><td>Number of memory accesses in the loop. </td></tr>
    <tr><td class="paramname">NumStridedMemAccesses</td><td>Number of the memory accesses that <a class="el" href="classllvm_1_1ScalarEvolution.html" title="The main scalar evolution driver.">ScalarEvolution</a> could find a known stride for. </td></tr>
    <tr><td class="paramname">NumPrefetches</td><td>Number of software prefetches that will be emitted as determined by the addresses involved and the cache line size. </td></tr>
    <tr><td class="paramname">HasCall</td><td>True if the loop contains a call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is the minimum stride in bytes where it makes sense to start adding SW prefetches. The default is 1, i.e. prefetch with any stride. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00621">621</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a8fa8b3631e74e836453f972aac6b4b65" name="a8fa8b3631e74e836453f972aac6b4b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa8b3631e74e836453f972aac6b4b65">&#9670;&#160;</a></span>getMinVectorRegisterBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMinVectorRegisterBitWidth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The width of the smallest vector register type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00585">585</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l00539">llvm::slpvectorizer::BoUpSLP::BoUpSLP()</a>.</p>

</div>
</div>
<a id="ad67b7e389a52ada1d5264e23d09f4cbe" name="ad67b7e389a52ada1d5264e23d09f4cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67b7e389a52ada1d5264e23d09f4cbe">&#9670;&#160;</a></span>getNumberOfParts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getNumberOfParts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Tp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of pieces into which the provided type must be split during legalization. Zero is returned when the answer is unknown. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00811">811</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="aae0e8ca52658f54e5cc6214eb1a291ef" name="aae0e8ca52658f54e5cc6214eb1a291ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0e8ca52658f54e5cc6214eb1a291ef">&#9670;&#160;</a></span>getNumberOfRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getNumberOfRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ClassID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of registers in the target-provided register class. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00568">568</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l08008">llvm::LoopVectorizePass::runImpl()</a>, <a class="el" href="SLPVectorizer_8cpp_source.html#l05684">llvm::SLPVectorizerPass::runImpl()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l05243">llvm::LoopVectorizationCostModel::selectInterleaveCount()</a>.</p>

</div>
</div>
<a id="a0a884ac711aafcdbc1715b68975cd7ec" name="a0a884ac711aafcdbc1715b68975cd7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a884ac711aafcdbc1715b68975cd7ec">&#9670;&#160;</a></span>getOperandInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afa38851d75434d1476444ac93f94cb4c">TargetTransformInfo::OperandValueKind</a> TargetTransformInfo::getOperandInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OpProps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect properties of V used in cost analysis, e.g. OP_PowerOf2. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00641">641</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00339">llvm::getSplatValue()</a>, <a class="el" href="MD5_8cpp_source.html#l00059">I</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l00850">OK_AnyValue</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l00853">OK_NonUniformConstantValue</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l00852">OK_UniformConstantValue</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l00851">OK_UniformValue</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l00857">OP_None</a>, and <a class="el" href="TargetTransformInfo_8h_source.html#l00857">OP_PowerOf2</a>.</p>

<p class="reference">Referenced by <a class="el" href="BasicTTIImpl_8h_source.html#l01100">llvm::BasicTTIImplBase&lt; T &gt;::getIntrinsicInstrCost()</a>, and <a class="el" href="TargetTransformInfoImpl_8h_source.html#l00800">llvm::TargetTransformInfoImplCRTPBase&lt; T &gt;::getUserCost()</a>.</p>

</div>
</div>
<a id="a9746bddf7711816a2e7853dea177cef1" name="a9746bddf7711816a2e7853dea177cef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9746bddf7711816a2e7853dea177cef1">&#9670;&#160;</a></span>getOperandsScalarizationOverhead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getOperandsScalarizationOverhead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Args</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>VF</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the overhead of scalarizing an instructions unique non-constant operands. </p>
<p>The types of the arguments are ordinarily scalar, in which case the costs are multiplied with VF. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00476">476</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ad5e18a8730e428b4967b375d57c2e401" name="ad5e18a8730e428b4967b375d57c2e401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e18a8730e428b4967b375d57c2e401">&#9670;&#160;</a></span>getOrCreateResultFromMemIntrinsic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Value.html">Value</a> * TargetTransformInfo::getOrCreateResultFromMemIntrinsic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Inst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>ExpectedType</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A value which is the result of the given memory intrinsic. New instructions may be created to extract the result from the given intrinsic memory operation. Returns nullptr if the target cannot create a result from the given intrinsic. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00863">863</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="af513fb5e9b4731b5b8315d757d5a252f" name="af513fb5e9b4731b5b8315d757d5a252f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af513fb5e9b4731b5b8315d757d5a252f">&#9670;&#160;</a></span>getPeelingPreferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> TargetTransformInfo::getPeelingPreferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Loop.html">Loop</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SE</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1PeelingPreferences.html">PeelingPreferences</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>PP</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target-customized preferences for the generic loop peeling transformation. </p>
<p>The caller will initialize <code>PP</code> with the current target-independent defaults with information from <code>L</code> and <code>SE</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00330">330</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrollPass_8cpp_source.html#l00279">llvm::gatherPeelingPreferences()</a>.</p>

</div>
</div>
<a id="a6480799b120b617b9b34f1313afe6661" name="a6480799b120b617b9b34f1313afe6661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6480799b120b617b9b34f1313afe6661">&#9670;&#160;</a></span>getPopcntSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbe">TargetTransformInfo::PopcntSupportKind</a> TargetTransformInfo::getPopcntSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>IntTyWidthInBit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return hardware support for population count. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00517">517</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a1e3f3a3d549cf057479e744e7ecfd7e1" name="a1e3f3a3d549cf057479e744e7ecfd7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3f3a3d549cf057479e744e7ecfd7e1">&#9670;&#160;</a></span>getPrefetchDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getPrefetchDistance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>How much before a load we should place the prefetch instruction. This is currently measured in number of instructions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00617">617</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a993b6b21885bc9a48c53230a3d8b3072" name="a993b6b21885bc9a48c53230a3d8b3072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993b6b21885bc9a48c53230a3d8b3072">&#9670;&#160;</a></span>getRegisterBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getRegisterBitWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>Vector</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The width of the largest scalar or vector register type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00581">581</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39a57dea6f5039281b7fee517fc43bf3110">llvm::Vector</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l00539">llvm::slpvectorizer::BoUpSLP::BoUpSLP()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l05416">llvm::LoopVectorizationCostModel::calculateRegisterUsage()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l06530">llvm::LoopVectorizationPlanner::planInVPlanNativePath()</a>.</p>

</div>
</div>
<a id="a623cced59353f83cc5eaba4068c57694" name="a623cced59353f83cc5eaba4068c57694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623cced59353f83cc5eaba4068c57694">&#9670;&#160;</a></span>getRegisterClassForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getRegisterClassForType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>Vector</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the target-provided register class ID for the provided type, accounting for type promotion and other type-legalization techniques that the target might apply. However, it specifically does not account for the scalarization or splitting of vector types. Should a vector type require scalarization or splitting into multiple underlying vector registers, that type should be mapped to a register class containing no registers. Specifically, this is designed to provide a simple, high-level view of the register allocation later performed by the backend. These register classes don't necessarily map onto the register classes used by the backend. FIXME: It's not currently possible to determine how many registers are used by the provided type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00572">572</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39a57dea6f5039281b7fee517fc43bf3110">llvm::Vector</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l05416">llvm::LoopVectorizationCostModel::calculateRegisterUsage()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l08008">llvm::LoopVectorizePass::runImpl()</a>, and <a class="el" href="SLPVectorizer_8cpp_source.html#l05684">llvm::SLPVectorizerPass::runImpl()</a>.</p>

</div>
</div>
<a id="a97503ae3ef00c5f1eaffa5bbeb0a4357" name="a97503ae3ef00c5f1eaffa5bbeb0a4357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97503ae3ef00c5f1eaffa5bbeb0a4357">&#9670;&#160;</a></span>getRegisterClassName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> * TargetTransformInfo::getRegisterClassName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ClassID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the target-provided register class name </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00577">577</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l05416">llvm::LoopVectorizationCostModel::calculateRegisterUsage()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l05243">llvm::LoopVectorizationCostModel::selectInterleaveCount()</a>.</p>

</div>
</div>
<a id="a3460783b1205071ee74d9db510dad0c8" name="a3460783b1205071ee74d9db510dad0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3460783b1205071ee74d9db510dad0c8">&#9670;&#160;</a></span>getScalarizationOverhead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getScalarizationOverhead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DemandedElts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>Insert</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>Extract</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the overhead of scalarizing an instruction. </p>
<p>Insert and Extract are set if the demanded result elements need to be inserted and/or extracted from vectors. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00470">470</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="aae66a93e348639259141a46230239c13" name="aae66a93e348639259141a46230239c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae66a93e348639259141a46230239c13">&#9670;&#160;</a></span>getScalingFactorCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getScalingFactorCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *</td>          <td class="paramname"><span class="paramname"><em>BaseGV</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>BaseOffset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>HasBaseReg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Scale</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the cost of the scaling factor used in the addressing mode represented by AM for this target, for a load/store of the specified type. </p>
<p>If the AM is supported, the return value must be &gt;= 0. If the AM is not supported, it returns a negative value. TODO: Handle pre/postinc as well. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00429">429</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l01749">getScalingFactorCost()</a>.</p>

</div>
</div>
<a id="a917e3117709a8e81dee75edb5e7d3459" name="a917e3117709a8e81dee75edb5e7d3459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917e3117709a8e81dee75edb5e7d3459">&#9670;&#160;</a></span>getShuffleCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getShuffleCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ec">ShuffleKind</a></td>          <td class="paramname"><span class="paramname"><em>Kind</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Tp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>Index</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>SubTp</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of a shuffle instruction of kind Kind and of type Tp. The index and subtype parameters are used by the subvector insertion and extraction shuffle kinds to show the insert/extract point and the type of the subvector being inserted/extracted. NOTE: For subvector extractions Tp represents the source type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00703">703</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>.</p>

</div>
</div>
<a id="a47da5df7f765cada1df9036a3433e1a4" name="a47da5df7f765cada1df9036a3433e1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47da5df7f765cada1df9036a3433e1a4">&#9670;&#160;</a></span>getStoreVectorFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getStoreVectorFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>VF</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>StoreSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ChainSizeInBytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>VecTy</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The new vector factor value if the target doesn't support <code>SizeInBytes</code> stores or has a better vector factor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00936">936</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a02e4dcfc435f179592619b03330f643b" name="a02e4dcfc435f179592619b03330f643b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e4dcfc435f179592619b03330f643b">&#9670;&#160;</a></span>getTgtMemIntrinsic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::getTgtMemIntrinsic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Inst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1MemIntrinsicInfo.html">MemIntrinsicInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Info</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the intrinsic is a supported memory intrinsic. Info will contain additional information - whether the intrinsic may write or read to memory, volatility and the pointer. Info is undefined if false is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00854">854</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l00846">getAccessType()</a>, and <a class="el" href="LoopStrengthReduce_8cpp_source.html#l00801">isAddressUse()</a>.</p>

</div>
</div>
<a id="add6c1c398e1c18db2de1bacbd80e332f" name="add6c1c398e1c18db2de1bacbd80e332f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6c1c398e1c18db2de1bacbd80e332f">&#9670;&#160;</a></span>getUnrollingPreferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> TargetTransformInfo::getUnrollingPreferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Loop.html">Loop</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SE</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html">UnrollingPreferences</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UP</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target-customized preferences for the generic loop unrolling transformation. </p>
<p>The caller will initialize UP with the current target-independent defaults. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00325">325</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrollPass_8cpp_source.html#l00191">llvm::gatherUnrollingPreferences()</a>.</p>

</div>
</div>
<a id="ab4561fdeb3aa9e2787cba13dd4ad3244" name="ab4561fdeb3aa9e2787cba13dd4ad3244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4561fdeb3aa9e2787cba13dd4ad3244">&#9670;&#160;</a></span>getUserCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getUserCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1User.html">User</a> *</td>          <td class="paramname"><span class="paramname"><em>U</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Operands</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the cost of a given IR user when lowered. </p>
<p>This can estimate the cost of either a <a class="el" href="classllvm_1_1ConstantExpr.html" title="A constant value that is initialized with an expression using other constant values.">ConstantExpr</a> or <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> when lowered.</p>
<p><code>Operands</code> is a list of operands which can be a result of transformations of the current operands. The number of the operands on the list must equal to the number of the current operands the IR user has. Their order on the list must be the same as the order of the current operands the IR user has.</p>
<p>The returned cost is defined in terms of <code>TargetCostConstants</code>, see its comments for a detailed explanation of the cost values. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00260">260</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>, <a class="el" href="MIRNamerPass_8cpp_source.html#l00078">Operands</a>, and <a class="el" href="TargetTransformInfo_8h_source.html#l00218">TCK_RecipThroughput</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeMetrics_8cpp_source.html#l00115">llvm::CodeMetrics::analyzeBasicBlock()</a>, <a class="el" href="LoopUnrollPass_8cpp_source.html#l00373">analyzeLoopUnrollCost()</a>, <a class="el" href="SpeculativeExecution_8cpp_source.html#l00213">llvm::ComputeSpeculationCost()</a>, <a class="el" href="SimplifyCFG_8cpp_source.html#l00334">ComputeSpeculationCost()</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l00231">getInstructionCost()</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l00325">getUserCost()</a>, <a class="el" href="LICM_8cpp_source.html#l01260">isFreeInLoop()</a>, <a class="el" href="SimplifyCFG_8cpp_source.html#l03018">mergeConditionalStoreToAddress()</a>, <a class="el" href="CodeGenPrepare_8cpp_source.html#l06307">sinkSelectOperand()</a>, and <a class="el" href="SimpleLoopUnswitch_8cpp_source.html#l02563">unswitchBestCondition()</a>.</p>

</div>
</div>
<a id="ab732975bf823facb36f2d20b26c3478c" name="ab732975bf823facb36f2d20b26c3478c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab732975bf823facb36f2d20b26c3478c">&#9670;&#160;</a></span>getUserCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int llvm::TargetTransformInfo::getUserCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1User.html">User</a> *</td>          <td class="paramname"><span class="paramname"><em>U</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a helper function which calls the two-argument getUserCost with <code>Operands</code> which are the current operands U has. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00325">325</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

<p class="reference">References <a class="el" href="CostModel_8cpp.html#a1d9e858ab2314c657af66200c663ab1a">CostKind</a>, <a class="el" href="TargetTransformInfo_8cpp_source.html#l00260">getUserCost()</a>, and <a class="el" href="MIRNamerPass_8cpp_source.html#l00078">Operands</a>.</p>

</div>
</div>
<a id="a4fe5a68d990207678993ce77ffb6da78" name="a4fe5a68d990207678993ce77ffb6da78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe5a68d990207678993ce77ffb6da78">&#9670;&#160;</a></span>getVectorInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getVectorInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Val</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Index</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The expected cost of vector Insert and Extract. <a class="el" href="classllvm_1_1Use.html" title="A Use represents the edge between a Value definition and its users.">Use</a> -1 to indicate that there is no information on the index value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00746">746</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l03828">llvm::slpvectorizer::BoUpSLP::getTreeCost()</a>.</p>

</div>
</div>
<a id="aa2374d75320454634f43cb4146236e95" name="aa2374d75320454634f43cb4146236e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2374d75320454634f43cb4146236e95">&#9670;&#160;</a></span>hasActiveVectorLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetTransformInfo::hasActiveVectorLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c0b137bcf194671c30aba4e2fab073d" name="a1c0b137bcf194671c30aba4e2fab073d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0b137bcf194671c30aba4e2fab073d">&#9670;&#160;</a></span>hasBranchDivergence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::hasBranchDivergence </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if branch divergence exists. </p>
<p>Branch divergence has a significantly negative impact on GPU performance when threads in the same wavefront take different paths due to conditional branches. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00269">269</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l04964">llvm::LoopVectorizationCostModel::computeMaxVF()</a>, <a class="el" href="SpeculativeExecution_8cpp_source.html#l00154">llvm::SpeculativeExecutionPass::runImpl()</a>, and <a class="el" href="LegacyDivergenceAnalysis_8cpp_source.html#l00321">llvm::LegacyDivergenceAnalysis::runOnFunction()</a>.</p>

</div>
</div>
<a id="ac31bf22f119c5a99c36646d8e0eb2c0f" name="ac31bf22f119c5a99c36646d8e0eb2c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31bf22f119c5a99c36646d8e0eb2c0f">&#9670;&#160;</a></span>hasDivRemOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::hasDivRemOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsSigned</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target has a unified operation to calculate division and remainder. </p>
<p>If so, the additional implicit multiplication and subtraction required to calculate a remainder from division are free. This can enable more aggressive transformations for division and remainder than would typically be allowed using throughput or size cost models. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00416">416</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DivRemPairs_8cpp_source.html#l00183">optimizeDivRem()</a>.</p>

</div>
</div>
<a id="ab33e1370498d06e0760c2861ff25e43a" name="ab33e1370498d06e0760c2861ff25e43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33e1370498d06e0760c2861ff25e43a">&#9670;&#160;</a></span>hasVolatileVariant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::hasVolatileVariant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given instruction (assumed to be a memory access instruction) has a volatile variant. </p>
<p>If that's the case then we can avoid addrspacecast to generic AS for volatile loads/stores. Default implementation returns false, which prevents address space inference for volatile loads/stores. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00420">420</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="InferAddressSpaces_8cpp_source.html#l00875">isSimplePointerUseValidToReplace()</a>.</p>

</div>
</div>
<a id="aef998bb15ea045fc769232b62ad0d968" name="aef998bb15ea045fc769232b62ad0d968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef998bb15ea045fc769232b62ad0d968">&#9670;&#160;</a></span>haveFastSqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::haveFastSqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the hardware has a fast square-root instruction. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00521">521</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="PartiallyInlineLibCalls_8cpp_source.html#l00090">runPartiallyInlineLibCalls()</a>.</p>

</div>
</div>
<a id="a2528c700b439460d668d188813ebf08c" name="a2528c700b439460d668d188813ebf08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2528c700b439460d668d188813ebf08c">&#9670;&#160;</a></span>invalidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetTransformInfo::invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1PreservedAnalyses.html">PreservedAnalyses</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1AnalysisManager_1_1Invalidator.html">FunctionAnalysisManager::Invalidator</a> &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the invalidation of this information. </p>
<p>When used as a result of <code><a class="el" href="classllvm_1_1TargetIRAnalysis.html" title="Analysis pass providing the TargetTransformInfo.">TargetIRAnalysis</a></code> this method will be called when the function this was computed for changes. When it returns false, the information is preserved across those changes. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00203">203</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="a1b21625ceb4a9d9eb225fa18cbf951de" name="a1b21625ceb4a9d9eb225fa18cbf951de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b21625ceb4a9d9eb225fa18cbf951de">&#9670;&#160;</a></span>isAlwaysUniform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetTransformInfo::isAlwaysUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00281">281</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DivergenceAnalysis_8cpp_source.html#l00442">llvm::GPUDivergenceAnalysis::GPUDivergenceAnalysis()</a>.</p>

</div>
</div>
<a id="a199e3382d45514816f88cb65310decb4" name="a199e3382d45514816f88cb65310decb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199e3382d45514816f88cb65310decb4">&#9670;&#160;</a></span>isFCmpOrdCheaperThanFCmpZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isFCmpOrdCheaperThanFCmpZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if it is faster to check if a floating-point value is NaN (or not-NaN) versus a comparison against a constant FP zero value. </p>
<p>Targets should override this if materializing a 0.0 for comparison is generally as cheap as checking for ordered/unordered. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00525">525</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="PartiallyInlineLibCalls_8cpp_source.html#l00031">optimizeSQRT()</a>.</p>

</div>
</div>
<a id="ab75d51988243f8ea9086b110401f8758" name="ab75d51988243f8ea9086b110401f8758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75d51988243f8ea9086b110401f8758">&#9670;&#160;</a></span>isFPVectorizationPotentiallyUnsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isFPVectorizationPotentiallyUnsafe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate that it is potentially unsafe to automatically vectorize floating-point operations because the semantics of vector and scalar floating-point semantics may differ. </p>
<p>For example, <a class="el" href="namespacellvm_1_1ARM.html" title="Define some predicates that are used for node matching.">ARM</a> NEON v7 SIMD math does not support IEEE-754 denormal numbers, while depending on the platform, scalar floating-point math does. This applies to floating-point math operations and calls, not memory operations, shuffles, or casts. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00503">503</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l07712">llvm::LoopVectorizePass::processLoop()</a>.</p>

</div>
</div>
<a id="aaae1d7de61213a91194e93174081ab4d" name="aaae1d7de61213a91194e93174081ab4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae1d7de61213a91194e93174081ab4d">&#9670;&#160;</a></span>isHardwareLoopProfitable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isHardwareLoopProfitable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Loop.html">Loop</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SE</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>AC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>LibInfo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1HardwareLoopInfo.html">HardwareLoopInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>HWLoopInfo</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target whether it would be profitable to convert the given loop into a hardware loop. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00308">308</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a7716bda26c61738e624214efa149e83e" name="a7716bda26c61738e624214efa149e83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7716bda26c61738e624214efa149e83e">&#9670;&#160;</a></span>isIndexedLoadLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isIndexedLoadLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">MemIndexedMode</a></td>          <td class="paramname"><span class="paramname"><em>Mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the specified indexed load for the given type is legal. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00895">895</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l03545">mayUsePostIncMode()</a>.</p>

</div>
</div>
<a id="a5a768ef7bcf1b5059f409327c1f83591" name="a5a768ef7bcf1b5059f409327c1f83591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a768ef7bcf1b5059f409327c1f83591">&#9670;&#160;</a></span>isIndexedStoreLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isIndexedStoreLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">MemIndexedMode</a></td>          <td class="paramname"><span class="paramname"><em>Mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the specified indexed store for the given type is legal. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00900">900</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l03545">mayUsePostIncMode()</a>.</p>

</div>
</div>
<a id="a7f5c32f4b5bd13b1279016cd9a6db37b" name="a7f5c32f4b5bd13b1279016cd9a6db37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5c32f4b5bd13b1279016cd9a6db37b">&#9670;&#160;</a></span>isLegalAddImmediate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalAddImmediate </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Imm</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified immediate is legal add immediate, that is the target has add instructions which can add a register with the immediate without having to materialize the immediate into a register. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00335">335</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a5c84ca19e254840865cd33cc5aaedb81" name="a5c84ca19e254840865cd33cc5aaedb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c84ca19e254840865cd33cc5aaedb81">&#9670;&#160;</a></span>isLegalAddressingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalAddressingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *</td>          <td class="paramname"><span class="paramname"><em>BaseGV</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>BaseOffset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>HasBaseReg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Scale</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the addressing mode represented by AM is legal for this target, for a load/store of the specified type. </p>
<p>The type may be VoidTy, in which case only return true if the addressing mode is legal for a load/store of any legal type. If target returns true in <a class="el" href="#a4746d964f754f53ce75d48a418196674" title="Return true if the loop strength reduce pass should make Instruction* based TTI queries to isLegalAdd...">LSRWithInstrQueries()</a>, I may be valid. TODO: Handle pre/postinc as well. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00343">343</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="StraightLineStrengthReduce_8cpp_source.html#l00283">isAddFoldable()</a>, and <a class="el" href="LoopStrengthReduce_8cpp_source.html#l01619">isAMCompletelyFolded()</a>.</p>

</div>
</div>
<a id="a78ff38d597ee5f9da28bb64c812520d8" name="a78ff38d597ee5f9da28bb64c812520d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ff38d597ee5f9da28bb64c812520d8">&#9670;&#160;</a></span>isLegalICmpImmediate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalICmpImmediate </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Imm</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified immediate is legal icmp immediate, that is the target has icmp instructions which can compare a register against the immediate without having to materialize the immediate into a register. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00339">339</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l01619">isAMCompletelyFolded()</a>.</p>

</div>
</div>
<a id="a78f71d89b22106738d72d963725f0860" name="a78f71d89b22106738d72d963725f0860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f71d89b22106738d72d963725f0860">&#9670;&#160;</a></span>isLegalMaskedCompressStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedCompressStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked compress store. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00408">408</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="aa143359355225ce76a666b1758bb2d3d" name="aa143359355225ce76a666b1758bb2d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa143359355225ce76a666b1758bb2d3d">&#9670;&#160;</a></span>isLegalMaskedExpandLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedExpandLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked expand load. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00412">412</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a33ac7704be5bd5455f78caf0b5371012" name="a33ac7704be5bd5455f78caf0b5371012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ac7704be5bd5455f78caf0b5371012">&#9670;&#160;</a></span>isLegalMaskedGather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedGather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked gather. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00398">398</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l01228">llvm::LoopVectorizationCostModel::isLegalMaskedGather()</a>.</p>

</div>
</div>
<a id="aff5a70644f05b7731348861016ff2af1" name="aff5a70644f05b7731348861016ff2af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5a70644f05b7731348861016ff2af1">&#9670;&#160;</a></span>isLegalMaskedLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked load. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00384">384</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l04684">llvm::LoopVectorizationCostModel::interleavedAccessCanBeWidened()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l01215">llvm::LoopVectorizationCostModel::isLegalMaskedLoad()</a>.</p>

</div>
</div>
<a id="a0a973aabc3b5429e5e05beee35892de0" name="a0a973aabc3b5429e5e05beee35892de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a973aabc3b5429e5e05beee35892de0">&#9670;&#160;</a></span>isLegalMaskedScatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedScatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked scatter. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00403">403</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l01222">llvm::LoopVectorizationCostModel::isLegalMaskedScatter()</a>.</p>

</div>
</div>
<a id="ab9bcc7733985bba3ab58e5c2abbc129e" name="ab9bcc7733985bba3ab58e5c2abbc129e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bcc7733985bba3ab58e5c2abbc129e">&#9670;&#160;</a></span>isLegalMaskedStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked store. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00379">379</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l04684">llvm::LoopVectorizationCostModel::interleavedAccessCanBeWidened()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l01208">llvm::LoopVectorizationCostModel::isLegalMaskedStore()</a>.</p>

</div>
</div>
<a id="a7bdad414050f44dd51fe2c193b7992b6" name="a7bdad414050f44dd51fe2c193b7992b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bdad414050f44dd51fe2c193b7992b6">&#9670;&#160;</a></span>isLegalNTLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalNTLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports nontemporal load. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00394">394</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a923b761c973df44658c12ab18b29365c" name="a923b761c973df44658c12ab18b29365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923b761c973df44658c12ab18b29365c">&#9670;&#160;</a></span>isLegalNTStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalNTStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports nontemporal store. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00389">389</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a03aaf2f1c4d2a4bb801bc9aeea94de3c" name="a03aaf2f1c4d2a4bb801bc9aeea94de3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03aaf2f1c4d2a4bb801bc9aeea94de3c">&#9670;&#160;</a></span>isLegalToVectorizeLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalToVectorizeLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> *</td>          <td class="paramname"><span class="paramname"><em>LI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the load instruction is legal to vectorize. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00909">909</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="aaaa75efd79296070e4c5f24fa3ea6f01" name="aaaa75efd79296070e4c5f24fa3ea6f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa75efd79296070e4c5f24fa3ea6f01">&#9670;&#160;</a></span>isLegalToVectorizeLoadChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalToVectorizeLoadChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ChainSizeInBytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if it is legal to vectorize the given load chain. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00917">917</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a0de4290b00b162ec20705cad42047b64" name="a0de4290b00b162ec20705cad42047b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de4290b00b162ec20705cad42047b64">&#9670;&#160;</a></span>isLegalToVectorizeStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalToVectorizeStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StoreInst.html">StoreInst</a> *</td>          <td class="paramname"><span class="paramname"><em>SI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the store instruction is legal to vectorize. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00913">913</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SIInstrInfo_8cpp_source.html#l06827">SI</a>.</p>

</div>
</div>
<a id="a58b0dcd9d3ef39aa308b7d7371e5da88" name="a58b0dcd9d3ef39aa308b7d7371e5da88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b0dcd9d3ef39aa308b7d7371e5da88">&#9670;&#160;</a></span>isLegalToVectorizeStoreChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalToVectorizeStoreChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ChainSizeInBytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if it is legal to vectorize the given store chain. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00923">923</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="aa8b08fb48c8c58e63aa231a1099475d9" name="aa8b08fb48c8c58e63aa231a1099475d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b08fb48c8c58e63aa231a1099475d9">&#9670;&#160;</a></span>isLoweredToCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLoweredToCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>F</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether calls to a function lower to actual program function calls. </p>
<p>The idea is to test whether the program is likely to require a 'call' instruction or equivalent in order to call the given function.</p>
<p>FIXME: It's not clear that this is a good or useful query API. Client's should probably move to simpler cost metrics using the above. Alternatively, we could split the cost interface into distinct code-size and execution-speed costs. This would allow modelling the core of this query more accurately as a call is a single small instruction, but incurs significant execution cost. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00304">304</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00056">F</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeMetrics_8cpp_source.html#l00115">llvm::CodeMetrics::analyzeBasicBlock()</a>, <a class="el" href="LoopUnrollPass_8cpp_source.html#l00373">analyzeLoopUnrollCost()</a>, and <a class="el" href="CGProfile_8cpp_source.html#l00049">runCGProfilePass()</a>.</p>

</div>
</div>
<a id="a90d868fd1e5fa04b220b13bb42d0b90e" name="a90d868fd1e5fa04b220b13bb42d0b90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d868fd1e5fa04b220b13bb42d0b90e">&#9670;&#160;</a></span>isLSRCostLess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLSRCostLess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1LSRCost.html">TargetTransformInfo::LSRCost</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1LSRCost.html">TargetTransformInfo::LSRCost</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if LSR cost of C1 is lower than C1. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00352">352</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a50c845c07da9fd93a05ec29509486166" name="a50c845c07da9fd93a05ec29509486166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c845c07da9fd93a05ec29509486166">&#9670;&#160;</a></span>isNoopAddrSpaceCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isNoopAddrSpaceCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>FromAS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ToAS</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00294">294</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a2c5b11c76ffc12a4dde038d77dc4d5ae" name="a2c5b11c76ffc12a4dde038d77dc4d5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5b11c76ffc12a4dde038d77dc4d5ae">&#9670;&#160;</a></span>isProfitableLSRChainElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isProfitableLSRChainElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if LSR should not optimize a chain that includes <code>I</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00356">356</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l02825">isProfitableChain()</a>.</p>

</div>
</div>
<a id="aafcbf4e3010950dd8ea0be1c4b0d3281" name="aafcbf4e3010950dd8ea0be1c4b0d3281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcbf4e3010950dd8ea0be1c4b0d3281">&#9670;&#160;</a></span>isProfitableToHoist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isProfitableToHoist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if it is profitable to hoist instruction in the then/else to before if. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00447">447</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

</div>
</div>
<a id="a787ddce53dcb1b93b5c173dbbba4d3f0" name="a787ddce53dcb1b93b5c173dbbba4d3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787ddce53dcb1b93b5c173dbbba4d3f0">&#9670;&#160;</a></span>isSourceOfDivergence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isSourceOfDivergence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether V is a source of divergence. </p>
<p>This function provides the target-dependent information for the target-independent <a class="el" href="classllvm_1_1LegacyDivergenceAnalysis.html">LegacyDivergenceAnalysis</a>. <a class="el" href="classllvm_1_1LegacyDivergenceAnalysis.html">LegacyDivergenceAnalysis</a> first builds the dependency graph, and then runs the reachability algorithm starting with the sources of divergence. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00277">277</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DivergenceAnalysis_8cpp_source.html#l00442">llvm::GPUDivergenceAnalysis::GPUDivergenceAnalysis()</a>.</p>

</div>
</div>
<a id="ae3e55cf13c60a8b90145f1411367b975" name="ae3e55cf13c60a8b90145f1411367b975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e55cf13c60a8b90145f1411367b975">&#9670;&#160;</a></span>isTruncateFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isTruncateFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if it's free to truncate a value of type Ty1 to type Ty2. </p>
<p>e.g. On x86 it's free to truncate a i32 value in register EAX to i16 by referencing its sub-register AX. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00443">443</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l01167">llvm::LoopVectorizationCostModel::isOptimizableIVTruncate()</a>, and <a class="el" href="ScalarEvolutionExpander_8cpp_source.html#l01960">llvm::SCEVExpander::replaceCongruentIVs()</a>.</p>

</div>
</div>
<a id="a7a84209b8495d8fd3d2799eb01f1ab2b" name="a7a84209b8495d8fd3d2799eb01f1ab2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a84209b8495d8fd3d2799eb01f1ab2b">&#9670;&#160;</a></span>isTypeLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isTypeLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this type is legal. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00453">453</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUtils_8cpp_source.html#l00478">llvm::computeMinimumValueSizes()</a>, <a class="el" href="SLPVectorizer_8cpp_source.html#l03685">isLoadCombineCandidateImpl()</a>, and <a class="el" href="SimplifyCFG_8cpp_source.html#l05278">ShouldBuildLookupTable()</a>.</p>

</div>
</div>
<a id="a4746d964f754f53ce75d48a418196674" name="a4746d964f754f53ce75d48a418196674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4746d964f754f53ce75d48a418196674">&#9670;&#160;</a></span>LSRWithInstrQueries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::LSRWithInstrQueries </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the loop strength reduce pass should make Instruction* based TTI queries to <a class="el" href="#a5c84ca19e254840865cd33cc5aaedb81" title="Return true if the addressing mode represented by AM is legal for this target, for a load/store of th...">isLegalAddressingMode()</a>. </p>
<p>This is needed on <a class="el" href="namespacellvm_1_1SystemZ.html">SystemZ</a>, where e.g. a memcpy can only have a 12 bit unsigned immediate offset and no index register. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00439">439</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l01732">isAMCompletelyFolded()</a>.</p>

</div>
</div>
<a id="a9d7b3a4d1ce161b7ec5d97ac690cd5b7" name="a9d7b3a4d1ce161b7ec5d97ac690cd5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7b3a4d1ce161b7ec5d97ac690cd5b7">&#9670;&#160;</a></span>matchPairwiseReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2be22489ac8251d2241bd4ed1633c8a9">TTI::ReductionKind</a> TTI::matchPairwiseReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ExtractElementInst.html">ExtractElementInst</a> *</td>          <td class="paramname"><span class="paramname"><em>ReduxRoot</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01088">1088</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetTransformInfo_8cpp.html#a94d88608903a1c51834a383c0af6b862">EnableReduxCost</a>, <a class="el" href="TargetTransformInfo_8cpp_source.html#l00980">getReductionData()</a>, <a class="el" href="Constants_8h_source.html#l00142">llvm::ConstantInt::getZExtValue()</a>, <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00341">Idx</a>, <a class="el" href="MathExtras_8h_source.html#l00492">llvm::isPowerOf2_32()</a>, <a class="el" href="MathExtras_8h_source.html#l00597">llvm::Log2_32()</a>, <a class="el" href="TargetTransformInfo_8cpp_source.html#l01003">matchPairwiseReductionAtLevel()</a>, and <a class="el" href="TargetTransformInfo_8h_source.html#l00820">RK_None</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetTransformInfoImpl_8h_source.html#l00800">llvm::TargetTransformInfoImplCRTPBase&lt; T &gt;::getUserCost()</a>.</p>

</div>
</div>
<a id="a0cf9887087e88a3b6af81593e2630550" name="a0cf9887087e88a3b6af81593e2630550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf9887087e88a3b6af81593e2630550">&#9670;&#160;</a></span>matchVectorSplittingReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2be22489ac8251d2241bd4ed1633c8a9">TTI::ReductionKind</a> TTI::matchVectorSplittingReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ExtractElementInst.html">ExtractElementInst</a> *</td>          <td class="paramname"><span class="paramname"><em>ReduxRoot</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01152">1152</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetTransformInfo_8cpp.html#a94d88608903a1c51834a383c0af6b862">EnableReduxCost</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="TargetTransformInfo_8cpp_source.html#l00980">getReductionData()</a>, <a class="el" href="TargetTransformInfo_8cpp_source.html#l01142">getShuffleAndOtherOprd()</a>, <a class="el" href="Instructions_8cpp_source.html#l01999">llvm::ShuffleVectorInst::getShuffleMask()</a>, <a class="el" href="Constants_8h_source.html#l00142">llvm::ConstantInt::getZExtValue()</a>, <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00341">Idx</a>, <a class="el" href="MathExtras_8h_source.html#l00492">llvm::isPowerOf2_32()</a>, and <a class="el" href="TargetTransformInfo_8h_source.html#l00820">RK_None</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetTransformInfoImpl_8h_source.html#l00800">llvm::TargetTransformInfoImplCRTPBase&lt; T &gt;::getUserCost()</a>.</p>

</div>
</div>
<a id="a6d955ca0eda3479b562ccc505575049b" name="a6d955ca0eda3479b562ccc505575049b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d955ca0eda3479b562ccc505575049b">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp; TargetTransformInfo::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00235">235</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a7384797683527a3c112a0bc709d5c659" name="a7384797683527a3c112a0bc709d5c659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7384797683527a3c112a0bc709d5c659">&#9670;&#160;</a></span>preferPredicateOverEpilogue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::preferPredicateOverEpilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Loop.html">Loop</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>LI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SE</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>AC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TLI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *</td>          <td class="paramname"><span class="paramname"><em>DT</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LoopAccessInfo.html">LoopAccessInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>LAI</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target whether it would be prefered to create a predicated vector loop, which can avoid the need to emit a scalar epilogue loop. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00314">314</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l07615">getScalarEpilogueLowering()</a>.</p>

</div>
</div>
<a id="a215ea3605f88c5b21ffbdf76a72a8554" name="a215ea3605f88c5b21ffbdf76a72a8554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215ea3605f88c5b21ffbdf76a72a8554">&#9670;&#160;</a></span>prefersVectorizedAddressing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::prefersVectorizedAddressing </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if target doesn't mind addresses in vectors. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00425">425</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l06067">llvm::LoopVectorizationCostModel::setCostBasedWideningDecision()</a>.</p>

</div>
</div>
<a id="a88bd45e10d1f1069da1b4d216d0f5f73" name="a88bd45e10d1f1069da1b4d216d0f5f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bd45e10d1f1069da1b4d216d0f5f73">&#9670;&#160;</a></span>rewriteIntrinsicWithAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Value.html">Value</a> * TargetTransformInfo::rewriteIntrinsicWithAddressSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *</td>          <td class="paramname"><span class="paramname"><em>II</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>OldV</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>NewV</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite intrinsic call <code>II</code> such that <code>OldV</code> will be replaced with <code>NewV</code>, which has a different address space. </p>
<p>This should happen for every operand index that collectFlatAddressOperands returned for the intrinsic. </p><dl class="section return"><dt>Returns</dt><dd>nullptr if the intrinsic was not handled. Otherwise, returns the new value (which may be the original <code>II</code> with modified operands). </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00299">299</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a0d5b47e1f017620a784b726852915d58" name="a0d5b47e1f017620a784b726852915d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5b47e1f017620a784b726852915d58">&#9670;&#160;</a></span>shouldBuildLookupTables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldBuildLookupTables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if switches should be turned into lookup tables for the target. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00457">457</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SimplifyCFG_8cpp_source.html#l05404">SwitchToLookupTable()</a>.</p>

</div>
</div>
<a id="a265e334c170d96e5cbcf8b420db520d4" name="a265e334c170d96e5cbcf8b420db520d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265e334c170d96e5cbcf8b420db520d4">&#9670;&#160;</a></span>shouldBuildLookupTablesForConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldBuildLookupTablesForConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Constant.html">Constant</a> *</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if switches should be turned into lookup tables containing this constant value for the target. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00460">460</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>.</p>

<p class="reference">Referenced by <a class="el" href="SimplifyCFG_8cpp_source.html#l04718">ValidLookupTableConstant()</a>.</p>

</div>
</div>
<a id="a9880b7512930d879440db073b536d362" name="a9880b7512930d879440db073b536d362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9880b7512930d879440db073b536d362">&#9670;&#160;</a></span>shouldConsiderAddressTypePromotion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldConsiderAddressTypePromotion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>AllowPromotionWithoutCommonHeader</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if it should be considered for address type promotion. <code>AllowPromotionWithoutCommonHeader</code> Set true if promoting <code>I</code> is profitable without finding other extensions fed by the same input. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00597">597</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00059">I</a>.</p>

</div>
</div>
<a id="aefeefc63fa057f5050b78547c6cdf0e1" name="aefeefc63fa057f5050b78547c6cdf0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefeefc63fa057f5050b78547c6cdf0e1">&#9670;&#160;</a></span>shouldExpandReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldExpandReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *</td>          <td class="paramname"><span class="paramname"><em>II</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the target wants to expand the given reduction intrinsic into a shuffle sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00948">948</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a44209c5b1486b375c5d2ee304fc2b535" name="a44209c5b1486b375c5d2ee304fc2b535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44209c5b1486b375c5d2ee304fc2b535">&#9670;&#160;</a></span>shouldFavorBackedgeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldFavorBackedgeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Loop.html">Loop</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if LSR should make efforts to generate indexed addressing modes that operate across loop iterations. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00375">375</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a5d223e0e64b5c839d91db0ca11bc4390" name="a5d223e0e64b5c839d91db0ca11bc4390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d223e0e64b5c839d91db0ca11bc4390">&#9670;&#160;</a></span>shouldFavorPostInc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldFavorPostInc </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True is LSR should make efforts to create/preserve post-inc addressing mode expressions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00371">371</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a6631468caf2fe616dcd85f80f5a51801" name="a6631468caf2fe616dcd85f80f5a51801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6631468caf2fe616dcd85f80f5a51801">&#9670;&#160;</a></span>shouldMaximizeVectorBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldMaximizeVectorBandwidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>OptSize</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the vectorization factor should be chosen to make the vector of the smallest element type match the size of a vector register. For wider element types, this could result in creating vectors that span multiple vector registers. If false, the vectorization factor will be chosen based on the size of the widest element type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00589">589</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a1af0805a1dd7afabb0aa6cc1832b5011" name="a1af0805a1dd7afabb0aa6cc1832b5011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af0805a1dd7afabb0aa6cc1832b5011">&#9670;&#160;</a></span>supportsEfficientVectorElementLoadStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::supportsEfficientVectorElementLoadStore </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If target has efficient vector element load/store instructions, it can return true here so that insertion/extraction costs are not added to the scalarization cost of a load/store. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00481">481</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a98deb6721fb0ac45c41f71b800700596" name="a98deb6721fb0ac45c41f71b800700596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98deb6721fb0ac45c41f71b800700596">&#9670;&#160;</a></span>useAA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::useAA </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00451">451</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ad30e432e7796aa46c87440cb54de2243" name="ad30e432e7796aa46c87440cb54de2243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30e432e7796aa46c87440cb54de2243">&#9670;&#160;</a></span>useColdCCForColdCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::useColdCCForColdCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>F</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the input function which is cold at all call sites, should use coldcc calling convention. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00465">465</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00056">F</a>.</p>

<p class="reference">Referenced by <a class="el" href="GlobalOpt_8cpp_source.html#l02380">OptimizeFunctions()</a>.</p>

</div>
</div>
<a id="aaf36efea43204c6a4c9b219c8f9acaf5" name="aaf36efea43204c6a4c9b219c8f9acaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf36efea43204c6a4c9b219c8f9acaf5">&#9670;&#160;</a></span>useGPUDivergenceAnalysis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::useGPUDivergenceAnalysis </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target prefers to use GPU divergence analysis to replace the legacy version. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00273">273</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a196b604c795c4a56383c68a9e343cc3f" name="a196b604c795c4a56383c68a9e343cc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196b604c795c4a56383c68a9e343cc3f">&#9670;&#160;</a></span>useReductionIntrinsic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::useReductionIntrinsic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1ReductionFlags.html">ReductionFlags</a></td>          <td class="paramname"><span class="paramname"><em>Flags</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the target wants to handle the given reduction idiom in the intrinsics form instead of the shuffle form. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00943">943</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00957">llvm::createSimpleTargetReduction()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/llvm/Analysis/<a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a></li>
<li>lib/Analysis/<a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 20 2024 14:03:42 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
