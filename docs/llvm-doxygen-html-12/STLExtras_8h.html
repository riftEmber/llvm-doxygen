<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: include/llvm/ADT/STLExtras.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;12.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_dcde91663b8816e1e2311938ccd8f690.html">llvm</a></li><li class="navelem"><a class="el" href="dir_32453792af2ba70c54e3ccae3a790d1b.html">ADT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">STLExtras.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Optional_8h_source.html">llvm/ADT/Optional.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iterator_8h_source.html">llvm/ADT/iterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iterator__range_8h_source.html">llvm/ADT/iterator_range.h</a>&quot;</code><br />
<code>#include &quot;llvm/Config/abi-breaking.h&quot;</code><br />
<code>#include &quot;<a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html">llvm/Support/ErrorHandling.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;initializer_list&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for STLExtras.h:</div>
<div class="dyncontent">
<div class="center"><img src="STLExtras_8h__incl.png" border="0" usemap="#ainclude_2llvm_2ADT_2STLExtras_8h" alt=""/></div>
<map name="ainclude_2llvm_2ADT_2STLExtras_8h" id="ainclude_2llvm_2ADT_2STLExtras_8h">
<area shape="rect" title=" " alt="" coords="1461,5,1659,31"/>
<area shape="rect" href="Optional_8h.html" title=" " alt="" coords="968,79,1107,105"/>
<area shape="poly" title=" " alt="" coords="1471,34,1122,82,1121,76,1470,29"/>
<area shape="rect" href="llvm_2Support_2ErrorHandling_8h.html" title=" " alt="" coords="91,226,280,252"/>
<area shape="poly" title=" " alt="" coords="1460,23,1186,27,841,37,527,55,415,67,350,81,303,109,262,145,228,183,203,215,199,212,224,180,258,142,300,105,348,77,414,61,527,49,841,32,1186,22,1460,18"/>
<area shape="rect" title=" " alt="" coords="1403,300,1467,326"/>
<area shape="poly" title=" " alt="" coords="1556,33,1514,113,1462,227,1444,287,1439,285,1458,225,1509,111,1551,30"/>
<area shape="rect" title=" " alt="" coords="570,300,630,326"/>
<area shape="poly" title=" " alt="" coords="1460,23,1202,34,1042,46,877,64,719,90,578,125,517,147,466,171,425,198,396,228,391,239,395,250,556,297,555,302,392,254,386,239,391,225,422,194,463,166,515,142,576,120,718,85,877,59,1042,40,1202,28,1460,18"/>
<area shape="rect" title=" " alt="" coords="1124,300,1207,326"/>
<area shape="poly" title=" " alt="" coords="1552,33,1458,132,1387,196,1308,254,1263,279,1218,297,1216,292,1261,274,1305,250,1384,192,1455,128,1548,29"/>
<area shape="rect" title=" " alt="" coords="1575,300,1628,326"/>
<area shape="poly" title=" " alt="" coords="1598,29,1694,63,1815,111,1873,139,1925,167,1967,196,1993,225,1998,240,1993,254,1968,272,1931,286,1885,296,1834,304,1729,312,1642,314,1642,309,1728,307,1833,298,1884,291,1929,281,1965,267,1989,250,1993,240,1988,228,1963,200,1923,172,1871,143,1812,116,1692,68,1597,34"/>
<area shape="rect" title=" " alt="" coords="1472,226,1547,252"/>
<area shape="poly" title=" " alt="" coords="1560,32,1518,213,1513,212,1555,31"/>
<area shape="rect" title=" " alt="" coords="1157,226,1222,252"/>
<area shape="poly" title=" " alt="" coords="1469,34,1405,52,1373,65,1343,81,1315,104,1298,126,1283,151,1259,180,1217,218,1214,215,1255,176,1279,148,1294,123,1311,100,1340,77,1370,60,1403,47,1468,29"/>
<area shape="rect" title=" " alt="" coords="1246,226,1295,252"/>
<area shape="poly" title=" " alt="" coords="1475,34,1419,52,1392,65,1367,81,1331,135,1286,215,1282,212,1327,132,1363,77,1389,60,1417,47,1473,29"/>
<area shape="rect" title=" " alt="" coords="1177,153,1245,178"/>
<area shape="poly" title=" " alt="" coords="1461,34,1347,53,1299,66,1266,81,1239,109,1222,140,1218,138,1235,105,1262,77,1297,61,1346,48,1460,28"/>
<area shape="rect" href="iterator_8h.html" title=" " alt="" coords="1547,153,1677,178"/>
<area shape="poly" title=" " alt="" coords="1567,30,1605,138,1600,139,1562,32"/>
<area shape="rect" href="iterator__range_8h.html" title="This provides a very simple, boring adaptor for a begin and end iterator into a range type." alt="" coords="1723,226,1893,252"/>
<area shape="poly" title=" " alt="" coords="1575,30,1785,214,1782,218,1572,34"/>
<area shape="rect" title=" " alt="" coords="1917,226,1979,252"/>
<area shape="poly" title=" " alt="" coords="1583,29,1916,217,1913,221,1580,34"/>
<area shape="rect" title=" " alt="" coords="1854,79,2026,105"/>
<area shape="poly" title=" " alt="" coords="1625,29,1862,73,1861,78,1624,34"/>
<area shape="rect" title=" " alt="" coords="2050,79,2110,105"/>
<area shape="poly" title=" " alt="" coords="1660,25,1832,44,2036,76,2035,81,1831,49,1659,30"/>
<area shape="rect" title=" " alt="" coords="2133,79,2211,105"/>
<area shape="poly" title=" " alt="" coords="1660,24,1867,43,2119,76,2118,81,1867,48,1659,29"/>
<area shape="rect" title=" " alt="" coords="2235,79,2331,105"/>
<area shape="poly" title=" " alt="" coords="1660,23,1910,42,2064,57,2220,76,2220,81,2063,62,1910,47,1660,28"/>
<area shape="rect" title=" " alt="" coords="2355,79,2408,105"/>
<area shape="poly" title=" " alt="" coords="1660,18,1793,22,1961,31,2149,49,2341,77,2340,82,2149,54,1961,36,1793,27,1660,23"/>
<area shape="rect" href="Hashing_8h.html" title=" " alt="" coords="861,153,1000,178"/>
<area shape="poly" title=" " alt="" coords="1021,107,962,146,959,142,1018,103"/>
<area shape="rect" href="Compiler_8h.html" title=" " alt="" coords="105,300,266,326"/>
<area shape="poly" title=" " alt="" coords="967,100,748,117,466,145,330,163,213,183,126,205,97,216,81,228,75,237,75,246,86,263,108,278,136,292,134,297,106,283,82,266,70,247,70,236,77,225,95,212,124,200,212,177,329,157,465,140,747,112,967,95"/>
<area shape="rect" href="type__traits_8h.html" title=" " alt="" coords="912,226,1083,252"/>
<area shape="poly" title=" " alt="" coords="1037,106,1007,212,1002,211,1031,104"/>
<area shape="poly" title=" " alt="" coords="1055,103,1113,143,1165,176,1339,232,1562,297,1560,303,1338,237,1163,181,1110,148,1052,107"/>
<area shape="poly" title=" " alt="" coords="1050,103,1122,176,1165,215,1162,219,1118,180,1046,107"/>
<area shape="rect" href="None_8h.html" title=" " alt="" coords="646,153,768,178"/>
<area shape="poly" title=" " alt="" coords="981,108,778,152,776,146,980,103"/>
<area shape="poly" title=" " alt="" coords="1068,103,1169,144,1167,149,1066,108"/>
<area shape="rect" title=" " alt="" coords="792,153,837,178"/>
<area shape="poly" title=" " alt="" coords="999,108,852,155,851,150,998,103"/>
<area shape="rect" href="llvm_2Support_2DataTypes_8h.html" title=" " alt="" coords="406,226,578,252"/>
<area shape="poly" title=" " alt="" coords="861,181,582,226,581,221,860,176"/>
<area shape="poly" title=" " alt="" coords="861,180,850,181,574,207,299,229,294,229,294,224,298,224,574,201,849,176,860,174"/>
<area shape="rect" title=" " alt="" coords="289,300,343,326"/>
<area shape="poly" title=" " alt="" coords="861,180,850,181,748,187,618,192,489,204,436,214,395,229,376,241,359,257,332,289,328,286,355,253,372,237,392,224,434,209,488,199,617,187,748,182,849,176,860,174"/>
<area shape="rect" href="SwapByteOrder_8h.html" title=" " alt="" coords="603,226,803,252"/>
<area shape="poly" title=" " alt="" coords="893,181,756,224,754,219,891,176"/>
<area shape="poly" title=" " alt="" coords="944,177,978,214,974,217,940,180"/>
<area shape="poly" title=" " alt="" coords="969,176,1096,224,1121,238,1146,249,1213,261,1329,277,1561,304,1561,310,1329,282,1212,267,1145,255,1118,243,1094,229,967,181"/>
<area shape="poly" title=" " alt="" coords="1001,173,1458,229,1457,234,1000,178"/>
<area shape="poly" title=" " alt="" coords="975,176,1144,222,1142,228,974,181"/>
<area shape="rect" title=" " alt="" coords="827,226,888,252"/>
<area shape="poly" title=" " alt="" coords="920,180,882,218,878,214,917,177"/>
<area shape="poly" title=" " alt="" coords="1001,176,1106,196,1232,224,1231,229,1105,201,1000,181"/>
<area shape="rect" href="llvm-c_2DataTypes_8h.html" title=" " alt="" coords="412,300,546,326"/>
<area shape="poly" title=" " alt="" coords="492,253,486,286,481,285,487,252"/>
<area shape="rect" title=" " alt="" coords="548,374,626,399"/>
<area shape="poly" title=" " alt="" coords="498,324,558,363,555,368,496,328"/>
<area shape="rect" title=" " alt="" coords="345,374,410,399"/>
<area shape="poly" title=" " alt="" coords="463,328,408,367,405,363,460,324"/>
<area shape="rect" title=" " alt="" coords="434,374,523,399"/>
<area shape="poly" title=" " alt="" coords="481,326,481,359,476,359,476,326"/>
<area shape="poly" title=" " alt="" coords="188,252,188,285,183,285,183,252"/>
<area shape="poly" title=" " alt="" coords="209,250,282,290,280,295,206,255"/>
<area shape="rect" title=" " alt="" coords="5,374,171,399"/>
<area shape="poly" title=" " alt="" coords="170,328,117,367,114,363,167,324"/>
<area shape="rect" title=" " alt="" coords="195,374,264,399"/>
<area shape="poly" title=" " alt="" coords="195,324,217,360,212,362,190,327"/>
<area shape="poly" title=" " alt="" coords="804,248,815,249,1389,305,1388,310,814,255,803,254"/>
<area shape="poly" title=" " alt="" coords="687,255,631,294,628,289,684,250"/>
<area shape="poly" title=" " alt="" coords="782,250,1110,300,1109,306,781,255"/>
<area shape="rect" title=" " alt="" coords="654,300,778,326"/>
<area shape="poly" title=" " alt="" coords="707,252,714,285,708,286,702,253"/>
<area shape="poly" title=" " alt="" coords="912,253,900,255,728,269,592,278,456,287,281,302,280,297,455,282,592,273,727,264,900,249,912,248"/>
<area shape="poly" title=" " alt="" coords="1027,250,1125,291,1122,296,1025,255"/>
<area shape="poly" title=" " alt="" coords="1083,248,1561,304,1560,309,1082,253"/>
<area shape="poly" title=" " alt="" coords="1617,179,1618,214,1614,235,1605,254,1578,278,1547,294,1513,305,1482,311,1481,306,1512,300,1545,289,1575,273,1601,250,1609,233,1613,214,1612,179"/>
<area shape="poly" title=" " alt="" coords="1611,180,1593,217,1579,237,1560,254,1533,267,1497,278,1406,294,1307,305,1222,311,1221,306,1306,300,1405,289,1496,273,1531,262,1557,250,1575,234,1589,214,1606,177"/>
<area shape="poly" title=" " alt="" coords="1627,177,1651,210,1658,231,1656,253,1644,274,1629,291,1625,288,1640,271,1651,251,1653,232,1646,212,1622,180"/>
<area shape="poly" title=" " alt="" coords="1596,181,1540,220,1537,215,1593,177"/>
<area shape="poly" title=" " alt="" coords="1646,176,1762,218,1760,223,1644,181"/>
<area shape="poly" title=" " alt="" coords="1678,176,1903,223,1902,228,1677,182"/>
<area shape="poly" title=" " alt="" coords="1774,255,1643,300,1641,295,1772,250"/>
</map>
</div>
</div>
<p><a href="STLExtras_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1negation.html">llvm::negation&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1conjunction.html">llvm::conjunction&lt;... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1conjunction_3_01B1_01_4.html">llvm::conjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1conjunction_3_01B1_00_01Bn_8_8_8_01_4.html">llvm::conjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1make__const__ptr.html">llvm::make_const_ptr&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1make__const__ref.html">llvm::make_const_ref&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1detector.html">llvm::detail::detector&lt; class, Op, Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1detector_3_01void__t_3_01Op_3_01Args_8_8_8_01_4_01_4_00_01Op_00_01Args_8_8_8_01_4.html">llvm::detail::detector&lt; void_t&lt; Op&lt; Args... &gt; &gt;, Op, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1function__traits.html">llvm::function_traits&lt; T, isClass &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides various trait information about a callable object.  <a href="structllvm_1_1function__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01const_00_01false_01_4.html">llvm::function_traits&lt; ReturnType(ClassType::*)(Args...) const, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for class function types.  <a href="structllvm_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01const_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_00_01false_01_4.html">llvm::function_traits&lt; ReturnType(ClassType::*)(Args...), false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for class function types.  <a href="structllvm_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1function__traits_3_01ReturnType_07_5_08_07Args_8_8_8_08_00_01false_01_4.html">llvm::function_traits&lt; ReturnType(*)(Args...), false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for non-class function types.  <a href="structllvm_1_1function__traits_3_01ReturnType_07_5_08_07Args_8_8_8_08_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1function__traits_3_01ReturnType_07_6_08_07Args_8_8_8_08_00_01false_01_4.html">llvm::function_traits&lt; ReturnType(&amp;)(Args...), false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for non-class function type references.  <a href="structllvm_1_1function__traits_3_01ReturnType_07_6_08_07Args_8_8_8_08_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1identity.html">llvm::identity&lt; Ty &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1function__ref_3_01Ret_07Params_8_8_8_08_4.html">llvm::function_ref&lt; Ret(Params...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1mapped__iterator.html">llvm::mapped_iterator&lt; ItTy, FuncTy, FuncReturnTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1has__rbegin__impl.html">llvm::has_rbegin_impl&lt; Ty &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to determine if type T has a member called rbegin().  <a href="classllvm_1_1has__rbegin__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1has__rbegin.html">llvm::has_rbegin&lt; Ty &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to determine if T&amp; or T has a member called rbegin().  <a href="structllvm_1_1has__rbegin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1filter__iterator__base.html">llvm::filter_iterator_base&lt; WrappedIteratorT, PredicateT, IterTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator adaptor that filters the elements of given inner iterators.  <a href="classllvm_1_1filter__iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1filter__iterator__impl.html">llvm::filter_iterator_impl&lt; WrappedIteratorT, PredicateT, IterTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classllvm_1_1filter__iterator__base.html" title="An iterator adaptor that filters the elements of given inner iterators.">filter_iterator_base</a> for forward iteration only.  <a href="classllvm_1_1filter__iterator__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1filter__iterator__impl_3_01WrappedIteratorT_00_01PredicateT_00_01std_1_1bidirectional__iterator__tag_01_4.html">llvm::filter_iterator_impl&lt; WrappedIteratorT, PredicateT, std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classllvm_1_1filter__iterator__base.html" title="An iterator adaptor that filters the elements of given inner iterators.">filter_iterator_base</a> for bidirectional iteration.  <a href="classllvm_1_1filter__iterator__impl_3_01WrappedIteratorT_00_01PredicateT_00_01std_1_1bidirectional__iterator__tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1fwd__or__bidi__tag__impl.html">llvm::detail::fwd_or_bidi_tag_impl&lt; is_bidirectional &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1fwd__or__bidi__tag__impl_3_01true_01_4.html">llvm::detail::fwd_or_bidi_tag_impl&lt; true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1fwd__or__bidi__tag.html">llvm::detail::fwd_or_bidi_tag&lt; IterT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper which sets its type member to forward_iterator_tag if the category of <code>IterT</code> does not derive from bidirectional_iterator_tag, and to bidirectional_iterator_tag otherwise.  <a href="structllvm_1_1detail_1_1fwd__or__bidi__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1early__inc__iterator__impl.html">llvm::early_inc_iterator_impl&lt; WrappedIteratorT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudo-iterator adaptor that is designed to implement "early increment" style loops.  <a href="classllvm_1_1early__inc__iterator__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1ZipTupleType.html">llvm::detail::ZipTupleType&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1zip__common.html">llvm::detail::zip_common&lt; ZipType, Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1zip__first.html">llvm::detail::zip_first&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zip__shortest.html">llvm::detail::zip_shortest&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zippy.html">llvm::detail::zippy&lt; ItType, Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1ZipLongestItemType.html">llvm::detail::ZipLongestItemType&lt; Iter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1ZipLongestTupleType.html">llvm::detail::ZipLongestTupleType&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zip__longest__iterator.html">llvm::detail::zip_longest_iterator&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zip__longest__range.html">llvm::detail::zip_longest_range&lt; Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1concat__iterator.html">llvm::concat_iterator&lt; ValueT, IterTs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator wrapper that concatenates sequences together.  <a href="classllvm_1_1concat__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1concat__range.html">llvm::detail::concat_range&lt; ValueT, RangeTs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to store a sequence of ranges being concatenated and access them.  <a href="classllvm_1_1detail_1_1concat__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1indexed__accessor__iterator.html">llvm::indexed_accessor_iterator&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class used to implement an iterator that contains some base object and an index.  <a href="classllvm_1_1indexed__accessor__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1indexed__accessor__range__base.html">llvm::detail::indexed_accessor_range_base&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class represents the base of a range of indexed_accessor_iterators.  <a href="classllvm_1_1detail_1_1indexed__accessor__range__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1indexed__accessor__range__base_1_1iterator.html">llvm::detail::indexed_accessor_range_base&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;::iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator element of this range.  <a href="classllvm_1_1detail_1_1indexed__accessor__range__base_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1indexed__accessor__range.html">llvm::indexed_accessor_range&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an implementation of a range of indexed_accessor_iterators where the base is not indexable.  <a href="classllvm_1_1indexed__accessor__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1less__first.html">llvm::less_first</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Function.html">Function</a> object to check whether the first component of a std::pair compares less than the first component of another std::pair.  <a href="structllvm_1_1less__first.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1less__second.html">llvm::less_second</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Function.html">Function</a> object to check whether the second component of a std::pair compares less than the second component of another std::pair.  <a href="structllvm_1_1less__second.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1on__first.html">llvm::on_first&lt; FuncTy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Function.html">Function</a> object to apply a binary function to the first component of a std::pair.  <a href="structllvm_1_1on__first.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1rank.html">llvm::rank&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type to build an inheritance chain that makes it easy to rank overload candidates.  <a href="structllvm_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1rank_3_010_01_4.html">llvm::rank&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1is__one__of.html">llvm::is_one_of&lt; T, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits class for checking whether type T is one of any of the given types in the variadic list.  <a href="structllvm_1_1is__one__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1is__one__of_3_01T_00_01U_00_01Ts_8_8_8_01_4.html">llvm::is_one_of&lt; T, U, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1are__base__of.html">llvm::are_base_of&lt; T, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits class for checking whether type T is a base class for all the given types in the variadic list.  <a href="structllvm_1_1are__base__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1are__base__of_3_01T_00_01U_00_01Ts_8_8_8_01_4.html">llvm::are_base_of&lt; T, U, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1FreeDeleter.html">llvm::FreeDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1pair__hash.html">llvm::pair_hash&lt; First, Second &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1deref.html">llvm::deref&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary functor that adapts to any other binary functor after dereferencing operands.  <a href="structllvm_1_1deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1result__pair.html">llvm::detail::result_pair&lt; R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1enumerator__iter.html">llvm::detail::enumerator_iter&lt; R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1enumerator.html">llvm::detail::enumerator&lt; R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacellvm" id="r_namespacellvm"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html">llvm</a></td></tr>
<tr class="memdesc:namespacellvm"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents lattice values for constants. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellvm_1_1detail" id="r_namespacellvm_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html">llvm::detail</a></td></tr>
<tr class="memdesc:namespacellvm_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for detecting if a given trait holds for some set of arguments 'Args'. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellvm_1_1adl__detail" id="r_namespacellvm_1_1adl__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html">llvm::adl_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad80886189e91251b99501b998026d728" id="r_ad80886189e91251b99501b998026d728"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">RangeT</a> &gt; </td></tr>
<tr class="memitem:ad80886189e91251b99501b998026d728"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#ad80886189e91251b99501b998026d728">llvm::detail::IterOfRange</a> = <a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(std::begin(std::declval&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">RangeT</a> &amp;&gt;()))</td></tr>
<tr class="separator:ad80886189e91251b99501b998026d728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5716437bd3aefe36118ac9750d85cd" id="r_a3d5716437bd3aefe36118ac9750d85cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">RangeT</a> &gt; </td></tr>
<tr class="memitem:a3d5716437bd3aefe36118ac9750d85cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a3d5716437bd3aefe36118ac9750d85cd">llvm::detail::ValueOfRange</a></td></tr>
<tr class="separator:a3d5716437bd3aefe36118ac9750d85cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2c64da35049da88556dd4c86760651" id="r_a6a2c64da35049da88556dd4c86760651"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:a6a2c64da35049da88556dd4c86760651"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a6a2c64da35049da88556dd4c86760651">llvm::detail::void_t</a> = <a class="el" href="classvoid.html">void</a></td></tr>
<tr class="separator:a6a2c64da35049da88556dd4c86760651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1ad174f29a434886594433ce8a787f" id="r_abf1ad174f29a434886594433ce8a787f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">template</a>&lt; class... &gt; <a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> Op, class... Args&gt; </td></tr>
<tr class="memitem:abf1ad174f29a434886594433ce8a787f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abf1ad174f29a434886594433ce8a787f">llvm::is_detected</a> = <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="structllvm_1_1detail_1_1detector.html">detail::detector</a>&lt;<a class="el" href="classvoid.html">void</a>, Op, Args...&gt;::value_t</td></tr>
<tr class="separator:abf1ad174f29a434886594433ce8a787f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9554d8196bd8cc444ecc1b2f2cb89a" id="r_a4e9554d8196bd8cc444ecc1b2f2cb89a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Callable , typename... Args&gt; </td></tr>
<tr class="memitem:a4e9554d8196bd8cc444ecc1b2f2cb89a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a4e9554d8196bd8cc444ecc1b2f2cb89a">llvm::detail::is_invocable</a></td></tr>
<tr class="separator:a4e9554d8196bd8cc444ecc1b2f2cb89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2243127157f83ab889e9e3b3bdae43" id="r_aaa2243127157f83ab889e9e3b3bdae43"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Callable , typename... Args&gt; </td></tr>
<tr class="memitem:aaa2243127157f83ab889e9e3b3bdae43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aaa2243127157f83ab889e9e3b3bdae43">llvm::is_invocable</a> = <a class="el" href="namespacellvm.html#abf1ad174f29a434886594433ce8a787f">is_detected</a>&lt;<a class="el" href="namespacellvm_1_1detail.html#a4e9554d8196bd8cc444ecc1b2f2cb89a">detail::is_invocable</a>, Callable, Args...&gt;</td></tr>
<tr class="separator:aaa2243127157f83ab889e9e3b3bdae43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dde99f929971dfc4e50bb63dd7aecb" id="r_a34dde99f929971dfc4e50bb63dd7aecb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classWrappedIteratorT.html">WrappedIteratorT</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classPredicateT.html">PredicateT</a> &gt; </td></tr>
<tr class="memitem:a34dde99f929971dfc4e50bb63dd7aecb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a34dde99f929971dfc4e50bb63dd7aecb">llvm::filter_iterator</a></td></tr>
<tr class="memdesc:a34dde99f929971dfc4e50bb63dd7aecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines filter_iterator to a suitable specialization of <a class="el" href="classllvm_1_1filter__iterator__impl.html" title="Specialization of filter_iterator_base for forward iteration only.">filter_iterator_impl</a>, based on the underlying iterator's category.  <br /></td></tr>
<tr class="separator:a34dde99f929971dfc4e50bb63dd7aecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e33cf574230e331dea3462a0da2817" id="r_a22e33cf574230e331dea3462a0da2817"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ZipType</a> , typename... Iters&gt; </td></tr>
<tr class="memitem:a22e33cf574230e331dea3462a0da2817"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a22e33cf574230e331dea3462a0da2817">llvm::detail::zip_traits</a></td></tr>
<tr class="separator:a22e33cf574230e331dea3462a0da2817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad650db3d4b46b28266b843474d80730f" id="r_ad650db3d4b46b28266b843474d80730f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:ad650db3d4b46b28266b843474d80730f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#ad650db3d4b46b28266b843474d80730f">llvm::detail::sort_trivially_copyable</a></td></tr>
<tr class="separator:ad650db3d4b46b28266b843474d80730f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5f3e5084005cf0e5014e0ca7504ce399" id="r_a5f3e5084005cf0e5014e0ca7504ce399"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:a5f3e5084005cf0e5014e0ca7504ce399"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(<a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html#a5f3e5084005cf0e5014e0ca7504ce399">llvm::adl_detail::adl_begin</a> (ContainerTy &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">container</a>)</td></tr>
<tr class="separator:a5f3e5084005cf0e5014e0ca7504ce399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3969ddf16bfd23b6be1a0662cd383a5" id="r_af3969ddf16bfd23b6be1a0662cd383a5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:af3969ddf16bfd23b6be1a0662cd383a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(<a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html#af3969ddf16bfd23b6be1a0662cd383a5">llvm::adl_detail::adl_end</a> (ContainerTy &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">container</a>)</td></tr>
<tr class="separator:af3969ddf16bfd23b6be1a0662cd383a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36acc760326b76ec4fd78ea77c0d73aa" id="r_a36acc760326b76ec4fd78ea77c0d73aa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a36acc760326b76ec4fd78ea77c0d73aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html#a36acc760326b76ec4fd78ea77c0d73aa">llvm::adl_detail::adl_swap</a> (<a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">lhs</a>, <a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">rhs</a>) <a class="el" href="classllvm_1_1ilist__node__impl.html">noexcept</a>(<a class="el" href="classllvm_1_1ilist__node__impl.html">noexcept</a>(swap(std::declval&lt; <a class="el" href="classT.html">T</a> &gt;(), std::declval&lt; <a class="el" href="classT.html">T</a> &gt;())))</td></tr>
<tr class="separator:a36acc760326b76ec4fd78ea77c0d73aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c992e206fc7bcb9be2d30be1381dc1" id="r_a58c992e206fc7bcb9be2d30be1381dc1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:a58c992e206fc7bcb9be2d30be1381dc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(<a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a58c992e206fc7bcb9be2d30be1381dc1">llvm::adl_begin</a> (ContainerTy &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">container</a>)</td></tr>
<tr class="separator:a58c992e206fc7bcb9be2d30be1381dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61654c6c0f8b807e684fc0cea37c05f" id="r_ab61654c6c0f8b807e684fc0cea37c05f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:ab61654c6c0f8b807e684fc0cea37c05f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(<a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ab61654c6c0f8b807e684fc0cea37c05f">llvm::adl_end</a> (ContainerTy &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">container</a>)</td></tr>
<tr class="separator:ab61654c6c0f8b807e684fc0cea37c05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87387cf1d55dabf01ef630a5a90c6859" id="r_a87387cf1d55dabf01ef630a5a90c6859"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a87387cf1d55dabf01ef630a5a90c6859"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a87387cf1d55dabf01ef630a5a90c6859">llvm::adl_swap</a> (<a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">lhs</a>, <a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">rhs</a>) <a class="el" href="classllvm_1_1ilist__node__impl.html">noexcept</a>(<a class="el" href="classllvm_1_1ilist__node__impl.html">noexcept</a>(adl_detail::adl_swap(std::declval&lt; <a class="el" href="classT.html">T</a> &gt;(), std::declval&lt; <a class="el" href="classT.html">T</a> &gt;())))</td></tr>
<tr class="separator:a87387cf1d55dabf01ef630a5a90c6859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824f3e0d9eb261d9345fcc96b36852f5" id="r_a824f3e0d9eb261d9345fcc96b36852f5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a824f3e0d9eb261d9345fcc96b36852f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">constexpr</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a824f3e0d9eb261d9345fcc96b36852f5">llvm::empty</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classT.html">T</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">RangeOrContainer</a>)</td></tr>
<tr class="memdesc:a824f3e0d9eb261d9345fcc96b36852f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether <code>RangeOrContainer</code> is empty. Similar to C++17 std::empty.  <br /></td></tr>
<tr class="separator:a824f3e0d9eb261d9345fcc96b36852f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88027543aef5a9bc0d82bc5e5e3506c3" id="r_a88027543aef5a9bc0d82bc5e5e3506c3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:a88027543aef5a9bc0d82bc5e5e3506c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a88027543aef5a9bc0d82bc5e5e3506c3">llvm::hasSingleElement</a> (ContainerTy &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>)</td></tr>
<tr class="memdesc:a88027543aef5a9bc0d82bc5e5e3506c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given container only contains a single element.  <br /></td></tr>
<tr class="separator:a88027543aef5a9bc0d82bc5e5e3506c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02981de53fb6ffd384d39addc4d25f37" id="r_a02981de53fb6ffd384d39addc4d25f37"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a02981de53fb6ffd384d39addc4d25f37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a02981de53fb6ffd384d39addc4d25f37">llvm::drop_begin</a> (<a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">RangeOrContainer</a>, <a class="el" href="classsize__t.html">size_t</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>=1)</td></tr>
<tr class="memdesc:a02981de53fb6ffd384d39addc4d25f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range covering <code>RangeOrContainer</code> with the first N elements excluded.  <br /></td></tr>
<tr class="separator:a02981de53fb6ffd384d39addc4d25f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f31bfe9e8b65522b0be4bdcec96e83" id="r_a36f31bfe9e8b65522b0be4bdcec96e83"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> <a class="el" href="classItTy.html">ItTy</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> FuncTy &gt; </td></tr>
<tr class="memitem:a36f31bfe9e8b65522b0be4bdcec96e83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1mapped__iterator.html">mapped_iterator</a>&lt; <a class="el" href="classItTy.html">ItTy</a>, FuncTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a36f31bfe9e8b65522b0be4bdcec96e83">llvm::map_iterator</a> (<a class="el" href="classItTy.html">ItTy</a> <a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, FuncTy <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="separator:a36f31bfe9e8b65522b0be4bdcec96e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c7cbd21e1104ee6841c18d7daa6edb" id="r_a51c7cbd21e1104ee6841c18d7daa6edb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> ContainerTy , <a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> FuncTy &gt; </td></tr>
<tr class="memitem:a51c7cbd21e1104ee6841c18d7daa6edb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a51c7cbd21e1104ee6841c18d7daa6edb">llvm::map_range</a> (ContainerTy &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, FuncTy <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="separator:a51c7cbd21e1104ee6841c18d7daa6edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469101ea87b8b432a1b4f7935c97f35c" id="r_a469101ea87b8b432a1b4f7935c97f35c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:a469101ea87b8b432a1b4f7935c97f35c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a469101ea87b8b432a1b4f7935c97f35c">llvm::reverse</a> (ContainerTy &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, std::enable_if_t&lt; <a class="el" href="structllvm_1_1has__rbegin.html">has_rbegin</a>&lt; ContainerTy &gt;::value &gt; *=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>)</td></tr>
<tr class="separator:a469101ea87b8b432a1b4f7935c97f35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85eb4332c3a6c2343040656a4f32df05" id="r_a85eb4332c3a6c2343040656a4f32df05"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> &gt; </td></tr>
<tr class="memitem:a85eb4332c3a6c2343040656a4f32df05"><td class="memTemplItemLeft" align="right" valign="top">std::reverse_iterator&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a85eb4332c3a6c2343040656a4f32df05">llvm::make_reverse_iterator</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> It)</td></tr>
<tr class="separator:a85eb4332c3a6c2343040656a4f32df05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a590f10322ff960d0dcaccc0e953286" id="r_a4a590f10322ff960d0dcaccc0e953286"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:a4a590f10322ff960d0dcaccc0e953286"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a4a590f10322ff960d0dcaccc0e953286">llvm::reverse</a> (ContainerTy &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, std::enable_if_t&lt;!<a class="el" href="structllvm_1_1has__rbegin.html">has_rbegin</a>&lt; ContainerTy &gt;::value &gt; *=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>)</td></tr>
<tr class="separator:a4a590f10322ff960d0dcaccc0e953286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898e9304cf2baf908f4e9b8e32a5f6c3" id="r_a898e9304cf2baf908f4e9b8e32a5f6c3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">RangeT</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classPredicateT.html">PredicateT</a> &gt; </td></tr>
<tr class="memitem:a898e9304cf2baf908f4e9b8e32a5f6c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="namespacellvm.html#a34dde99f929971dfc4e50bb63dd7aecb">filter_iterator</a>&lt; <a class="el" href="namespacellvm_1_1detail.html#ad80886189e91251b99501b998026d728">detail::IterOfRange</a>&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">RangeT</a> &gt;, <a class="el" href="classPredicateT.html">PredicateT</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a898e9304cf2baf908f4e9b8e32a5f6c3">llvm::make_filter_range</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">RangeT</a> &amp;&amp;Range, <a class="el" href="classPredicateT.html">PredicateT</a> Pred)</td></tr>
<tr class="memdesc:a898e9304cf2baf908f4e9b8e32a5f6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that takes a range of elements and a predicate, and return a new filter_iterator range.  <br /></td></tr>
<tr class="separator:a898e9304cf2baf908f4e9b8e32a5f6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2cdc4a0db233678e7141c9d6ea3419" id="r_a3d2cdc4a0db233678e7141c9d6ea3419"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">RangeT</a> &gt; </td></tr>
<tr class="memitem:a3d2cdc4a0db233678e7141c9d6ea3419"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classllvm_1_1early__inc__iterator__impl.html">early_inc_iterator_impl</a>&lt; <a class="el" href="namespacellvm_1_1detail.html#ad80886189e91251b99501b998026d728">detail::IterOfRange</a>&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">RangeT</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a3d2cdc4a0db233678e7141c9d6ea3419">llvm::make_early_inc_range</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">RangeT</a> &amp;&amp;Range)</td></tr>
<tr class="memdesc:a3d2cdc4a0db233678e7141c9d6ea3419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a range that does early increment to allow mutation of the underlying range without disrupting iteration.  <br /></td></tr>
<tr class="separator:a3d2cdc4a0db233678e7141c9d6ea3419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d10fe510ced2849a8074fe81e5d04ce" id="r_a0d10fe510ced2849a8074fe81e5d04ce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> UnaryPredicate &gt; </td></tr>
<tr class="memitem:a0d10fe510ced2849a8074fe81e5d04ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0d10fe510ced2849a8074fe81e5d04ce">llvm::all_of</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:a0d10fe510ced2849a8074fe81e5d04ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::all_of which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:a0d10fe510ced2849a8074fe81e5d04ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d13d6824ec46c31260a4fd0997eda0" id="r_a61d13d6824ec46c31260a4fd0997eda0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> UnaryPredicate &gt; </td></tr>
<tr class="memitem:a61d13d6824ec46c31260a4fd0997eda0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a61d13d6824ec46c31260a4fd0997eda0">llvm::any_of</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:a61d13d6824ec46c31260a4fd0997eda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::any_of which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:a61d13d6824ec46c31260a4fd0997eda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34f572d891c9b45fbe921e5782c5e30" id="r_aa34f572d891c9b45fbe921e5782c5e30"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> U , typename... Args&gt; </td></tr>
<tr class="memitem:aa34f572d891c9b45fbe921e5782c5e30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1detail_1_1zippy.html">detail::zippy</a>&lt; <a class="el" href="classllvm_1_1detail_1_1zip__shortest.html">detail::zip_shortest</a>, <a class="el" href="classT.html">T</a>, U, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa34f572d891c9b45fbe921e5782c5e30">llvm::zip</a> (<a class="el" href="classT.html">T</a> &amp;&amp;t, U &amp;&amp;u, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa34f572d891c9b45fbe921e5782c5e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">zip iterator for two or more iteratable types.  <br /></td></tr>
<tr class="separator:aa34f572d891c9b45fbe921e5782c5e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b2b4d5c501508bb5b5d4766f0f779e" id="r_ae6b2b4d5c501508bb5b5d4766f0f779e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> U , typename... Args&gt; </td></tr>
<tr class="memitem:ae6b2b4d5c501508bb5b5d4766f0f779e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1detail_1_1zippy.html">detail::zippy</a>&lt; <a class="el" href="structllvm_1_1detail_1_1zip__first.html">detail::zip_first</a>, <a class="el" href="classT.html">T</a>, U, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae6b2b4d5c501508bb5b5d4766f0f779e">llvm::zip_first</a> (<a class="el" href="classT.html">T</a> &amp;&amp;t, U &amp;&amp;u, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae6b2b4d5c501508bb5b5d4766f0f779e"><td class="mdescLeft">&#160;</td><td class="mdescRight">zip iterator that, for the sake of efficiency, assumes the first iteratee to be the shortest.  <br /></td></tr>
<tr class="separator:ae6b2b4d5c501508bb5b5d4766f0f779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999d703cc02d4b597056c3d718c9ed7b" id="r_a999d703cc02d4b597056c3d718c9ed7b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Iter &gt; </td></tr>
<tr class="memitem:a999d703cc02d4b597056c3d718c9ed7b"><td class="memTemplItemLeft" align="right" valign="top">Iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a999d703cc02d4b597056c3d718c9ed7b">llvm::detail::next_or_end</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;End)</td></tr>
<tr class="separator:a999d703cc02d4b597056c3d718c9ed7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308132bff22fab719f3c30f087e89e19" id="r_a308132bff22fab719f3c30f087e89e19"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Iter &gt; </td></tr>
<tr class="memitem:a308132bff22fab719f3c30f087e89e19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a308132bff22fab719f3c30f087e89e19">llvm::detail::deref_or_none</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;End) -&gt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; std::remove_const_t&lt; std::remove_reference_t&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(*<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)&gt; &gt; &gt;</td></tr>
<tr class="separator:a308132bff22fab719f3c30f087e89e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eac485ec0d931c1a0974664b7ca99b0" id="r_a0eac485ec0d931c1a0974664b7ca99b0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> U , typename... Args&gt; </td></tr>
<tr class="memitem:a0eac485ec0d931c1a0974664b7ca99b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1detail_1_1zip__longest__range.html">detail::zip_longest_range</a>&lt; <a class="el" href="classT.html">T</a>, U, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0eac485ec0d931c1a0974664b7ca99b0">llvm::zip_longest</a> (<a class="el" href="classT.html">T</a> &amp;&amp;t, U &amp;&amp;u, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0eac485ec0d931c1a0974664b7ca99b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over two or more iterators at the same time.  <br /></td></tr>
<tr class="separator:a0eac485ec0d931c1a0974664b7ca99b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ece7220c7a97c24dfa6adb4d527225" id="r_a84ece7220c7a97c24dfa6adb4d527225"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classValueT.html">ValueT</a> , typename... RangeTs&gt; </td></tr>
<tr class="memitem:a84ece7220c7a97c24dfa6adb4d527225"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1detail_1_1concat__range.html">detail::concat_range</a>&lt; <a class="el" href="classValueT.html">ValueT</a>, RangeTs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a84ece7220c7a97c24dfa6adb4d527225">llvm::concat</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">RangeTs</a> &amp;&amp;... Ranges)</td></tr>
<tr class="memdesc:a84ece7220c7a97c24dfa6adb4d527225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenated range across two or more ranges.  <br /></td></tr>
<tr class="separator:a84ece7220c7a97c24dfa6adb4d527225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f02feabe2798347395e53d18da48f96" id="r_a7f02feabe2798347395e53d18da48f96"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:a7f02feabe2798347395e53d18da48f96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7f02feabe2798347395e53d18da48f96">llvm::make_first_range</a> (ContainerTy &amp;&amp;c)</td></tr>
<tr class="memdesc:a7f02feabe2798347395e53d18da48f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a container of pairs, return a range over the first elements.  <br /></td></tr>
<tr class="separator:a7f02feabe2798347395e53d18da48f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe90bd018550a621549fa13700c0f762" id="r_abe90bd018550a621549fa13700c0f762"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:abe90bd018550a621549fa13700c0f762"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abe90bd018550a621549fa13700c0f762">llvm::make_second_range</a> (ContainerTy &amp;&amp;c)</td></tr>
<tr class="memdesc:abe90bd018550a621549fa13700c0f762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a container of pairs, return a range over the second elements.  <br /></td></tr>
<tr class="separator:abe90bd018550a621549fa13700c0f762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457abdc792a2b697c1031f09edb8492f" id="r_a457abdc792a2b697c1031f09edb8492f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> Iterator , <a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">RNG</a> &gt; </td></tr>
<tr class="memitem:a457abdc792a2b697c1031f09edb8492f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a457abdc792a2b697c1031f09edb8492f">llvm::shuffle</a> (Iterator first, Iterator last, <a class="el" href="classllvm_1_1ilist__node__impl.html">RNG</a> &amp;&amp;g)</td></tr>
<tr class="separator:a457abdc792a2b697c1031f09edb8492f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7510cdb641954d5eca96ba44129a0737" id="r_a7510cdb641954d5eca96ba44129a0737"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> <a class="el" href="classT.html">T</a> , std::size_t N&gt; </td></tr>
<tr class="memitem:a7510cdb641954d5eca96ba44129a0737"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">constexpr</a> <a class="el" href="classsize__t.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7510cdb641954d5eca96ba44129a0737">llvm::array_lengthof</a> (<a class="el" href="classT.html">T</a>(&amp;)[<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>])</td></tr>
<tr class="memdesc:a7510cdb641954d5eca96ba44129a0737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of an array.  <br /></td></tr>
<tr class="separator:a7510cdb641954d5eca96ba44129a0737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ebcf9fb4ed8e3831a2cf44500c8894" id="r_a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a33ebcf9fb4ed8e3831a2cf44500c8894">llvm::array_pod_sort_comparator</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classvoid.html">void</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">P1</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classvoid.html">void</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">P2</a>)</td></tr>
<tr class="memdesc:a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt std::less&lt;T&gt; for array_pod_sort.  <br /></td></tr>
<tr class="separator:a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1eb5637dd671428b6f138ed3db6428" id="r_add1eb5637dd671428b6f138ed3db6428"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> &gt; </td></tr>
<tr class="memitem:add1eb5637dd671428b6f138ed3db6428"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#add1eb5637dd671428b6f138ed3db6428">llvm::array_pod_sort</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> Start, <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> End)</td></tr>
<tr class="memdesc:add1eb5637dd671428b6f138ed3db6428"><td class="mdescLeft">&#160;</td><td class="mdescRight">array_pod_sort - This sorts an array with the specified start and end extent.  <br /></td></tr>
<tr class="separator:add1eb5637dd671428b6f138ed3db6428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5788f17f70ece4dcb34154325ce7126" id="r_ae5788f17f70ece4dcb34154325ce7126"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> &gt; </td></tr>
<tr class="memitem:ae5788f17f70ece4dcb34154325ce7126"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae5788f17f70ece4dcb34154325ce7126">llvm::array_pod_sort</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> Start, <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> End, int(*Compare)(<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> std::iterator_traits&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> &gt;::value_type *, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> std::iterator_traits&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> &gt;::value_type *))</td></tr>
<tr class="separator:ae5788f17f70ece4dcb34154325ce7126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830041552b81a6cea1f497490d0f41d9" id="r_a830041552b81a6cea1f497490d0f41d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> , std::enable_if_t&lt;!<a class="el" href="namespacellvm_1_1detail.html#ad650db3d4b46b28266b843474d80730f">detail::sort_trivially_copyable</a>&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a830041552b81a6cea1f497490d0f41d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a830041552b81a6cea1f497490d0f41d9">llvm::sort</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> Start, <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> End)</td></tr>
<tr class="separator:a830041552b81a6cea1f497490d0f41d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af591c14ddf8fa76705d1243a47a3bc57" id="r_af591c14ddf8fa76705d1243a47a3bc57"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container &gt; </td></tr>
<tr class="memitem:af591c14ddf8fa76705d1243a47a3bc57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#af591c14ddf8fa76705d1243a47a3bc57">llvm::sort</a> (Container &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>)</td></tr>
<tr class="separator:af591c14ddf8fa76705d1243a47a3bc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84aac64c34ffe3da7c08eb061d9feb7a" id="r_a84aac64c34ffe3da7c08eb061d9feb7a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Compare &gt; </td></tr>
<tr class="memitem:a84aac64c34ffe3da7c08eb061d9feb7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a84aac64c34ffe3da7c08eb061d9feb7a">llvm::sort</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> Start, <a class="el" href="classllvm_1_1ilist__node__impl.html">IteratorTy</a> End, Compare <a class="el" href="classllvm_1_1ilist__node__impl.html">Comp</a>)</td></tr>
<tr class="separator:a84aac64c34ffe3da7c08eb061d9feb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200e8e1b1e54f27f91fbf8b32d526cda" id="r_a200e8e1b1e54f27f91fbf8b32d526cda"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Compare &gt; </td></tr>
<tr class="memitem:a200e8e1b1e54f27f91fbf8b32d526cda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a200e8e1b1e54f27f91fbf8b32d526cda">llvm::sort</a> (Container &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, Compare <a class="el" href="classllvm_1_1ilist__node__impl.html">Comp</a>)</td></tr>
<tr class="separator:a200e8e1b1e54f27f91fbf8b32d526cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f3d955592ae2bc745f57e5b48ae115" id="r_a10f3d955592ae2bc745f57e5b48ae115"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R &gt; </td></tr>
<tr class="memitem:a10f3d955592ae2bc745f57e5b48ae115"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a10f3d955592ae2bc745f57e5b48ae115">llvm::size</a> (R &amp;&amp;Range, std::enable_if_t&lt; std::is_base_of&lt; std::random_access_iterator_tag, <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> std::iterator_traits&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(Range.begin())&gt;::iterator_category &gt;::value, <a class="el" href="classvoid.html">void</a> &gt; *=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>)</td></tr>
<tr class="memdesc:a10f3d955592ae2bc745f57e5b48ae115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a range.  <br /></td></tr>
<tr class="separator:a10f3d955592ae2bc745f57e5b48ae115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2a153b655ed78a07468297eb4c6256" id="r_a0b2a153b655ed78a07468297eb4c6256"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunction</a> &gt; </td></tr>
<tr class="memitem:a0b2a153b655ed78a07468297eb4c6256"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0b2a153b655ed78a07468297eb4c6256">llvm::for_each</a> (R &amp;&amp;Range, <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunction</a> <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="memdesc:a0b2a153b655ed78a07468297eb4c6256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::for_each which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:a0b2a153b655ed78a07468297eb4c6256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc3069afa2ce5ea62ac2eb183e51c00" id="r_a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> UnaryPredicate &gt; </td></tr>
<tr class="memitem:a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7dc3069afa2ce5ea62ac2eb183e51c00">llvm::none_of</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::none_of which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086e9fbdb06276db7753101a08a63adf" id="r_a086e9fbdb06276db7753101a08a63adf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a086e9fbdb06276db7753101a08a63adf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a086e9fbdb06276db7753101a08a63adf">llvm::find</a> (R &amp;&amp;Range, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classT.html">T</a> &amp;Val)</td></tr>
<tr class="memdesc:a086e9fbdb06276db7753101a08a63adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::find which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:a086e9fbdb06276db7753101a08a63adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78c09ae232b2ce188ff590d51e3c268" id="r_ac78c09ae232b2ce188ff590d51e3c268"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> UnaryPredicate &gt; </td></tr>
<tr class="memitem:ac78c09ae232b2ce188ff590d51e3c268"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac78c09ae232b2ce188ff590d51e3c268">llvm::find_if</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:ac78c09ae232b2ce188ff590d51e3c268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::find_if which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:ac78c09ae232b2ce188ff590d51e3c268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b49849160e7f089916f83c52511da9e" id="r_a7b49849160e7f089916f83c52511da9e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> UnaryPredicate &gt; </td></tr>
<tr class="memitem:a7b49849160e7f089916f83c52511da9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7b49849160e7f089916f83c52511da9e">llvm::find_if_not</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="separator:a7b49849160e7f089916f83c52511da9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec2517b6489e71067be03afebb4d350" id="r_a9ec2517b6489e71067be03afebb4d350"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> UnaryPredicate &gt; </td></tr>
<tr class="memitem:a9ec2517b6489e71067be03afebb4d350"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9ec2517b6489e71067be03afebb4d350">llvm::remove_if</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:a9ec2517b6489e71067be03afebb4d350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::remove_if which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:a9ec2517b6489e71067be03afebb4d350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d13fd05401d8eb0c97b9864a0eb6028" id="r_a4d13fd05401d8eb0c97b9864a0eb6028"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> UnaryPredicate &gt; </td></tr>
<tr class="memitem:a4d13fd05401d8eb0c97b9864a0eb6028"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a4d13fd05401d8eb0c97b9864a0eb6028">llvm::copy_if</a> (R &amp;&amp;Range, <a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a> Out, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:a4d13fd05401d8eb0c97b9864a0eb6028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::copy_if which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:a4d13fd05401d8eb0c97b9864a0eb6028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb650e853db0ddbb60411b885c499737" id="r_abb650e853db0ddbb60411b885c499737"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:abb650e853db0ddbb60411b885c499737"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abb650e853db0ddbb60411b885c499737">llvm::copy</a> (R &amp;&amp;Range, <a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a> Out)</td></tr>
<tr class="separator:abb650e853db0ddbb60411b885c499737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc9c7ecf70f66901e439f7c04ef3dbb" id="r_abfc9c7ecf70f66901e439f7c04ef3dbb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:abfc9c7ecf70f66901e439f7c04ef3dbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abfc9c7ecf70f66901e439f7c04ef3dbb">llvm::move</a> (R &amp;&amp;Range, <a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a> Out)</td></tr>
<tr class="memdesc:abfc9c7ecf70f66901e439f7c04ef3dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::move which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:abfc9c7ecf70f66901e439f7c04ef3dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1cd968cb420c82d70926920fcdc7d7" id="r_acd1cd968cb420c82d70926920fcdc7d7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a> &gt; </td></tr>
<tr class="memitem:acd1cd968cb420c82d70926920fcdc7d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#acd1cd968cb420c82d70926920fcdc7d7">llvm::is_contained</a> (R &amp;&amp;Range, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a> &amp;Element)</td></tr>
<tr class="memdesc:acd1cd968cb420c82d70926920fcdc7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::find to detect if an element exists in a container.  <br /></td></tr>
<tr class="separator:acd1cd968cb420c82d70926920fcdc7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864e071375fea140a5441a243372ff81" id="r_a864e071375fea140a5441a243372ff81"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Compare &gt; </td></tr>
<tr class="memitem:a864e071375fea140a5441a243372ff81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a864e071375fea140a5441a243372ff81">llvm::is_sorted</a> (R &amp;&amp;Range, Compare <a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>)</td></tr>
<tr class="memdesc:a864e071375fea140a5441a243372ff81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::is_sorted to check if elements in a range <code>R</code> are sorted with respect to a comparator <code>C</code>.  <br /></td></tr>
<tr class="separator:a864e071375fea140a5441a243372ff81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443134b90d575b15a5d131bc5de0ebd4" id="r_a443134b90d575b15a5d131bc5de0ebd4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R &gt; </td></tr>
<tr class="memitem:a443134b90d575b15a5d131bc5de0ebd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a443134b90d575b15a5d131bc5de0ebd4">llvm::is_sorted</a> (R &amp;&amp;Range)</td></tr>
<tr class="memdesc:a443134b90d575b15a5d131bc5de0ebd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::is_sorted to check if elements in a range <code>R</code> are sorted in non-descending order.  <br /></td></tr>
<tr class="separator:a443134b90d575b15a5d131bc5de0ebd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1772fd431decccb7926d484ea223db7" id="r_ab1772fd431decccb7926d484ea223db7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a> &gt; </td></tr>
<tr class="memitem:ab1772fd431decccb7926d484ea223db7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ab1772fd431decccb7926d484ea223db7">llvm::count</a> (R &amp;&amp;Range, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a> &amp;Element)</td></tr>
<tr class="memdesc:ab1772fd431decccb7926d484ea223db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::count to count the number of times an element <code>Element</code> occurs in the given range <code>Range</code>.  <br /></td></tr>
<tr class="separator:ab1772fd431decccb7926d484ea223db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac214df91cdc242f4710ea5a93939c678" id="r_ac214df91cdc242f4710ea5a93939c678"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> UnaryPredicate &gt; </td></tr>
<tr class="memitem:ac214df91cdc242f4710ea5a93939c678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac214df91cdc242f4710ea5a93939c678">llvm::count_if</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:ac214df91cdc242f4710ea5a93939c678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::count_if to count the number of times an element satisfying a given predicate occurs in a range.  <br /></td></tr>
<tr class="separator:ac214df91cdc242f4710ea5a93939c678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615619b0b2879029152b9a20e96624bc" id="r_a615619b0b2879029152b9a20e96624bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunction</a> &gt; </td></tr>
<tr class="memitem:a615619b0b2879029152b9a20e96624bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a615619b0b2879029152b9a20e96624bc">llvm::transform</a> (R &amp;&amp;Range, <a class="el" href="classllvm_1_1ilist__node__impl.html">OutputIt</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">d_first</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunction</a> <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="memdesc:a615619b0b2879029152b9a20e96624bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::transform to apply a function to a range and store the result elsewhere.  <br /></td></tr>
<tr class="separator:a615619b0b2879029152b9a20e96624bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc14fa925bdbae07ef7bbd16ca82ce3d" id="r_abc14fa925bdbae07ef7bbd16ca82ce3d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> UnaryPredicate &gt; </td></tr>
<tr class="memitem:abc14fa925bdbae07ef7bbd16ca82ce3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abc14fa925bdbae07ef7bbd16ca82ce3d">llvm::partition</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:abc14fa925bdbae07ef7bbd16ca82ce3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::partition which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:abc14fa925bdbae07ef7bbd16ca82ce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81eb67f09ee4944eaeeddbc54c0c0de" id="r_aa81eb67f09ee4944eaeeddbc54c0c0de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:aa81eb67f09ee4944eaeeddbc54c0c0de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa81eb67f09ee4944eaeeddbc54c0c0de">llvm::lower_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="classllvm_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:aa81eb67f09ee4944eaeeddbc54c0c0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::lower_bound which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:aa81eb67f09ee4944eaeeddbc54c0c0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9220eb5a5a4bb04dba101e600e080c8d" id="r_a9220eb5a5a4bb04dba101e600e080c8d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Compare &gt; </td></tr>
<tr class="memitem:a9220eb5a5a4bb04dba101e600e080c8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9220eb5a5a4bb04dba101e600e080c8d">llvm::lower_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="classllvm_1_1Value.html">Value</a>, Compare <a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>)</td></tr>
<tr class="separator:a9220eb5a5a4bb04dba101e600e080c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7d2ab11554bd10d15b6cb21b2c2787" id="r_a4b7d2ab11554bd10d15b6cb21b2c2787"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a4b7d2ab11554bd10d15b6cb21b2c2787"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a4b7d2ab11554bd10d15b6cb21b2c2787">llvm::upper_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="classllvm_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:a4b7d2ab11554bd10d15b6cb21b2c2787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::upper_bound which take ranges instead of having to pass begin/end explicitly.  <br /></td></tr>
<tr class="separator:a4b7d2ab11554bd10d15b6cb21b2c2787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb90f7f42557dd188cd7ed0e4c46b8" id="r_ad7fb90f7f42557dd188cd7ed0e4c46b8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Compare &gt; </td></tr>
<tr class="memitem:ad7fb90f7f42557dd188cd7ed0e4c46b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ad7fb90f7f42557dd188cd7ed0e4c46b8">llvm::upper_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="classllvm_1_1Value.html">Value</a>, Compare <a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>)</td></tr>
<tr class="separator:ad7fb90f7f42557dd188cd7ed0e4c46b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076f93c387f454f0db13d4bc7d4e7f9c" id="r_a076f93c387f454f0db13d4bc7d4e7f9c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R &gt; </td></tr>
<tr class="memitem:a076f93c387f454f0db13d4bc7d4e7f9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a076f93c387f454f0db13d4bc7d4e7f9c">llvm::stable_sort</a> (R &amp;&amp;Range)</td></tr>
<tr class="separator:a076f93c387f454f0db13d4bc7d4e7f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe585614b67e0237c8fdbefd475572e" id="r_a0fe585614b67e0237c8fdbefd475572e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Compare &gt; </td></tr>
<tr class="memitem:a0fe585614b67e0237c8fdbefd475572e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0fe585614b67e0237c8fdbefd475572e">llvm::stable_sort</a> (R &amp;&amp;Range, Compare <a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>)</td></tr>
<tr class="separator:a0fe585614b67e0237c8fdbefd475572e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327a399b9f6ef414a29ddeffba934d26" id="r_a327a399b9f6ef414a29ddeffba934d26"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Predicate , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Val  = decltype(*adl_begin(std::declval&lt;R&gt;()))&gt; </td></tr>
<tr class="memitem:a327a399b9f6ef414a29ddeffba934d26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a327a399b9f6ef414a29ddeffba934d26">llvm::partition_point</a> (R &amp;&amp;Range, Predicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:a327a399b9f6ef414a29ddeffba934d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search for the first iterator in a range where a predicate is false.  <br /></td></tr>
<tr class="separator:a327a399b9f6ef414a29ddeffba934d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7451464a1e408bf83808f303eae5da4" id="r_aa7451464a1e408bf83808f303eae5da4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R &gt; </td></tr>
<tr class="memitem:aa7451464a1e408bf83808f303eae5da4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa7451464a1e408bf83808f303eae5da4">llvm::is_splat</a> (R &amp;&amp;Range)</td></tr>
<tr class="memdesc:aa7451464a1e408bf83808f303eae5da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::equal to detect if all elements in a container are same.  <br /></td></tr>
<tr class="separator:aa7451464a1e408bf83808f303eae5da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a7de5a04920954ac964059cfc428ad" id="r_ac9a7de5a04920954ac964059cfc428ad"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> UnaryPredicate &gt; </td></tr>
<tr class="memitem:ac9a7de5a04920954ac964059cfc428ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac9a7de5a04920954ac964059cfc428ad">llvm::erase_if</a> (Container &amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, UnaryPredicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:ac9a7de5a04920954ac964059cfc428ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a container algorithm similar to C++ Library Fundamentals v2's <code>erase_if</code> which is equivalent to:  <br /></td></tr>
<tr class="separator:ac9a7de5a04920954ac964059cfc428ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82bb12b2879425012b3742487e10964" id="r_aa82bb12b2879425012b3742487e10964"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="namespacellvm.html#ad18871060ac1b051c7322cc6ad71e11c">ValueType</a> &gt; </td></tr>
<tr class="memitem:aa82bb12b2879425012b3742487e10964"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa82bb12b2879425012b3742487e10964">llvm::erase_value</a> (Container &amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="namespacellvm.html#ad18871060ac1b051c7322cc6ad71e11c">ValueType</a> V)</td></tr>
<tr class="memdesc:aa82bb12b2879425012b3742487e10964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function to remove a value from a container:  <br /></td></tr>
<tr class="separator:aa82bb12b2879425012b3742487e10964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d3d23a084c4544ee5903203db10e8a" id="r_a39d3d23a084c4544ee5903203db10e8a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Range &gt; </td></tr>
<tr class="memitem:a39d3d23a084c4544ee5903203db10e8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a39d3d23a084c4544ee5903203db10e8a">llvm::append_range</a> (Container &amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, Range &amp;&amp;R)</td></tr>
<tr class="memdesc:a39d3d23a084c4544ee5903203db10e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function to append a range to a container.  <br /></td></tr>
<tr class="separator:a39d3d23a084c4544ee5903203db10e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca964c0c0aee877ecf5c5af8a47982f6" id="r_aca964c0c0aee877ecf5c5af8a47982f6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">RandomAccessIterator</a> &gt; </td></tr>
<tr class="memitem:aca964c0c0aee877ecf5c5af8a47982f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aca964c0c0aee877ecf5c5af8a47982f6">llvm::replace</a> (Container &amp;Cont, <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container::iterator <a class="el" href="classllvm_1_1ilist__node__impl.html">ContIt</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container::iterator <a class="el" href="classllvm_1_1ilist__node__impl.html">ContEnd</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html">RandomAccessIterator</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ValIt</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html">RandomAccessIterator</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ValEnd</a>)</td></tr>
<tr class="memdesc:aca964c0c0aee877ecf5c5af8a47982f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a sequence container Cont, replace the range [ContIt, ContEnd) with the range [ValIt, ValEnd) (which is not from the same container).  <br /></td></tr>
<tr class="separator:aca964c0c0aee877ecf5c5af8a47982f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc8234929f8be8a1fe8048eaa87a7b9" id="r_acfc8234929f8be8a1fe8048eaa87a7b9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Range  = std::initializer_list&lt;                                 typename Container::value_type&gt;&gt; </td></tr>
<tr class="memitem:acfc8234929f8be8a1fe8048eaa87a7b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#acfc8234929f8be8a1fe8048eaa87a7b9">llvm::replace</a> (Container &amp;Cont, <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container::iterator <a class="el" href="classllvm_1_1ilist__node__impl.html">ContIt</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container::iterator <a class="el" href="classllvm_1_1ilist__node__impl.html">ContEnd</a>, Range R)</td></tr>
<tr class="memdesc:acfc8234929f8be8a1fe8048eaa87a7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a sequence container Cont, replace the range [ContIt, ContEnd) with the range R.  <br /></td></tr>
<tr class="separator:acfc8234929f8be8a1fe8048eaa87a7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2145da5bde7663d745e9c3ade392809f" id="r_a2145da5bde7663d745e9c3ade392809f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ForwardIterator</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunctor</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">NullaryFunctor</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a>  = typename std::enable_if&lt;              !std::is_constructible&lt;StringRef, UnaryFunctor&gt;::value &amp;&amp;              !std::is_constructible&lt;StringRef, NullaryFunctor&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a2145da5bde7663d745e9c3ade392809f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a2145da5bde7663d745e9c3ade392809f">llvm::interleave</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">ForwardIterator</a> begin, <a class="el" href="classllvm_1_1ilist__node__impl.html">ForwardIterator</a> end, <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunctor</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">each_fn</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html">NullaryFunctor</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">between_fn</a>)</td></tr>
<tr class="memdesc:a2145da5bde7663d745e9c3ade392809f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL-style algorithm similar to std::for_each that applies a second functor between every pair of elements.  <br /></td></tr>
<tr class="separator:a2145da5bde7663d745e9c3ade392809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75c79282c4734018fe1482b12d03d62" id="r_ad75c79282c4734018fe1482b12d03d62"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunctor</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">NullaryFunctor</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a>  = typename std::enable_if&lt;              !std::is_constructible&lt;StringRef, UnaryFunctor&gt;::value &amp;&amp;              !std::is_constructible&lt;StringRef, NullaryFunctor&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad75c79282c4734018fe1482b12d03d62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ad75c79282c4734018fe1482b12d03d62">llvm::interleave</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Container &amp;c, <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunctor</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">each_fn</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html">NullaryFunctor</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">between_fn</a>)</td></tr>
<tr class="separator:ad75c79282c4734018fe1482b12d03d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c567bf2276d10ac77e08571ea27aabe" id="r_a1c567bf2276d10ac77e08571ea27aabe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunctor</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">StreamT</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a>  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:a1c567bf2276d10ac77e08571ea27aabe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a1c567bf2276d10ac77e08571ea27aabe">llvm::interleave</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Container &amp;c, <a class="el" href="classllvm_1_1ilist__node__impl.html">StreamT</a> &amp;os, <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunctor</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">each_fn</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1StringRef.html">StringRef</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">separator</a>)</td></tr>
<tr class="memdesc:a1c567bf2276d10ac77e08571ea27aabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of interleave for the common case of string separator.  <br /></td></tr>
<tr class="separator:a1c567bf2276d10ac77e08571ea27aabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474e54bf9021abdb881613524c8fdcf5" id="r_a474e54bf9021abdb881613524c8fdcf5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">StreamT</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a>  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:a474e54bf9021abdb881613524c8fdcf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a474e54bf9021abdb881613524c8fdcf5">llvm::interleave</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Container &amp;c, <a class="el" href="classllvm_1_1ilist__node__impl.html">StreamT</a> &amp;os, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1StringRef.html">StringRef</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">separator</a>)</td></tr>
<tr class="separator:a474e54bf9021abdb881613524c8fdcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4daeeeabc6cdcff5627aace66de8a3" id="r_a3b4daeeeabc6cdcff5627aace66de8a3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunctor</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">StreamT</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a>  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:a3b4daeeeabc6cdcff5627aace66de8a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a3b4daeeeabc6cdcff5627aace66de8a3">llvm::interleaveComma</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Container &amp;c, <a class="el" href="classllvm_1_1ilist__node__impl.html">StreamT</a> &amp;os, <a class="el" href="classllvm_1_1ilist__node__impl.html">UnaryFunctor</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">each_fn</a>)</td></tr>
<tr class="separator:a3b4daeeeabc6cdcff5627aace66de8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c3a0594ff96ff6d3dcef270a3f4a60" id="r_a65c3a0594ff96ff6d3dcef270a3f4a60"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Container , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">StreamT</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a>  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:a65c3a0594ff96ff6d3dcef270a3f4a60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a65c3a0594ff96ff6d3dcef270a3f4a60">llvm::interleaveComma</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Container &amp;c, <a class="el" href="classllvm_1_1ilist__node__impl.html">StreamT</a> &amp;os)</td></tr>
<tr class="separator:a65c3a0594ff96ff6d3dcef270a3f4a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51a79063c6d9b906682e27ced445f7e" id="r_aa51a79063c6d9b906682e27ced445f7e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> R &gt; </td></tr>
<tr class="memitem:aa51a79063c6d9b906682e27ced445f7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1detail_1_1enumerator.html">detail::enumerator</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa51a79063c6d9b906682e27ced445f7e">llvm::enumerate</a> (R &amp;&amp;TheRange)</td></tr>
<tr class="memdesc:aa51a79063c6d9b906682e27ced445f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input range, returns a new range whose values are are pair (A,B) such that A is the 0-based index of the item in the sequence, and B is the value from the original sequence.  <br /></td></tr>
<tr class="separator:aa51a79063c6d9b906682e27ced445f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf8cb13bb366998069df510abd97f9a" id="r_a2bf8cb13bb366998069df510abd97f9a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Tuple , std::size_t... I&gt; </td></tr>
<tr class="memitem:a2bf8cb13bb366998069df510abd97f9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(<a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a2bf8cb13bb366998069df510abd97f9a">llvm::detail::apply_tuple_impl</a> (<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">f</a>, Tuple &amp;&amp;t, std::index_sequence&lt; I... &gt;)</td></tr>
<tr class="separator:a2bf8cb13bb366998069df510abd97f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cda7d24921d2eee025c4904c74a2d3" id="r_af9cda7d24921d2eee025c4904c74a2d3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Tuple &gt; </td></tr>
<tr class="memitem:af9cda7d24921d2eee025c4904c74a2d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(<a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#af9cda7d24921d2eee025c4904c74a2d3">llvm::apply_tuple</a> (<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a> &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">f</a>, Tuple &amp;&amp;t)</td></tr>
<tr class="memdesc:af9cda7d24921d2eee025c4904c74a2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input tuple (a1, a2, ..., an), pass the arguments of the tuple variadically to f as if by calling f(a1, a2, ..., an) and return the result.  <br /></td></tr>
<tr class="separator:af9cda7d24921d2eee025c4904c74a2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a396bf53b927c8f4c2191a0d115c7e1" id="r_a7a396bf53b927c8f4c2191a0d115c7e1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Pred  = bool (*)(const decltype(*std::declval&lt;IterTy&gt;()) &amp;)&gt; </td></tr>
<tr class="memitem:a7a396bf53b927c8f4c2191a0d115c7e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7a396bf53b927c8f4c2191a0d115c7e1">llvm::hasNItems</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> &amp;&amp;Begin, <a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> &amp;&amp;End, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, Pred &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">ShouldBeCounted</a>=[](<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(*std::declval&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> &gt;()) &amp;) { return <a class="el" href="BasicAliasAnalysis_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>;}, std::enable_if_t&lt; !std::is_base_of&lt; std::random_access_iterator_tag, <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> std::iterator_traits&lt; std::remove_reference_t&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(Begin)&gt; &gt;::iterator_category &gt;::value, <a class="el" href="classvoid.html">void</a> &gt; *=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>)</td></tr>
<tr class="memdesc:a7a396bf53b927c8f4c2191a0d115c7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the sequence [Begin, End) has exactly N items.  <br /></td></tr>
<tr class="separator:a7a396bf53b927c8f4c2191a0d115c7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59eea4fd874ad0e0fad609e750c88976" id="r_a59eea4fd874ad0e0fad609e750c88976"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Pred  = bool (*)(const decltype(*std::declval&lt;IterTy&gt;()) &amp;)&gt; </td></tr>
<tr class="memitem:a59eea4fd874ad0e0fad609e750c88976"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a59eea4fd874ad0e0fad609e750c88976">llvm::hasNItemsOrMore</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> &amp;&amp;Begin, <a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> &amp;&amp;End, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, Pred &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">ShouldBeCounted</a>=[](<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(*std::declval&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> &gt;()) &amp;) { return <a class="el" href="BasicAliasAnalysis_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>;}, std::enable_if_t&lt; !std::is_base_of&lt; std::random_access_iterator_tag, <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> std::iterator_traits&lt; std::remove_reference_t&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(Begin)&gt; &gt;::iterator_category &gt;::value, <a class="el" href="classvoid.html">void</a> &gt; *=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>)</td></tr>
<tr class="memdesc:a59eea4fd874ad0e0fad609e750c88976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the sequence [Begin, End) has N or more items.  <br /></td></tr>
<tr class="separator:a59eea4fd874ad0e0fad609e750c88976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b24ebd69d40090a23b6a2717a896625" id="r_a3b24ebd69d40090a23b6a2717a896625"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> , <a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> Pred  = bool (*)(const decltype(*std::declval&lt;IterTy&gt;()) &amp;)&gt; </td></tr>
<tr class="memitem:a3b24ebd69d40090a23b6a2717a896625"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a3b24ebd69d40090a23b6a2717a896625">llvm::hasNItemsOrLess</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> &amp;&amp;Begin, <a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> &amp;&amp;End, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, Pred &amp;&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">ShouldBeCounted</a>=[](<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">decltype</a>(*std::declval&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">IterTy</a> &gt;()) &amp;) { return <a class="el" href="BasicAliasAnalysis_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>;})</td></tr>
<tr class="memdesc:a3b24ebd69d40090a23b6a2717a896625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sequence [Begin, End) has N or less items.  <br /></td></tr>
<tr class="separator:a3b24ebd69d40090a23b6a2717a896625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23468ef9810b74fa5b8d4a8f319d715" id="r_aa23468ef9810b74fa5b8d4a8f319d715"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:aa23468ef9810b74fa5b8d4a8f319d715"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa23468ef9810b74fa5b8d4a8f319d715">llvm::hasNItems</a> (ContainerTy &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:aa23468ef9810b74fa5b8d4a8f319d715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given container has exactly N items.  <br /></td></tr>
<tr class="separator:aa23468ef9810b74fa5b8d4a8f319d715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cc12beecee8ad26a54d3d81c6361af" id="r_ae7cc12beecee8ad26a54d3d81c6361af"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:ae7cc12beecee8ad26a54d3d81c6361af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae7cc12beecee8ad26a54d3d81c6361af">llvm::hasNItemsOrMore</a> (ContainerTy &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:ae7cc12beecee8ad26a54d3d81c6361af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given container has N or more items.  <br /></td></tr>
<tr class="separator:ae7cc12beecee8ad26a54d3d81c6361af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38328ea32bc035b0156dfb05ff54400a" id="r_a38328ea32bc035b0156dfb05ff54400a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> ContainerTy &gt; </td></tr>
<tr class="memitem:a38328ea32bc035b0156dfb05ff54400a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a38328ea32bc035b0156dfb05ff54400a">llvm::hasNItemsOrLess</a> (ContainerTy &amp;&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:a38328ea32bc035b0156dfb05ff54400a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given container has N or less items.  <br /></td></tr>
<tr class="separator:a38328ea32bc035b0156dfb05ff54400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2f9c935d4fc983512ebb5bd6c57c7f" id="r_abb2f9c935d4fc983512ebb5bd6c57c7f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> Ptr &gt; </td></tr>
<tr class="memitem:abb2f9c935d4fc983512ebb5bd6c57c7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abb2f9c935d4fc983512ebb5bd6c57c7f">llvm::to_address</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Ptr &amp;<a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="memdesc:abb2f9c935d4fc983512ebb5bd6c57c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer that represents the same address as the argument.  <br /></td></tr>
<tr class="separator:abb2f9c935d4fc983512ebb5bd6c57c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628cf8baacb86dac2bf705c25800f661" id="r_a628cf8baacb86dac2bf705c25800f661"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a628cf8baacb86dac2bf705c25800f661"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">constexpr</a> <a class="el" href="classT.html">T</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a628cf8baacb86dac2bf705c25800f661">llvm::to_address</a> (<a class="el" href="classT.html">T</a> *<a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>)</td></tr>
<tr class="separator:a628cf8baacb86dac2bf705c25800f661"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a141d266dab226e9a4b9212ec2958419b" id="r_a141d266dab226e9a4b9212ec2958419b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classllvm_1_1ilist__node__impl.html">typename</a> <a class="el" href="classT.html">T</a> &gt; </td></tr>
<tr class="memitem:a141d266dab226e9a4b9212ec2958419b"><td class="memTemplItemLeft" align="right" valign="top">int(*)(<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classvoid.html">void</a> *, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classvoid.html">void</a> *)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a141d266dab226e9a4b9212ec2958419b">llvm::get_array_pod_sort_comparator</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classT.html">T</a> &amp;)</td></tr>
<tr class="memdesc:a141d266dab226e9a4b9212ec2958419b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_array_pod_sort_comparator - This is an internal helper function used to get type deduction of T right.  <br /></td></tr>
<tr class="separator:a141d266dab226e9a4b9212ec2958419b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 20 2024 14:04:53 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
