<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: llvm::TargetTransformInfo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;17.0.0rc</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacellvm.html">llvm</a></li><li class="navelem"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classllvm_1_1TargetTransformInfo-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">llvm::TargetTransformInfo Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This pass provides access to the codegen interfaces that are needed for IR-level transformations.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="TargetTransformInfo_8h_source.html">llvm/Analysis/TargetTransformInfo.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1LSRCost.html">LSRCost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1MemCmpExpansionOptions.html">MemCmpExpansionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns options for expansion of memcmp. IsZeroCmp is.  <a href="structllvm_1_1TargetTransformInfo_1_1MemCmpExpansionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1OperandValueInfo.html">OperandValueInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1PeelingPreferences.html">PeelingPreferences</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1PointersChainInfo.html">PointersChainInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describe known properties for a set of pointers.  <a href="structllvm_1_1TargetTransformInfo_1_1PointersChainInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1ReductionFlags.html">ReductionFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags describing the kind of vector reduction.  <a href="structllvm_1_1TargetTransformInfo_1_1ReductionFlags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html">UnrollingPreferences</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters that control the generic loop unrolling transformation.  <a href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1VPLegalization.html">VPLegalization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af1bf12b2f33b7e30f8f361a1e7642079" id="r_af1bf12b2f33b7e30f8f361a1e7642079"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1bf12b2f33b7e30f8f361a1e7642079"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1bf12b2f33b7e30f8f361a1e7642079">TargetTransformInfo</a> (T Impl)</td></tr>
<tr class="memdesc:af1bf12b2f33b7e30f8f361a1e7642079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a TTI object using a type implementing the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below.  <br /></td></tr>
<tr class="separator:af1bf12b2f33b7e30f8f361a1e7642079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b62dddca1c89d43af02d0e2ab06030" id="r_ac7b62dddca1c89d43af02d0e2ab06030"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7b62dddca1c89d43af02d0e2ab06030">TargetTransformInfo</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;<a class="el" href="AArch64SLSHardening_8cpp.html#ad467c4ab9119043f9b7750ab986be61a">DL</a>)</td></tr>
<tr class="memdesc:ac7b62dddca1c89d43af02d0e2ab06030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a baseline TTI object using a minimal implementation of the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below.  <br /></td></tr>
<tr class="separator:ac7b62dddca1c89d43af02d0e2ab06030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab158463a734f57c86e685364527ebaa4" id="r_ab158463a734f57c86e685364527ebaa4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab158463a734f57c86e685364527ebaa4">TargetTransformInfo</a> (<a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;<a class="el" href="AMDGPULibCalls_8cpp.html#afecf1cc1292b07f57d343c0f4d682044">Arg</a>)</td></tr>
<tr class="separator:ab158463a734f57c86e685364527ebaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d955ca0eda3479b562ccc505575049b" id="r_a6d955ca0eda3479b562ccc505575049b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d955ca0eda3479b562ccc505575049b">operator=</a> (<a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>)</td></tr>
<tr class="separator:a6d955ca0eda3479b562ccc505575049b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e9d106cef4491370c43c4f136fc050" id="r_af9e9d106cef4491370c43c4f136fc050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9e9d106cef4491370c43c4f136fc050">~TargetTransformInfo</a> ()</td></tr>
<tr class="separator:af9e9d106cef4491370c43c4f136fc050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2528c700b439460d668d188813ebf08c" id="r_a2528c700b439460d668d188813ebf08c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2528c700b439460d668d188813ebf08c">invalidate</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1PreservedAnalyses.html">PreservedAnalyses</a> &amp;, <a class="el" href="classllvm_1_1AnalysisManager_1_1Invalidator.html">FunctionAnalysisManager::Invalidator</a> &amp;)</td></tr>
<tr class="memdesc:a2528c700b439460d668d188813ebf08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the invalidation of this information.  <br /></td></tr>
<tr class="separator:a2528c700b439460d668d188813ebf08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959a58a9740a235c53703a287e722906" id="r_a959a58a9740a235c53703a287e722906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a959a58a9740a235c53703a287e722906">hasArmWideBranch</a> (<a class="el" href="classbool.html">bool</a> Thumb) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a959a58a9740a235c53703a287e722906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a234a5bae6ee891cc95421752592ec7" id="r_a0a234a5bae6ee891cc95421752592ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a234a5bae6ee891cc95421752592ec7">getMaxNumArgs</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a0a234a5bae6ee891cc95421752592ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vector Predication Information</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Whether the target supports the evl parameter of VP intrinsic efficiently in hardware, for the given opcode and type/alignment.</p>
<p>(see LLVM Language Reference - "Vector Predication Intrinsics"). <a class="el" href="classllvm_1_1Use.html" title="A Use represents the edge between a Value definition and its users.">Use</a> of evl is discouraged when that is not the case. </p>
</div></td></tr>
<tr class="memitem:aa3898235ae1cbefb03b09d1ddebae0e5" id="r_aa3898235ae1cbefb03b09d1ddebae0e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3898235ae1cbefb03b09d1ddebae0e5">hasActiveVectorLength</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aa3898235ae1cbefb03b09d1ddebae0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4843aaa2647f4f1fb037f957beda8eaa" id="r_a4843aaa2647f4f1fb037f957beda8eaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1VPLegalization.html">VPLegalization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4843aaa2647f4f1fb037f957beda8eaa">getVPLegalizationStrategy</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1VPIntrinsic.html">VPIntrinsic</a> &amp;PI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a4843aaa2647f4f1fb037f957beda8eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Generic Target Information</h2></td></tr>
<tr class="memitem:a706f223f760b55668fbae74202b816bb" id="r_a706f223f760b55668fbae74202b816bb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> { <a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TCK_RecipThroughput</a>
, <a class="el" href="#a706f223f760b55668fbae74202b816bba81b2c6f1f1e13e4a575e6d1c8b29b6e1">TCK_Latency</a>
, <a class="el" href="#a706f223f760b55668fbae74202b816bba737cfc93e5a2ff961677d57186167e7c">TCK_CodeSize</a>
, <a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TCK_SizeAndLatency</a>
 }</td></tr>
<tr class="memdesc:a706f223f760b55668fbae74202b816bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of cost model.  <a href="#a706f223f760b55668fbae74202b816bb">More...</a><br /></td></tr>
<tr class="separator:a706f223f760b55668fbae74202b816bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44f6b9fdbb5f9cc199f8329cb0b272c" id="r_ac44f6b9fdbb5f9cc199f8329cb0b272c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac44f6b9fdbb5f9cc199f8329cb0b272c">TargetCostConstants</a> { <a class="el" href="#ac44f6b9fdbb5f9cc199f8329cb0b272ca89f768b1267e3083b4eb05b4ab77e717">TCC_Free</a> = 0
, <a class="el" href="#ac44f6b9fdbb5f9cc199f8329cb0b272cae46c9eecc49bd2dc253c607e78a0fb86">TCC_Basic</a> = 1
, <a class="el" href="#ac44f6b9fdbb5f9cc199f8329cb0b272ca022565d444ccf496c0414bccefbcd9c8">TCC_Expensive</a> = 4
 }</td></tr>
<tr class="memdesc:ac44f6b9fdbb5f9cc199f8329cb0b272c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying constants for 'cost' values in this interface.  <a href="#ac44f6b9fdbb5f9cc199f8329cb0b272c">More...</a><br /></td></tr>
<tr class="separator:ac44f6b9fdbb5f9cc199f8329cb0b272c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fca44604259f23a346fdc969aaefeb" id="r_a57fca44604259f23a346fdc969aaefeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57fca44604259f23a346fdc969aaefeb">getGEPCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">PointeeType</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="TargetLibraryInfo_8cpp.html#aca185e6d0e9f423dbb24440206454872a11dbf501abf829b3ab7049c2d3a8a053">Ptr</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; <a class="el" href="MIRNamerPass_8cpp.html#a05e4be4ec3e2c3587dda0e376bb6822c">Operands</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">AccessType</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TCK_SizeAndLatency</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a57fca44604259f23a346fdc969aaefeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of a GEP operation when lowered.  <br /></td></tr>
<tr class="separator:a57fca44604259f23a346fdc969aaefeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bdd6764746631f64902145e7dd7872" id="r_a75bdd6764746631f64902145e7dd7872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75bdd6764746631f64902145e7dd7872">getPointersChainCost</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; Ptrs, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="namespacellvm_1_1sampleprof.html#a702f69807459cc25db5754a5f179d3fcaf6fbeb8fa9f451468611536b00878d41">Base</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1TargetTransformInfo_1_1PointersChainInfo.html">PointersChainInfo</a> &amp;<a class="el" href="CSEInfo_8cpp.html#a75f8a8519c2c9b30e7c06dc5e256fffa">Info</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *AccessTy, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a75bdd6764746631f64902145e7dd7872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of a chain of pointers (typically pointer operands of a chain of loads or stores within same block) operations set when lowered.  <br /></td></tr>
<tr class="separator:a75bdd6764746631f64902145e7dd7872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab827381fb7034818435387572088683" id="r_aab827381fb7034818435387572088683"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab827381fb7034818435387572088683">getInliningThresholdMultiplier</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aab827381fb7034818435387572088683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5dd9267d6c9b90b4daa6410be3da6a" id="r_a7e5dd9267d6c9b90b4daa6410be3da6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e5dd9267d6c9b90b4daa6410be3da6a">adjustInliningThreshold</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1CallBase.html">CallBase</a> *CB) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a7e5dd9267d6c9b90b4daa6410be3da6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac02d3d31a66774a2a021b7db942dc2" id="r_a9ac02d3d31a66774a2a021b7db942dc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ac02d3d31a66774a2a021b7db942dc2">getCallerAllocaCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1CallBase.html">CallBase</a> *CB, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *AI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a9ac02d3d31a66774a2a021b7db942dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30e16357eef0a6bb3dc98fb7fd67684" id="r_aa30e16357eef0a6bb3dc98fb7fd67684"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa30e16357eef0a6bb3dc98fb7fd67684">getInlinerVectorBonusPercent</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aa30e16357eef0a6bb3dc98fb7fd67684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd4d71624770e0e121a19b1efd26e52" id="r_a7cd4d71624770e0e121a19b1efd26e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cd4d71624770e0e121a19b1efd26e52">getMemcpyCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a7cd4d71624770e0e121a19b1efd26e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af202c774afe951c5c841c5bf356efaae" id="r_af202c774afe951c5c841c5bf356efaae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint64__t.html">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af202c774afe951c5c841c5bf356efaae">getMaxMemIntrinsicInlineSizeThreshold</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af202c774afe951c5c841c5bf356efaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum memset / memcpy size in bytes that still makes it profitable to inline the call.  <br /></td></tr>
<tr class="separator:af202c774afe951c5c841c5bf356efaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b0a3c3724fe2cb1b335007c068179d" id="r_a64b0a3c3724fe2cb1b335007c068179d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64b0a3c3724fe2cb1b335007c068179d">getEstimatedNumberOfCaseClusters</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SwitchInst.html">SwitchInst</a> &amp;SI, <a class="el" href="classunsigned.html">unsigned</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">JTSize</a>, <a class="el" href="classllvm_1_1ProfileSummaryInfo.html">ProfileSummaryInfo</a> *PSI, <a class="el" href="classllvm_1_1BlockFrequencyInfo.html">BlockFrequencyInfo</a> *BFI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a64b0a3c3724fe2cb1b335007c068179d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77dbedcfd916a5c9b58e753b2678a98" id="r_ac77dbedcfd916a5c9b58e753b2678a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac77dbedcfd916a5c9b58e753b2678a98">getInstructionCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1User.html">User</a> *U, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; <a class="el" href="MIRNamerPass_8cpp.html#a05e4be4ec3e2c3587dda0e376bb6822c">Operands</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac77dbedcfd916a5c9b58e753b2678a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the cost of a given IR user when lowered.  <br /></td></tr>
<tr class="separator:ac77dbedcfd916a5c9b58e753b2678a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2a0583912318be02194abf401fdf1e" id="r_a3e2a0583912318be02194abf401fdf1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e2a0583912318be02194abf401fdf1e">getInstructionCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1User.html">User</a> *U, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a3e2a0583912318be02194abf401fdf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function which calls the three-argument getInstructionCost with <code>Operands</code> which are the current operands U has.  <br /></td></tr>
<tr class="separator:a3e2a0583912318be02194abf401fdf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b320fd35acaf648a0a7826a0bdd777" id="r_a99b320fd35acaf648a0a7826a0bdd777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1BranchProbability.html">BranchProbability</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99b320fd35acaf648a0a7826a0bdd777">getPredictableBranchThreshold</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a99b320fd35acaf648a0a7826a0bdd777"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a branch or a select condition is skewed in one direction by more than this factor, it is very likely to be predicted correctly.  <br /></td></tr>
<tr class="separator:a99b320fd35acaf648a0a7826a0bdd777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233996b13b5fa2774af23282d8870204" id="r_a233996b13b5fa2774af23282d8870204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a233996b13b5fa2774af23282d8870204">hasBranchDivergence</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a233996b13b5fa2774af23282d8870204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if branch divergence exists.  <br /></td></tr>
<tr class="separator:a233996b13b5fa2774af23282d8870204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787ddce53dcb1b93b5c173dbbba4d3f0" id="r_a787ddce53dcb1b93b5c173dbbba4d3f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a787ddce53dcb1b93b5c173dbbba4d3f0">isSourceOfDivergence</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *V) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a787ddce53dcb1b93b5c173dbbba4d3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether V is a source of divergence.  <br /></td></tr>
<tr class="separator:a787ddce53dcb1b93b5c173dbbba4d3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b21625ceb4a9d9eb225fa18cbf951de" id="r_a1b21625ceb4a9d9eb225fa18cbf951de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b21625ceb4a9d9eb225fa18cbf951de">isAlwaysUniform</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *V) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a1b21625ceb4a9d9eb225fa18cbf951de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61de27a7641e7ce57bc6e3fdc8cd8d2" id="r_ad61de27a7641e7ce57bc6e3fdc8cd8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad61de27a7641e7ce57bc6e3fdc8cd8d2">isValidAddrSpaceCast</a> (<a class="el" href="classunsigned.html">unsigned</a> FromAS, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ToAS</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad61de27a7641e7ce57bc6e3fdc8cd8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target whether the specified address space cast from FromAS to ToAS is valid.  <br /></td></tr>
<tr class="separator:ad61de27a7641e7ce57bc6e3fdc8cd8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3e39d2d1306afddf277fd3fca9aebb" id="r_a0a3e39d2d1306afddf277fd3fca9aebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a3e39d2d1306afddf277fd3fca9aebb">addrspacesMayAlias</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">AS0</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">AS1</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0a3e39d2d1306afddf277fd3fca9aebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return false if a <code>AS0</code> address cannot possibly alias a <code>AS1</code> address.  <br /></td></tr>
<tr class="separator:a0a3e39d2d1306afddf277fd3fca9aebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e74cc1819ce2f8f151a1900284ce89" id="r_a93e74cc1819ce2f8f151a1900284ce89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93e74cc1819ce2f8f151a1900284ce89">getFlatAddressSpace</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a93e74cc1819ce2f8f151a1900284ce89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address space ID for a target's 'flat' address space.  <br /></td></tr>
<tr class="separator:a93e74cc1819ce2f8f151a1900284ce89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7313158dcc10a1569a2333c78cde8621" id="r_a7313158dcc10a1569a2333c78cde8621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7313158dcc10a1569a2333c78cde8621">collectFlatAddressOperands</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int &gt; &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">OpIndexes</a>, <a class="el" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a> IID) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7313158dcc10a1569a2333c78cde8621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return any intrinsic address operand indexes which may be rewritten if they use a flat address space pointer.  <br /></td></tr>
<tr class="separator:a7313158dcc10a1569a2333c78cde8621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c845c07da9fd93a05ec29509486166" id="r_a50c845c07da9fd93a05ec29509486166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50c845c07da9fd93a05ec29509486166">isNoopAddrSpaceCast</a> (<a class="el" href="classunsigned.html">unsigned</a> FromAS, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ToAS</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a50c845c07da9fd93a05ec29509486166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ca9af33d7674947e80df6bd7e22758" id="r_a68ca9af33d7674947e80df6bd7e22758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68ca9af33d7674947e80df6bd7e22758">canHaveNonUndefGlobalInitializerInAddressSpace</a> (<a class="el" href="classunsigned.html">unsigned</a> AS) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a68ca9af33d7674947e80df6bd7e22758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if globals in this address space can have initializers other than <code>undef</code>.  <br /></td></tr>
<tr class="separator:a68ca9af33d7674947e80df6bd7e22758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf8eeaf9756076f0eea55ab20adf4bc" id="r_a1bf8eeaf9756076f0eea55ab20adf4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bf8eeaf9756076f0eea55ab20adf4bc">getAssumedAddrSpace</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *V) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a1bf8eeaf9756076f0eea55ab20adf4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba50f0bbbe7b4ae53a66e70c614cce2" id="r_a3ba50f0bbbe7b4ae53a66e70c614cce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ba50f0bbbe7b4ae53a66e70c614cce2">isSingleThreaded</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a3ba50f0bbbe7b4ae53a66e70c614cce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa721827d7115203f1eb5a3479e7d5e" id="r_a5aa721827d7115203f1eb5a3479e7d5e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5aa721827d7115203f1eb5a3479e7d5e">getPredicatedAddrSpace</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *V) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a5aa721827d7115203f1eb5a3479e7d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bd45e10d1f1069da1b4d216d0f5f73" id="r_a88bd45e10d1f1069da1b4d216d0f5f73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88bd45e10d1f1069da1b4d216d0f5f73">rewriteIntrinsicWithAddressSpace</a> (<a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *II, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">OldV</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">NewV</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a88bd45e10d1f1069da1b4d216d0f5f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite intrinsic call <code>II</code> such that <code>OldV</code> will be replaced with <code>NewV</code>, which has a different address space.  <br /></td></tr>
<tr class="separator:a88bd45e10d1f1069da1b4d216d0f5f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b08fb48c8c58e63aa231a1099475d9" id="r_aa8b08fb48c8c58e63aa231a1099475d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8b08fb48c8c58e63aa231a1099475d9">isLoweredToCall</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa8b08fb48c8c58e63aa231a1099475d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether calls to a function lower to actual program function calls.  <br /></td></tr>
<tr class="separator:aa8b08fb48c8c58e63aa231a1099475d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f5cd1eed2a2102d7a012dbc5c08e1a" id="r_a25f5cd1eed2a2102d7a012dbc5c08e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25f5cd1eed2a2102d7a012dbc5c08e1a">getUnrollingPreferences</a> (<a class="el" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html">UnrollingPreferences</a> &amp;UP, <a class="el" href="classllvm_1_1OptimizationRemarkEmitter.html">OptimizationRemarkEmitter</a> *ORE) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a25f5cd1eed2a2102d7a012dbc5c08e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target-customized preferences for the generic loop unrolling transformation.  <br /></td></tr>
<tr class="separator:a25f5cd1eed2a2102d7a012dbc5c08e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae1d7de61213a91194e93174081ab4d" id="r_aaae1d7de61213a91194e93174081ab4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaae1d7de61213a91194e93174081ab4d">isHardwareLoopProfitable</a> (<a class="el" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> &amp;AC, <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *LibInfo, <a class="el" href="structllvm_1_1HardwareLoopInfo.html">HardwareLoopInfo</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">HWLoopInfo</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aaae1d7de61213a91194e93174081ab4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target whether it would be profitable to convert the given loop into a hardware loop.  <br /></td></tr>
<tr class="separator:aaae1d7de61213a91194e93174081ab4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae953310cea2ff4ae78d8fcf9269f9259" id="r_ae953310cea2ff4ae78d8fcf9269f9259"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae953310cea2ff4ae78d8fcf9269f9259">preferPredicateOverEpilogue</a> (<a class="el" href="structllvm_1_1TailFoldingInfo.html">TailFoldingInfo</a> *TFI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae953310cea2ff4ae78d8fcf9269f9259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target whether it would be prefered to create a predicated vector loop, which can avoid the need to emit a scalar epilogue loop.  <br /></td></tr>
<tr class="separator:ae953310cea2ff4ae78d8fcf9269f9259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579a550a75fcdd6ebdb773fb2efd10de" id="r_a579a550a75fcdd6ebdb773fb2efd10de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacellvm.html#ada31142763d41520644d228c139a4bdd">TailFoldingStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a579a550a75fcdd6ebdb773fb2efd10de">getPreferredTailFoldingStyle</a> (<a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IVUpdateMayOverflow</a>=<a class="el" href="BasicAliasAnalysis_8cpp.html#af6d5cafbdfc5313e65d990120021a3ec">true</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a579a550a75fcdd6ebdb773fb2efd10de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the target what the preferred style of tail folding is.  <br /></td></tr>
<tr class="separator:a579a550a75fcdd6ebdb773fb2efd10de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af513fb5e9b4731b5b8315d757d5a252f" id="r_af513fb5e9b4731b5b8315d757d5a252f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af513fb5e9b4731b5b8315d757d5a252f">getPeelingPreferences</a> (<a class="el" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1PeelingPreferences.html">PeelingPreferences</a> &amp;PP) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af513fb5e9b4731b5b8315d757d5a252f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target-customized preferences for the generic loop peeling transformation.  <br /></td></tr>
<tr class="separator:af513fb5e9b4731b5b8315d757d5a252f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c34992cf5a6125fc637fbde99b88890" id="r_a2c34992cf5a6125fc637fbde99b88890"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c34992cf5a6125fc637fbde99b88890">instCombineIntrinsic</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, <a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> &amp;II) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a2c34992cf5a6125fc637fbde99b88890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Targets can implement their own combinations for target-specific intrinsics.  <br /></td></tr>
<tr class="separator:a2c34992cf5a6125fc637fbde99b88890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17fdac44c73248d9e36df4fd8d93b28" id="r_ac17fdac44c73248d9e36df4fd8d93b28"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac17fdac44c73248d9e36df4fd8d93b28">simplifyDemandedUseBitsIntrinsic</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, <a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> &amp;II, <a class="el" href="classllvm_1_1APInt.html">APInt</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">DemandedMask</a>, <a class="el" href="structllvm_1_1KnownBits.html">KnownBits</a> &amp;Known, <a class="el" href="classbool.html">bool</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">KnownBitsComputed</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac17fdac44c73248d9e36df4fd8d93b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to implement target-specific instruction combining.  <br /></td></tr>
<tr class="separator:ac17fdac44c73248d9e36df4fd8d93b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c63492d1e619b740c6e6d123efeb4f8" id="r_a3c63492d1e619b740c6e6d123efeb4f8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c63492d1e619b740c6e6d123efeb4f8">simplifyDemandedVectorEltsIntrinsic</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, <a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> &amp;II, <a class="el" href="classllvm_1_1APInt.html">APInt</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">DemandedElts</a>, <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">UndefElts</a>, <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">UndefElts2</a>, <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">UndefElts3</a>, std::function&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">void</a>(<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *, <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classllvm_1_1APInt.html">APInt</a>, <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;)&gt; <a class="el" href="classllvm_1_1ilist__node__impl.html">SimplifyAndSetOp</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a3c63492d1e619b740c6e6d123efeb4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to implement target-specific instruction combining.  <br /></td></tr>
<tr class="separator:a3c63492d1e619b740c6e6d123efeb4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Scalar Target Information</h2></td></tr>
<tr class="memitem:aa4c17e89b1ef061ed69f42b7cee93dbe" id="r_aa4c17e89b1ef061ed69f42b7cee93dbe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbe">PopcntSupportKind</a> { <a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbea0ce99a3a4fe2b7f2771a7b288a99ed2c">PSK_Software</a>
, <a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbea01deb9d0bc6399399b0d8377bd09201d">PSK_SlowHardware</a>
, <a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbeac71465fd61f1ba8aa2c7c397722b5e05">PSK_FastHardware</a>
 }</td></tr>
<tr class="memdesc:aa4c17e89b1ef061ed69f42b7cee93dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags indicating the kind of support for population count.  <a href="#aa4c17e89b1ef061ed69f42b7cee93dbe">More...</a><br /></td></tr>
<tr class="separator:aa4c17e89b1ef061ed69f42b7cee93dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88649498463e1fe02380ad98886ce43" id="r_ad88649498463e1fe02380ad98886ce43"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad88649498463e1fe02380ad98886ce43">AddressingModeKind</a> { <a class="el" href="#ad88649498463e1fe02380ad98886ce43a7cb26b7792c751612e634c36dce16f9a">AMK_PreIndexed</a>
, <a class="el" href="#ad88649498463e1fe02380ad98886ce43a0e72bd25d3608a66eac09e4cfbb7c658">AMK_PostIndexed</a>
, <a class="el" href="#ad88649498463e1fe02380ad98886ce43afcb500aacd74955fc04edc890f5e5d1a">AMK_None</a>
 }</td></tr>
<tr class="separator:ad88649498463e1fe02380ad98886ce43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5c32f4b5bd13b1279016cd9a6db37b" id="r_a7f5c32f4b5bd13b1279016cd9a6db37b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f5c32f4b5bd13b1279016cd9a6db37b">isLegalAddImmediate</a> (int64_t Imm) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7f5c32f4b5bd13b1279016cd9a6db37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified immediate is legal add immediate, that is the target has add instructions which can add a register with the immediate without having to materialize the immediate into a register.  <br /></td></tr>
<tr class="separator:a7f5c32f4b5bd13b1279016cd9a6db37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ff38d597ee5f9da28bb64c812520d8" id="r_a78ff38d597ee5f9da28bb64c812520d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78ff38d597ee5f9da28bb64c812520d8">isLegalICmpImmediate</a> (int64_t Imm) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a78ff38d597ee5f9da28bb64c812520d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified immediate is legal icmp immediate, that is the target has icmp instructions which can compare a register against the immediate without having to materialize the immediate into a register.  <br /></td></tr>
<tr class="separator:a78ff38d597ee5f9da28bb64c812520d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c84ca19e254840865cd33cc5aaedb81" id="r_a5c84ca19e254840865cd33cc5aaedb81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c84ca19e254840865cd33cc5aaedb81">isLegalAddressingMode</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *BaseGV, int64_t BaseOffset, <a class="el" href="classbool.html">bool</a> HasBaseReg, int64_t Scale, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace=0, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5c84ca19e254840865cd33cc5aaedb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the addressing mode represented by AM is legal for this target, for a load/store of the specified type.  <br /></td></tr>
<tr class="separator:a5c84ca19e254840865cd33cc5aaedb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d57a8095a918e8a7ebe31f964c16bbe" id="r_a1d57a8095a918e8a7ebe31f964c16bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d57a8095a918e8a7ebe31f964c16bbe">isLSRCostLess</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1TargetTransformInfo_1_1LSRCost.html">TargetTransformInfo::LSRCost</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">C1</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1TargetTransformInfo_1_1LSRCost.html">TargetTransformInfo::LSRCost</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">C2</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a1d57a8095a918e8a7ebe31f964c16bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if LSR cost of C1 is lower than C2.  <br /></td></tr>
<tr class="separator:a1d57a8095a918e8a7ebe31f964c16bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb09869158c4446f417427d102199632" id="r_acb09869158c4446f417427d102199632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb09869158c4446f417427d102199632">isNumRegsMajorCostOfLSR</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:acb09869158c4446f417427d102199632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if LSR major cost is number of registers.  <br /></td></tr>
<tr class="separator:acb09869158c4446f417427d102199632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5b11c76ffc12a4dde038d77dc4d5ae" id="r_a2c5b11c76ffc12a4dde038d77dc4d5ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c5b11c76ffc12a4dde038d77dc4d5ae">isProfitableLSRChainElement</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a2c5b11c76ffc12a4dde038d77dc4d5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5711c8e7ef4d1848c44e839242316c3" id="r_ad5711c8e7ef4d1848c44e839242316c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5711c8e7ef4d1848c44e839242316c3">canMacroFuseCmp</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad5711c8e7ef4d1848c44e839242316c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target can fuse a compare and branch.  <br /></td></tr>
<tr class="separator:ad5711c8e7ef4d1848c44e839242316c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884326e08a0f3d72b4f5006cf31eb76f" id="r_a884326e08a0f3d72b4f5006cf31eb76f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a884326e08a0f3d72b4f5006cf31eb76f">canSaveCmp</a> (<a class="el" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="el" href="classllvm_1_1BranchInst.html">BranchInst</a> **BI, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE, <a class="el" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *LI, <a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT, <a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *AC, <a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *LibInfo) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a884326e08a0f3d72b4f5006cf31eb76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target can save a compare for loop count, for example hardware loop saves a compare.  <br /></td></tr>
<tr class="separator:a884326e08a0f3d72b4f5006cf31eb76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89a5a037e90eef4edcffea07a423748" id="r_aa89a5a037e90eef4edcffea07a423748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad88649498463e1fe02380ad98886ce43">AddressingModeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa89a5a037e90eef4edcffea07a423748">getPreferredAddressingMode</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa89a5a037e90eef4edcffea07a423748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the preferred addressing mode LSR should make efforts to generate.  <br /></td></tr>
<tr class="separator:aa89a5a037e90eef4edcffea07a423748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bcc7733985bba3ab58e5c2abbc129e" id="r_ab9bcc7733985bba3ab58e5c2abbc129e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9bcc7733985bba3ab58e5c2abbc129e">isLegalMaskedStore</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab9bcc7733985bba3ab58e5c2abbc129e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked store.  <br /></td></tr>
<tr class="separator:ab9bcc7733985bba3ab58e5c2abbc129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5a70644f05b7731348861016ff2af1" id="r_aff5a70644f05b7731348861016ff2af1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff5a70644f05b7731348861016ff2af1">isLegalMaskedLoad</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aff5a70644f05b7731348861016ff2af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked load.  <br /></td></tr>
<tr class="separator:aff5a70644f05b7731348861016ff2af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923b761c973df44658c12ab18b29365c" id="r_a923b761c973df44658c12ab18b29365c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a923b761c973df44658c12ab18b29365c">isLegalNTStore</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a923b761c973df44658c12ab18b29365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports nontemporal store.  <br /></td></tr>
<tr class="separator:a923b761c973df44658c12ab18b29365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdad414050f44dd51fe2c193b7992b6" id="r_a7bdad414050f44dd51fe2c193b7992b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bdad414050f44dd51fe2c193b7992b6">isLegalNTLoad</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7bdad414050f44dd51fe2c193b7992b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports nontemporal load.  <br /></td></tr>
<tr class="separator:a7bdad414050f44dd51fe2c193b7992b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6b14ee0f0d259ea09d847875be536f" id="r_a5a6b14ee0f0d259ea09d847875be536f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a6b14ee0f0d259ea09d847875be536f">isLegalBroadcastLoad</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *ElementTy, <a class="el" href="classllvm_1_1ElementCount.html">ElementCount</a> NumElements) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5a6b14ee0f0d259ea09d847875be536f"><td class="mdescLeft">&#160;</td><td class="mdescRight">\Returns true if the target supports broadcasting a load to a vector of type &lt;NumElements x ElementTy&gt;.  <br /></td></tr>
<tr class="separator:a5a6b14ee0f0d259ea09d847875be536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a973aabc3b5429e5e05beee35892de0" id="r_a0a973aabc3b5429e5e05beee35892de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a973aabc3b5429e5e05beee35892de0">isLegalMaskedScatter</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0a973aabc3b5429e5e05beee35892de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked scatter.  <br /></td></tr>
<tr class="separator:a0a973aabc3b5429e5e05beee35892de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac7704be5bd5455f78caf0b5371012" id="r_a33ac7704be5bd5455f78caf0b5371012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33ac7704be5bd5455f78caf0b5371012">isLegalMaskedGather</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a33ac7704be5bd5455f78caf0b5371012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked gather.  <br /></td></tr>
<tr class="separator:a33ac7704be5bd5455f78caf0b5371012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661bd4bd069ee48ef7bf8a7892790468" id="r_a661bd4bd069ee48ef7bf8a7892790468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a661bd4bd069ee48ef7bf8a7892790468">forceScalarizeMaskedGather</a> (<a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *<a class="el" href="classllvm_1_1Type.html">Type</a>, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a661bd4bd069ee48ef7bf8a7892790468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target forces scalarizing of llvm.masked.gather intrinsics.  <br /></td></tr>
<tr class="separator:a661bd4bd069ee48ef7bf8a7892790468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebda4a819a6130c6c0f37a8b05dfac67" id="r_aebda4a819a6130c6c0f37a8b05dfac67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebda4a819a6130c6c0f37a8b05dfac67">forceScalarizeMaskedScatter</a> (<a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *<a class="el" href="classllvm_1_1Type.html">Type</a>, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aebda4a819a6130c6c0f37a8b05dfac67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target forces scalarizing of llvm.masked.scatter intrinsics.  <br /></td></tr>
<tr class="separator:aebda4a819a6130c6c0f37a8b05dfac67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f71d89b22106738d72d963725f0860" id="r_a78f71d89b22106738d72d963725f0860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78f71d89b22106738d72d963725f0860">isLegalMaskedCompressStore</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a78f71d89b22106738d72d963725f0860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked compress store.  <br /></td></tr>
<tr class="separator:a78f71d89b22106738d72d963725f0860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa143359355225ce76a666b1758bb2d3d" id="r_aa143359355225ce76a666b1758bb2d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa143359355225ce76a666b1758bb2d3d">isLegalMaskedExpandLoad</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa143359355225ce76a666b1758bb2d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target supports masked expand load.  <br /></td></tr>
<tr class="separator:aa143359355225ce76a666b1758bb2d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae67acb89326f200683e3d0b872a5329" id="r_aae67acb89326f200683e3d0b872a5329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae67acb89326f200683e3d0b872a5329">isLegalAltInstr</a> (<a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">Opcode0</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">Opcode1</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SmallBitVector.html">SmallBitVector</a> &amp;OpcodeMask) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aae67acb89326f200683e3d0b872a5329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an alternating opcode pattern that can be lowered to a single instruction on the target.  <br /></td></tr>
<tr class="separator:aae67acb89326f200683e3d0b872a5329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e034d813ec5b7818252ac121d20a5aa" id="r_a3e034d813ec5b7818252ac121d20a5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e034d813ec5b7818252ac121d20a5aa">enableOrderedReductions</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a3e034d813ec5b7818252ac121d20a5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we should be enabling ordered reductions for the target.  <br /></td></tr>
<tr class="separator:a3e034d813ec5b7818252ac121d20a5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31bf22f119c5a99c36646d8e0eb2c0f" id="r_ac31bf22f119c5a99c36646d8e0eb2c0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac31bf22f119c5a99c36646d8e0eb2c0f">hasDivRemOp</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *DataType, <a class="el" href="classbool.html">bool</a> IsSigned) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac31bf22f119c5a99c36646d8e0eb2c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the target has a unified operation to calculate division and remainder.  <br /></td></tr>
<tr class="separator:ac31bf22f119c5a99c36646d8e0eb2c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33e1370498d06e0760c2861ff25e43a" id="r_ab33e1370498d06e0760c2861ff25e43a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab33e1370498d06e0760c2861ff25e43a">hasVolatileVariant</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab33e1370498d06e0760c2861ff25e43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given instruction (assumed to be a memory access instruction) has a volatile variant.  <br /></td></tr>
<tr class="separator:ab33e1370498d06e0760c2861ff25e43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215ea3605f88c5b21ffbdf76a72a8554" id="r_a215ea3605f88c5b21ffbdf76a72a8554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a215ea3605f88c5b21ffbdf76a72a8554">prefersVectorizedAddressing</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a215ea3605f88c5b21ffbdf76a72a8554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if target doesn't mind addresses in vectors.  <br /></td></tr>
<tr class="separator:a215ea3605f88c5b21ffbdf76a72a8554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886c5c16f6fb41c44e57b24543f0dc7d" id="r_a886c5c16f6fb41c44e57b24543f0dc7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a886c5c16f6fb41c44e57b24543f0dc7d">getScalingFactorCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *BaseGV, int64_t BaseOffset, <a class="el" href="classbool.html">bool</a> HasBaseReg, int64_t Scale, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace=0) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a886c5c16f6fb41c44e57b24543f0dc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cost of the scaling factor used in the addressing mode represented by AM for this target, for a load/store of the specified type.  <br /></td></tr>
<tr class="separator:a886c5c16f6fb41c44e57b24543f0dc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4746d964f754f53ce75d48a418196674" id="r_a4746d964f754f53ce75d48a418196674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4746d964f754f53ce75d48a418196674">LSRWithInstrQueries</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a4746d964f754f53ce75d48a418196674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the loop strength reduce pass should make Instruction* based TTI queries to <a class="el" href="#a5c84ca19e254840865cd33cc5aaedb81" title="Return true if the addressing mode represented by AM is legal for this target, for a load/store of th...">isLegalAddressingMode()</a>.  <br /></td></tr>
<tr class="separator:a4746d964f754f53ce75d48a418196674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e55cf13c60a8b90145f1411367b975" id="r_ae3e55cf13c60a8b90145f1411367b975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3e55cf13c60a8b90145f1411367b975">isTruncateFree</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Ty1</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Ty2</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae3e55cf13c60a8b90145f1411367b975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it's free to truncate a value of type Ty1 to type Ty2.  <br /></td></tr>
<tr class="separator:ae3e55cf13c60a8b90145f1411367b975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcbf4e3010950dd8ea0be1c4b0d3281" id="r_aafcbf4e3010950dd8ea0be1c4b0d3281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafcbf4e3010950dd8ea0be1c4b0d3281">isProfitableToHoist</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aafcbf4e3010950dd8ea0be1c4b0d3281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is profitable to hoist instruction in the then/else to before if.  <br /></td></tr>
<tr class="separator:aafcbf4e3010950dd8ea0be1c4b0d3281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98deb6721fb0ac45c41f71b800700596" id="r_a98deb6721fb0ac45c41f71b800700596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98deb6721fb0ac45c41f71b800700596">useAA</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a98deb6721fb0ac45c41f71b800700596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a84209b8495d8fd3d2799eb01f1ab2b" id="r_a7a84209b8495d8fd3d2799eb01f1ab2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a84209b8495d8fd3d2799eb01f1ab2b">isTypeLegal</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a7a84209b8495d8fd3d2799eb01f1ab2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this type is legal.  <br /></td></tr>
<tr class="separator:a7a84209b8495d8fd3d2799eb01f1ab2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6989eb41033f67be080858c27d840a" id="r_a5a6989eb41033f67be080858c27d840a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a6989eb41033f67be080858c27d840a">getRegUsageForType</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5a6989eb41033f67be080858c27d840a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the estimated number of registers required to represent <code>Ty</code>.  <br /></td></tr>
<tr class="separator:a5a6989eb41033f67be080858c27d840a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5b47e1f017620a784b726852915d58" id="r_a0d5b47e1f017620a784b726852915d58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d5b47e1f017620a784b726852915d58">shouldBuildLookupTables</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a0d5b47e1f017620a784b726852915d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if switches should be turned into lookup tables for the target.  <br /></td></tr>
<tr class="separator:a0d5b47e1f017620a784b726852915d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265e334c170d96e5cbcf8b420db520d4" id="r_a265e334c170d96e5cbcf8b420db520d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a265e334c170d96e5cbcf8b420db520d4">shouldBuildLookupTablesForConstant</a> (<a class="el" href="classllvm_1_1Constant.html">Constant</a> *<a class="el" href="namespacellvm_1_1CallingConv.html#aece6fe9908ef98302dd0e85e4d7fa535afd841a49aec1539bc88abc8ff9e170fb">C</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a265e334c170d96e5cbcf8b420db520d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if switches should be turned into lookup tables containing this constant value for the target.  <br /></td></tr>
<tr class="separator:a265e334c170d96e5cbcf8b420db520d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb1dfc8333359b25dda0d8cbef24e4a" id="r_abcb1dfc8333359b25dda0d8cbef24e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcb1dfc8333359b25dda0d8cbef24e4a">shouldBuildRelLookupTables</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:abcb1dfc8333359b25dda0d8cbef24e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if lookup tables should be turned into relative lookup tables.  <br /></td></tr>
<tr class="separator:abcb1dfc8333359b25dda0d8cbef24e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30e432e7796aa46c87440cb54de2243" id="r_ad30e432e7796aa46c87440cb54de2243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad30e432e7796aa46c87440cb54de2243">useColdCCForColdCall</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> &amp;<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad30e432e7796aa46c87440cb54de2243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the input function which is cold at all call sites, should use coldcc calling convention.  <br /></td></tr>
<tr class="separator:ad30e432e7796aa46c87440cb54de2243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fe2d1bb4f708d68fe7a908ba675d1b" id="r_ae7fe2d1bb4f708d68fe7a908ba675d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7fe2d1bb4f708d68fe7a908ba675d1b">getScalarizationOverhead</a> (<a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *Ty, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">DemandedElts</a>, <a class="el" href="classbool.html">bool</a> Insert, <a class="el" href="classbool.html">bool</a> Extract, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ae7fe2d1bb4f708d68fe7a908ba675d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the overhead of scalarizing an instruction.  <br /></td></tr>
<tr class="separator:ae7fe2d1bb4f708d68fe7a908ba675d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296acd14b143ce1e1b0db86f4c221662" id="r_a296acd14b143ce1e1b0db86f4c221662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a296acd14b143ce1e1b0db86f4c221662">getOperandsScalarizationOverhead</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; Args, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; <a class="el" href="classllvm_1_1ilist__node__impl.html">Tys</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a296acd14b143ce1e1b0db86f4c221662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the overhead of scalarizing an instructions unique non-constant operands.  <br /></td></tr>
<tr class="separator:a296acd14b143ce1e1b0db86f4c221662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af0805a1dd7afabb0aa6cc1832b5011" id="r_a1af0805a1dd7afabb0aa6cc1832b5011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1af0805a1dd7afabb0aa6cc1832b5011">supportsEfficientVectorElementLoadStore</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a1af0805a1dd7afabb0aa6cc1832b5011"><td class="mdescLeft">&#160;</td><td class="mdescRight">If target has efficient vector element load/store instructions, it can return true here so that insertion/extraction costs are not added to the scalarization cost of a load/store.  <br /></td></tr>
<tr class="separator:a1af0805a1dd7afabb0aa6cc1832b5011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d10c3084307035a3ae29cc2f420440" id="r_ad4d10c3084307035a3ae29cc2f420440"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4d10c3084307035a3ae29cc2f420440">supportsTailCalls</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad4d10c3084307035a3ae29cc2f420440"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the target supports tail calls.  <br /></td></tr>
<tr class="separator:ad4d10c3084307035a3ae29cc2f420440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c143ebdce9475bb57428828fe848e3a" id="r_a2c143ebdce9475bb57428828fe848e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c143ebdce9475bb57428828fe848e3a">supportsTailCallFor</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1CallBase.html">CallBase</a> *CB) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a2c143ebdce9475bb57428828fe848e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If target supports tail call on <code>CB</code>.  <br /></td></tr>
<tr class="separator:a2c143ebdce9475bb57428828fe848e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f25864d2ad4955cb285d871a36345b" id="r_a12f25864d2ad4955cb285d871a36345b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12f25864d2ad4955cb285d871a36345b">enableAggressiveInterleaving</a> (<a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">LoopHasReductions</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a12f25864d2ad4955cb285d871a36345b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't restrict interleaved unrolling to small loops.  <br /></td></tr>
<tr class="separator:a12f25864d2ad4955cb285d871a36345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24629c2792a37162cf0ef4b1c38ba00c" id="r_a24629c2792a37162cf0ef4b1c38ba00c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1MemCmpExpansionOptions.html">MemCmpExpansionOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24629c2792a37162cf0ef4b1c38ba00c">enableMemCmpExpansion</a> (<a class="el" href="classbool.html">bool</a> OptSize, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsZeroCmp</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a24629c2792a37162cf0ef4b1c38ba00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72110d5a1a43e21651a36bd96cfdec98" id="r_a72110d5a1a43e21651a36bd96cfdec98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72110d5a1a43e21651a36bd96cfdec98">enableSelectOptimize</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a72110d5a1a43e21651a36bd96cfdec98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should the Select Optimization pass be enabled and ran.  <br /></td></tr>
<tr class="separator:a72110d5a1a43e21651a36bd96cfdec98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac501bf52c07df51c9e1242117cfc7b2f" id="r_ac501bf52c07df51c9e1242117cfc7b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac501bf52c07df51c9e1242117cfc7b2f">enableInterleavedAccessVectorization</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac501bf52c07df51c9e1242117cfc7b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable matching of interleaved access groups.  <br /></td></tr>
<tr class="separator:ac501bf52c07df51c9e1242117cfc7b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0734de892207738014317d233c72ad" id="r_a6b0734de892207738014317d233c72ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b0734de892207738014317d233c72ad">enableMaskedInterleavedAccessVectorization</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6b0734de892207738014317d233c72ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable matching of interleaved access groups that contain predicated accesses or gaps and therefore vectorized using masked vector loads/stores.  <br /></td></tr>
<tr class="separator:a6b0734de892207738014317d233c72ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75d51988243f8ea9086b110401f8758" id="r_ab75d51988243f8ea9086b110401f8758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab75d51988243f8ea9086b110401f8758">isFPVectorizationPotentiallyUnsafe</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ab75d51988243f8ea9086b110401f8758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that it is potentially unsafe to automatically vectorize floating-point operations because the semantics of vector and scalar floating-point semantics may differ.  <br /></td></tr>
<tr class="separator:ab75d51988243f8ea9086b110401f8758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e737ae000f542eba6ebc679637144d9" id="r_a9e737ae000f542eba6ebc679637144d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e737ae000f542eba6ebc679637144d9">allowsMisalignedMemoryAccesses</a> (<a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;Context, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#abee0df5f7f703bb4462aba260ba0a60f">BitWidth</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>=0, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment=<a class="el" href="structllvm_1_1Align.html">Align</a>(1), <a class="el" href="classunsigned.html">unsigned</a> *<a class="el" href="namespacellvm_1_1CallingConv.html#aece6fe9908ef98302dd0e85e4d7fa535abc8e2ee40a84687a9e12fd08784b87ba">Fast</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a9e737ae000f542eba6ebc679637144d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the target supports unaligned memory accesses.  <br /></td></tr>
<tr class="separator:a9e737ae000f542eba6ebc679637144d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6480799b120b617b9b34f1313afe6661" id="r_a6480799b120b617b9b34f1313afe6661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbe">PopcntSupportKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6480799b120b617b9b34f1313afe6661">getPopcntSupport</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IntTyWidthInBit</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6480799b120b617b9b34f1313afe6661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return hardware support for population count.  <br /></td></tr>
<tr class="separator:a6480799b120b617b9b34f1313afe6661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef998bb15ea045fc769232b62ad0d968" id="r_aef998bb15ea045fc769232b62ad0d968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef998bb15ea045fc769232b62ad0d968">haveFastSqrt</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aef998bb15ea045fc769232b62ad0d968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the hardware has a fast square-root instruction.  <br /></td></tr>
<tr class="separator:aef998bb15ea045fc769232b62ad0d968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30646d63c1f1ca132d37dff17cf5daae" id="r_a30646d63c1f1ca132d37dff17cf5daae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30646d63c1f1ca132d37dff17cf5daae">isExpensiveToSpeculativelyExecute</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a30646d63c1f1ca132d37dff17cf5daae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the cost of the instruction is too high to speculatively execute and should be kept behind a branch.  <br /></td></tr>
<tr class="separator:a30646d63c1f1ca132d37dff17cf5daae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199e3382d45514816f88cb65310decb4" id="r_a199e3382d45514816f88cb65310decb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a199e3382d45514816f88cb65310decb4">isFCmpOrdCheaperThanFCmpZero</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a199e3382d45514816f88cb65310decb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is faster to check if a floating-point value is NaN (or not-NaN) versus a comparison against a constant FP zero value.  <br /></td></tr>
<tr class="separator:a199e3382d45514816f88cb65310decb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b0e7df7704fa34e356e1178374b49e" id="r_ad3b0e7df7704fa34e356e1178374b49e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3b0e7df7704fa34e356e1178374b49e">getFPOpCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ad3b0e7df7704fa34e356e1178374b49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected cost of supporting the floating point operation of the specified type.  <br /></td></tr>
<tr class="separator:ad3b0e7df7704fa34e356e1178374b49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f708e28c4cf4fcdbbe363849b779a00" id="r_a8f708e28c4cf4fcdbbe363849b779a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f708e28c4cf4fcdbbe363849b779a00">getIntImmCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Imm, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a8f708e28c4cf4fcdbbe363849b779a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected cost of materializing for the given integer immediate of the specified type.  <br /></td></tr>
<tr class="separator:a8f708e28c4cf4fcdbbe363849b779a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5798a479ce88e66e1b53d70d678332" id="r_a6c5798a479ce88e66e1b53d70d678332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c5798a479ce88e66e1b53d70d678332">getIntImmCostInst</a> (<a class="el" href="classunsigned.html">unsigned</a> Opc, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="DeadArgumentElimination_8cpp.html#a39a491a969849f634027f20be70a5c57">Idx</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Imm, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *Inst=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a6c5798a479ce88e66e1b53d70d678332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected cost of materialization for the given integer immediate of the specified type for a given instruction.  <br /></td></tr>
<tr class="separator:a6c5798a479ce88e66e1b53d70d678332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abe636878bffb348ed313016ab1c21b" id="r_a6abe636878bffb348ed313016ab1c21b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6abe636878bffb348ed313016ab1c21b">getIntImmCostIntrin</a> (<a class="el" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a> IID, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="DeadArgumentElimination_8cpp.html#a39a491a969849f634027f20be70a5c57">Idx</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Imm, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a6abe636878bffb348ed313016ab1c21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8771f57e56c0bc0e9ace92ede634839" id="r_aa8771f57e56c0bc0e9ace92ede634839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8771f57e56c0bc0e9ace92ede634839">getIntImmCodeSizeCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opc, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="DeadArgumentElimination_8cpp.html#a39a491a969849f634027f20be70a5c57">Idx</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Imm, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:aa8771f57e56c0bc0e9ace92ede634839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected cost for the given integer when optimising for size.  <br /></td></tr>
<tr class="separator:aa8771f57e56c0bc0e9ace92ede634839"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Vector Target Information</h2></td></tr>
<tr class="memitem:af46433d0e36d3f80afc3a8c67b5c53ec" id="r_af46433d0e36d3f80afc3a8c67b5c53ec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ec">ShuffleKind</a> { <br />
&#160;&#160;<a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ecab1ac8982cdb119f39a5fe74610a46796">SK_Broadcast</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ecaea788d98147161f25d5adc3ec6ce7e1f">SK_Reverse</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53eca64d439485545faa793c20de7fbfd274c">SK_Select</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53eca7cc176c1463af0d9820e7981c32db478">SK_Transpose</a>
, <br />
&#160;&#160;<a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53eca466a4d581cf3a553414b9c2e889b944a">SK_InsertSubvector</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ecafd6c03f570400fcb24d861aa21ddffe9">SK_ExtractSubvector</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ecab4616961a3bfdaec42aedc4fc426ccfe">SK_PermuteTwoSrc</a>
, <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53eca7beec9815d0197f2d31fac9968e9205b">SK_PermuteSingleSrc</a>
, <br />
&#160;&#160;<a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ecaa9e18b2636661e341804da24971997df">SK_Splice</a>
<br />
 }</td></tr>
<tr class="memdesc:af46433d0e36d3f80afc3a8c67b5c53ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The various kinds of shuffle patterns for vector queries.  <a href="#af46433d0e36d3f80afc3a8c67b5c53ec">More...</a><br /></td></tr>
<tr class="separator:af46433d0e36d3f80afc3a8c67b5c53ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa38851d75434d1476444ac93f94cb4c" id="r_afa38851d75434d1476444ac93f94cb4c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa38851d75434d1476444ac93f94cb4c">OperandValueKind</a> { <a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a>
, <a class="el" href="#afa38851d75434d1476444ac93f94cb4ca7aa61d9e9d33bdf28478754c69c59640">OK_UniformValue</a>
, <a class="el" href="#afa38851d75434d1476444ac93f94cb4ca76d8855d96b8e66b9411ed74737ca8f7">OK_UniformConstantValue</a>
, <a class="el" href="#afa38851d75434d1476444ac93f94cb4cacf63326297610dfbedd0ad408b54e3e4">OK_NonUniformConstantValue</a>
 }</td></tr>
<tr class="memdesc:afa38851d75434d1476444ac93f94cb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional information about an operand's possible values.  <a href="#afa38851d75434d1476444ac93f94cb4c">More...</a><br /></td></tr>
<tr class="separator:afa38851d75434d1476444ac93f94cb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733fb237f3037c95ed59de6055b176c5" id="r_a733fb237f3037c95ed59de6055b176c5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a733fb237f3037c95ed59de6055b176c5">OperandValueProperties</a> { <a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a> = 0
, <a class="el" href="#a733fb237f3037c95ed59de6055b176c5a974f46ced0fd416db695ce5da6059dcc">OP_PowerOf2</a> = 1
, <a class="el" href="#a733fb237f3037c95ed59de6055b176c5a19af6b5f4f70eaefcc0b6734f1f06cd8">OP_NegatedPowerOf2</a> = 2
 }</td></tr>
<tr class="memdesc:a733fb237f3037c95ed59de6055b176c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional properties of an operand's values.  <a href="#a733fb237f3037c95ed59de6055b176c5">More...</a><br /></td></tr>
<tr class="separator:a733fb237f3037c95ed59de6055b176c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb3b1ccf19b8c85429b777dfa4a0166" id="r_a8bb3b1ccf19b8c85429b777dfa4a0166"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bb3b1ccf19b8c85429b777dfa4a0166">RegisterKind</a> { <a class="el" href="#a8bb3b1ccf19b8c85429b777dfa4a0166ad8f233645107107ed48d2e4a915152cc">RGK_Scalar</a>
, <a class="el" href="#a8bb3b1ccf19b8c85429b777dfa4a0166a183020fbea95c99db23f6d3594f4c4af">RGK_FixedWidthVector</a>
, <a class="el" href="#a8bb3b1ccf19b8c85429b777dfa4a0166a331413d3887a08546d0973091f6a4993">RGK_ScalableVector</a>
 }</td></tr>
<tr class="separator:a8bb3b1ccf19b8c85429b777dfa4a0166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbde4c30736df440ecdeee35a0608f6b" id="r_afbde4c30736df440ecdeee35a0608f6b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">CacheLevel</a> { <a class="el" href="#afbde4c30736df440ecdeee35a0608f6ba4ea39ed13dabbda09e2782f5529eb1ac">L1D</a>
, <a class="el" href="#afbde4c30736df440ecdeee35a0608f6baecc9f58d2b1c17e94659be202c01b55b">L2D</a>
 }</td></tr>
<tr class="memdesc:afbde4c30736df440ecdeee35a0608f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible cache levels.  <a href="#afbde4c30736df440ecdeee35a0608f6b">More...</a><br /></td></tr>
<tr class="separator:afbde4c30736df440ecdeee35a0608f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84cce349a77262269fd3f6756f37a64" id="r_af84cce349a77262269fd3f6756f37a64"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af84cce349a77262269fd3f6756f37a64">CastContextHint</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="#af84cce349a77262269fd3f6756f37a64a6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <a class="el" href="#af84cce349a77262269fd3f6756f37a64a960b44c579bc2f6818d2daaf9e4c16f0">Normal</a>
, <a class="el" href="#af84cce349a77262269fd3f6756f37a64a6864311f985d160ad4bd46a9fbe4a4d4">Masked</a>
, <a class="el" href="#af84cce349a77262269fd3f6756f37a64afc2e3edeec59afcdc10f55205713f14b">GatherScatter</a>
, <br />
&#160;&#160;<a class="el" href="#af84cce349a77262269fd3f6756f37a64ad392556b3674a98332cc2938ba0bfeb7">Interleave</a>
, <a class="el" href="#af84cce349a77262269fd3f6756f37a64a030aa94015bd11d183b897ddb541e4e3">Reversed</a>
<br />
 }</td></tr>
<tr class="memdesc:af84cce349a77262269fd3f6756f37a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a hint about the context in which a cast is used.  <a href="#af84cce349a77262269fd3f6756f37a64">More...</a><br /></td></tr>
<tr class="separator:af84cce349a77262269fd3f6756f37a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5cc8324c33cb1f59869456263f9f4b" id="r_acf5cc8324c33cb1f59869456263f9f4b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">MemIndexedMode</a> { <br />
&#160;&#160;<a class="el" href="#acf5cc8324c33cb1f59869456263f9f4ba24234938a33e357e0c86f1d71295a2f6">MIM_Unindexed</a>
, <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4baf049517e9a49117b5225ee67455f5dea">MIM_PreInc</a>
, <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4ba7367f3267f2bfe1a200655097784f4a1">MIM_PreDec</a>
, <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4ba3a471f30b7a193785b57c081776ad3cb">MIM_PostInc</a>
, <br />
&#160;&#160;<a class="el" href="#acf5cc8324c33cb1f59869456263f9f4ba57dbcb88640a74d04f7e0ddeefa76d1b">MIM_PostDec</a>
<br />
 }</td></tr>
<tr class="memdesc:acf5cc8324c33cb1f59869456263f9f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of load/store indexing.  <a href="#acf5cc8324c33cb1f59869456263f9f4b">More...</a><br /></td></tr>
<tr class="separator:acf5cc8324c33cb1f59869456263f9f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e8ca52658f54e5cc6214eb1a291ef" id="r_aae0e8ca52658f54e5cc6214eb1a291ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae0e8ca52658f54e5cc6214eb1a291ef">getNumberOfRegisters</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ClassID</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aae0e8ca52658f54e5cc6214eb1a291ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623cced59353f83cc5eaba4068c57694" id="r_a623cced59353f83cc5eaba4068c57694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a623cced59353f83cc5eaba4068c57694">getRegisterClassForType</a> (<a class="el" href="classbool.html">bool</a> <a class="el" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39a57dea6f5039281b7fee517fc43bf3110">Vector</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a623cced59353f83cc5eaba4068c57694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97503ae3ef00c5f1eaffa5bbeb0a4357" id="r_a97503ae3ef00c5f1eaffa5bbeb0a4357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97503ae3ef00c5f1eaffa5bbeb0a4357">getRegisterClassName</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ClassID</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a97503ae3ef00c5f1eaffa5bbeb0a4357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d30dd50c6b2d64ca3bc2826ca229fdb" id="r_a2d30dd50c6b2d64ca3bc2826ca229fdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1TypeSize.html">TypeSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d30dd50c6b2d64ca3bc2826ca229fdb">getRegisterBitWidth</a> (<a class="el" href="#a8bb3b1ccf19b8c85429b777dfa4a0166">RegisterKind</a> K) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a2d30dd50c6b2d64ca3bc2826ca229fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa8b3631e74e836453f972aac6b4b65" id="r_a8fa8b3631e74e836453f972aac6b4b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fa8b3631e74e836453f972aac6b4b65">getMinVectorRegisterBitWidth</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a8fa8b3631e74e836453f972aac6b4b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3586d4f687e1a068f879bf29b046eb3a" id="r_a3586d4f687e1a068f879bf29b046eb3a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3586d4f687e1a068f879bf29b046eb3a">getMaxVScale</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a3586d4f687e1a068f879bf29b046eb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04394f31b3d57c89fd8211783a12736d" id="r_a04394f31b3d57c89fd8211783a12736d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04394f31b3d57c89fd8211783a12736d">getVScaleForTuning</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a04394f31b3d57c89fd8211783a12736d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761a2a864705382c56d6406a6a97e6fc" id="r_a761a2a864705382c56d6406a6a97e6fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a761a2a864705382c56d6406a6a97e6fc">isVScaleKnownToBeAPowerOfTwo</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a761a2a864705382c56d6406a6a97e6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525b5174ebf7ac1db045dde5f579ddcb" id="r_a525b5174ebf7ac1db045dde5f579ddcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a525b5174ebf7ac1db045dde5f579ddcb">shouldMaximizeVectorBandwidth</a> (<a class="el" href="#a8bb3b1ccf19b8c85429b777dfa4a0166">TargetTransformInfo::RegisterKind</a> K) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a525b5174ebf7ac1db045dde5f579ddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a94a8710c9c41b64870559c9098f305" id="r_a6a94a8710c9c41b64870559c9098f305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ElementCount.html">ElementCount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a94a8710c9c41b64870559c9098f305">getMinimumVF</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ElemWidth</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsScalable</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a6a94a8710c9c41b64870559c9098f305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785bcc5cab17bd5d96f800247dad0649" id="r_a785bcc5cab17bd5d96f800247dad0649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a785bcc5cab17bd5d96f800247dad0649">getMaximumVF</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ElemWidth</a>, <a class="el" href="classunsigned.html">unsigned</a> Opcode) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a785bcc5cab17bd5d96f800247dad0649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf352ba0545cdb2ad70f4d72b594cfa" id="r_abdf352ba0545cdb2ad70f4d72b594cfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdf352ba0545cdb2ad70f4d72b594cfa">getStoreMinimumVF</a> (<a class="el" href="classunsigned.html">unsigned</a> VF, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">ScalarMemTy</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">ScalarValTy</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:abdf352ba0545cdb2ad70f4d72b594cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9880b7512930d879440db073b536d362" id="r_a9880b7512930d879440db073b536d362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9880b7512930d879440db073b536d362">shouldConsiderAddressTypePromotion</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classbool.html">bool</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">AllowPromotionWithoutCommonHeader</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a9880b7512930d879440db073b536d362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d04cbecfee76b1c4a5ea83aa6bb113c" id="r_a9d04cbecfee76b1c4a5ea83aa6bb113c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d04cbecfee76b1c4a5ea83aa6bb113c">getCacheLineSize</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a9d04cbecfee76b1c4a5ea83aa6bb113c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d6473c3ac48c1d2d9436408e6b9e82" id="r_ac0d6473c3ac48c1d2d9436408e6b9e82"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0d6473c3ac48c1d2d9436408e6b9e82">getCacheSize</a> (<a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">CacheLevel</a> Level) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ac0d6473c3ac48c1d2d9436408e6b9e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b210e7ba1c2c222ab9d01202a55f723" id="r_a7b210e7ba1c2c222ab9d01202a55f723"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b210e7ba1c2c222ab9d01202a55f723">getCacheAssociativity</a> (<a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">CacheLevel</a> Level) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a7b210e7ba1c2c222ab9d01202a55f723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3f3a3d549cf057479e744e7ecfd7e1" id="r_a1e3f3a3d549cf057479e744e7ecfd7e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e3f3a3d549cf057479e744e7ecfd7e1">getPrefetchDistance</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a1e3f3a3d549cf057479e744e7ecfd7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcadecc95e9e49f77a70ab8b99a8c35" id="r_a8dcadecc95e9e49f77a70ab8b99a8c35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dcadecc95e9e49f77a70ab8b99a8c35">getMinPrefetchStride</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">NumMemAccesses</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">NumStridedMemAccesses</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">NumPrefetches</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">HasCall</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a8dcadecc95e9e49f77a70ab8b99a8c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some HW prefetchers can handle accesses up to a certain constant stride.  <br /></td></tr>
<tr class="separator:a8dcadecc95e9e49f77a70ab8b99a8c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cb8d0f215f1b7b66e4a7d6581b3a16" id="r_a66cb8d0f215f1b7b66e4a7d6581b3a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66cb8d0f215f1b7b66e4a7d6581b3a16">getMaxPrefetchIterationsAhead</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a66cb8d0f215f1b7b66e4a7d6581b3a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec5838370bf4a0d0af43e443ee99325" id="r_a4ec5838370bf4a0d0af43e443ee99325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ec5838370bf4a0d0af43e443ee99325">enableWritePrefetching</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a4ec5838370bf4a0d0af43e443ee99325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4eb225c0b7b93c8b8e6c0de860fb5f" id="r_a8f4eb225c0b7b93c8b8e6c0de860fb5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f4eb225c0b7b93c8b8e6c0de860fb5f">shouldPrefetchAddressSpace</a> (<a class="el" href="classunsigned.html">unsigned</a> AS) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a8f4eb225c0b7b93c8b8e6c0de860fb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c60443d89e7ed0d199dfddafd5885f" id="r_ac8c60443d89e7ed0d199dfddafd5885f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8c60443d89e7ed0d199dfddafd5885f">getMaxInterleaveFactor</a> (<a class="el" href="classllvm_1_1ElementCount.html">ElementCount</a> VF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ac8c60443d89e7ed0d199dfddafd5885f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9679969ae87f8a08d5f6948be6cf7210" id="r_a9679969ae87f8a08d5f6948be6cf7210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9679969ae87f8a08d5f6948be6cf7210">getArithmeticInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1OperandValueInfo.html">TTI::OperandValueInfo</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">Opd1Info</a>={<a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">TTI::OK_AnyValue</a>, <a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">TTI::OP_None</a>}, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1OperandValueInfo.html">TTI::OperandValueInfo</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">Opd2Info</a>={<a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">TTI::OK_AnyValue</a>, <a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">TTI::OP_None</a>}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; Args=<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;(), <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a9679969ae87f8a08d5f6948be6cf7210"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an approximation of reciprocal throughput of a math/logic op.  <br /></td></tr>
<tr class="separator:a9679969ae87f8a08d5f6948be6cf7210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0519f26bcb15c25ac0ff557061fa7af" id="r_aa0519f26bcb15c25ac0ff557061fa7af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0519f26bcb15c25ac0ff557061fa7af">getShuffleCost</a> (<a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ec">ShuffleKind</a> Kind, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Tp</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt; Mask=std::nullopt, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, int <a class="el" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>=0, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">SubTp</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; Args=std::nullopt) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aa0519f26bcb15c25ac0ff557061fa7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425eab58717b81784602a0b169dd9ff8" id="r_a425eab58717b81784602a0b169dd9ff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a425eab58717b81784602a0b169dd9ff8">getCastInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Dst, <a class="el" href="classllvm_1_1Type.html">Type</a> *Src, <a class="el" href="#af84cce349a77262269fd3f6756f37a64">TTI::CastContextHint</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">CCH</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a425eab58717b81784602a0b169dd9ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbea7151f5e66776f92f7b4e305418d6" id="r_acbea7151f5e66776f92f7b4e305418d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbea7151f5e66776f92f7b4e305418d6">getExtractWithExtendCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Dst, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:acbea7151f5e66776f92f7b4e305418d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b131843b386c6e3cc39bd6f8141357" id="r_af7b131843b386c6e3cc39bd6f8141357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7b131843b386c6e3cc39bd6f8141357">getCFInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:af7b131843b386c6e3cc39bd6f8141357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89277d8bd76d6348291e29b6076796a" id="r_af89277d8bd76d6348291e29b6076796a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af89277d8bd76d6348291e29b6076796a">getCmpSelInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *ValTy, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">CondTy</a>, <a class="el" href="classllvm_1_1CmpInst.html#a2be3583dac92a031fa1458d4d992c78b">CmpInst::Predicate</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">VecPred</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:af89277d8bd76d6348291e29b6076796a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37b2842424eb63440bdcacca0af9820" id="r_af37b2842424eb63440bdcacca0af9820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af37b2842424eb63440bdcacca0af9820">getVectorInstrCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Val, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>=-1, <a class="el" href="classllvm_1_1Value.html">Value</a> *Op0=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *Op1=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:af37b2842424eb63440bdcacca0af9820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faf795a9033768e63f8907829339ccf" id="r_a8faf795a9033768e63f8907829339ccf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8faf795a9033768e63f8907829339ccf">getVectorInstrCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *Val, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>=-1) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a8faf795a9033768e63f8907829339ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d10bacb766fd94e20c1af0bfd52b9bd" id="r_a0d10bacb766fd94e20c1af0bfd52b9bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d10bacb766fd94e20c1af0bfd52b9bd">getReplicationShuffleCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *EltTy, int <a class="el" href="classllvm_1_1ilist__node__impl.html">ReplicationFactor</a>, int VF, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">DemandedDstElts</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>)</td></tr>
<tr class="separator:a0d10bacb766fd94e20c1af0bfd52b9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c987c590db0e5cff66d9869a34c556" id="r_a34c987c590db0e5cff66d9869a34c556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34c987c590db0e5cff66d9869a34c556">getMemoryOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Src, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1OperandValueInfo.html">OperandValueInfo</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">OpdInfo</a>={<a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a>, <a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a>}, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a34c987c590db0e5cff66d9869a34c556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846e472a2fb24cec08762c2c26624a35" id="r_a846e472a2fb24cec08762c2c26624a35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a846e472a2fb24cec08762c2c26624a35">getVPMemoryOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Src, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a846e472a2fb24cec08762c2c26624a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8718d4f9740c67449057887b386fb348" id="r_a8718d4f9740c67449057887b386fb348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8718d4f9740c67449057887b386fb348">getMaskedMemoryOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Src, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a8718d4f9740c67449057887b386fb348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f4a801858ac7255f623ca0ec53394f" id="r_aa0f4a801858ac7255f623ca0ec53394f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0f4a801858ac7255f623ca0ec53394f">getGatherScatterOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *DataTy, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="TargetLibraryInfo_8cpp.html#aca185e6d0e9f423dbb24440206454872a11dbf501abf829b3ab7049c2d3a8a053">Ptr</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">VariableMask</a>, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aa0f4a801858ac7255f623ca0ec53394f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38000267bdb6bb25b9c33f9fd7053b1d" id="r_a38000267bdb6bb25b9c33f9fd7053b1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38000267bdb6bb25b9c33f9fd7053b1d">getInterleavedMemoryOpCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *VecTy, <a class="el" href="classunsigned.html">unsigned</a> Factor, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; Indices, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="namespacellvm.html#a2c3c18bffdc25d969233c5448bdfe7eb">AddressSpace</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">UseMaskForCond</a>=false, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">UseMaskForGaps</a>=false) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a38000267bdb6bb25b9c33f9fd7053b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421ee26483edf3fd0cd1dca34513f45e" id="r_a421ee26483edf3fd0cd1dca34513f45e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a421ee26483edf3fd0cd1dca34513f45e">getArithmeticReductionCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *Ty, std::optional&lt; <a class="el" href="classllvm_1_1FastMathFlags.html">FastMathFlags</a> &gt; FMF, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a421ee26483edf3fd0cd1dca34513f45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cost of vector reduction intrinsics.  <br /></td></tr>
<tr class="separator:a421ee26483edf3fd0cd1dca34513f45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da1f2e3b471cce50680e800c05e4d6b" id="r_a6da1f2e3b471cce50680e800c05e4d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6da1f2e3b471cce50680e800c05e4d6b">getMinMaxReductionCost</a> (<a class="el" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a> IID, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *Ty, <a class="el" href="classllvm_1_1FastMathFlags.html">FastMathFlags</a> FMF=<a class="el" href="classllvm_1_1FastMathFlags.html">FastMathFlags</a>(), <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a6da1f2e3b471cce50680e800c05e4d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fd571365b64379faf5eb0b3caa1b27" id="r_a61fd571365b64379faf5eb0b3caa1b27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61fd571365b64379faf5eb0b3caa1b27">getMulAccReductionCost</a> (<a class="el" href="classbool.html">bool</a> IsUnsigned, <a class="el" href="classllvm_1_1Type.html">Type</a> *ResTy, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *Ty, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a61fd571365b64379faf5eb0b3caa1b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cost of an extended reduction pattern, similar to getArithmeticReductionCost of an Add reduction with multiply and optional extensions.  <br /></td></tr>
<tr class="separator:a61fd571365b64379faf5eb0b3caa1b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f958d8d050bfd1a5b0ea73186f2e36e" id="r_a5f958d8d050bfd1a5b0ea73186f2e36e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f958d8d050bfd1a5b0ea73186f2e36e">getExtendedReductionCost</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classbool.html">bool</a> IsUnsigned, <a class="el" href="classllvm_1_1Type.html">Type</a> *ResTy, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *Ty, <a class="el" href="classllvm_1_1FastMathFlags.html">FastMathFlags</a> FMF, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5f958d8d050bfd1a5b0ea73186f2e36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cost of an extended reduction pattern, similar to getArithmeticReductionCost of a reduction with an extension.  <br /></td></tr>
<tr class="separator:a5f958d8d050bfd1a5b0ea73186f2e36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4218f47749d093473e680ad0199fb239" id="r_a4218f47749d093473e680ad0199fb239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4218f47749d093473e680ad0199fb239">getIntrinsicInstrCost</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1IntrinsicCostAttributes.html">IntrinsicCostAttributes</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">ICA</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a4218f47749d093473e680ad0199fb239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67833027bb46ddb390684a6f0b75398" id="r_af67833027bb46ddb390684a6f0b75398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af67833027bb46ddb390684a6f0b75398">getCallInstrCost</a> (<a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="DeadArgumentElimination_8cpp.html#a35d4cf18d43d4f0b81e2b55be3fe2db7">RetTy</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; <a class="el" href="classllvm_1_1ilist__node__impl.html">Tys</a>, <a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a> <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>=<a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:af67833027bb46ddb390684a6f0b75398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67b7e389a52ada1d5264e23d09f4cbe" id="r_ad67b7e389a52ada1d5264e23d09f4cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad67b7e389a52ada1d5264e23d09f4cbe">getNumberOfParts</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Tp</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ad67b7e389a52ada1d5264e23d09f4cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246f298958a4a730bf7d3a64440dd47b" id="r_a246f298958a4a730bf7d3a64440dd47b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a246f298958a4a730bf7d3a64440dd47b">getAddressComputationCost</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *<a class="el" href="TargetLibraryInfo_8cpp.html#aca185e6d0e9f423dbb24440206454872a11dbf501abf829b3ab7049c2d3a8a053">Ptr</a>=<a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a246f298958a4a730bf7d3a64440dd47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8920039419b33a0b7248a0957e262ee7" id="r_a8920039419b33a0b7248a0957e262ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8920039419b33a0b7248a0957e262ee7">getCostOfKeepingLiveOverCall</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; <a class="el" href="classllvm_1_1ilist__node__impl.html">Tys</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a8920039419b33a0b7248a0957e262ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e4dcfc435f179592619b03330f643b" id="r_a02e4dcfc435f179592619b03330f643b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02e4dcfc435f179592619b03330f643b">getTgtMemIntrinsic</a> (<a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *Inst, <a class="el" href="structllvm_1_1MemIntrinsicInfo.html">MemIntrinsicInfo</a> &amp;<a class="el" href="CSEInfo_8cpp.html#a75f8a8519c2c9b30e7c06dc5e256fffa">Info</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a02e4dcfc435f179592619b03330f643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422b020a05731c432411d574a7728af5" id="r_a422b020a05731c432411d574a7728af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a422b020a05731c432411d574a7728af5">getAtomicMemIntrinsicMaxElementSize</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a422b020a05731c432411d574a7728af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e18a8730e428b4967b375d57c2e401" id="r_ad5e18a8730e428b4967b375d57c2e401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5e18a8730e428b4967b375d57c2e401">getOrCreateResultFromMemIntrinsic</a> (<a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *Inst, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">ExpectedType</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ad5e18a8730e428b4967b375d57c2e401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae027119490c2c4cfbb11092a28832cac" id="r_ae027119490c2c4cfbb11092a28832cac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae027119490c2c4cfbb11092a28832cac">getMemcpyLoopLoweringType</a> (<a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;Context, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="namespacellvm.html#a05f5b9a11bdcc5feba62899f95dcf878af6d9f1c7b49b7601fae6a545002a6763">Length</a>, <a class="el" href="classunsigned.html">unsigned</a> SrcAddrSpace, <a class="el" href="classunsigned.html">unsigned</a> DestAddrSpace, <a class="el" href="classunsigned.html">unsigned</a> SrcAlign, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">DestAlign</a>, std::optional&lt; <a class="el" href="classuint32__t.html">uint32_t</a> &gt; <a class="el" href="classllvm_1_1ilist__node__impl.html">AtomicElementSize</a>=std::nullopt) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ae027119490c2c4cfbb11092a28832cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13609bc726de8e7758fd9d6c8bc67c94" id="r_a13609bc726de8e7758fd9d6c8bc67c94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13609bc726de8e7758fd9d6c8bc67c94">getMemcpyLoopResidualLoweringType</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">OpsOut</a>, <a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;Context, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">RemainingBytes</a>, <a class="el" href="classunsigned.html">unsigned</a> SrcAddrSpace, <a class="el" href="classunsigned.html">unsigned</a> DestAddrSpace, <a class="el" href="classunsigned.html">unsigned</a> SrcAlign, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">DestAlign</a>, std::optional&lt; <a class="el" href="classuint32__t.html">uint32_t</a> &gt; <a class="el" href="classllvm_1_1ilist__node__impl.html">AtomicCpySize</a>=std::nullopt) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a13609bc726de8e7758fd9d6c8bc67c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e1f19379514bb06cdcedb2bae8748d" id="r_ad2e1f19379514bb06cdcedb2bae8748d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2e1f19379514bb06cdcedb2bae8748d">areInlineCompatible</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *Caller, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="AMDGPULibCalls_8cpp.html#a537c835c34f0b44b6ad2696643754390">Callee</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ad2e1f19379514bb06cdcedb2bae8748d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71773f01b77047575c95791e12f91246" id="r_a71773f01b77047575c95791e12f91246"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71773f01b77047575c95791e12f91246">areTypesABICompatible</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *Caller, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *<a class="el" href="AMDGPULibCalls_8cpp.html#a537c835c34f0b44b6ad2696643754390">Callee</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; &amp;Types) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a71773f01b77047575c95791e12f91246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7716bda26c61738e624214efa149e83e" id="r_a7716bda26c61738e624214efa149e83e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7716bda26c61738e624214efa149e83e">isIndexedLoadLegal</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">MemIndexedMode</a> <a class="el" href="RegAllocEvictionAdvisor_8cpp.html#aef71c4b21823f236e70cc6d62375adcd">Mode</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a7716bda26c61738e624214efa149e83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a768ef7bcf1b5059f409327c1f83591" id="r_a5a768ef7bcf1b5059f409327c1f83591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a768ef7bcf1b5059f409327c1f83591">isIndexedStoreLegal</a> (<a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">MemIndexedMode</a> <a class="el" href="RegAllocEvictionAdvisor_8cpp.html#aef71c4b21823f236e70cc6d62375adcd">Mode</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a5a768ef7bcf1b5059f409327c1f83591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9d2da3e41e4cc90c7a552258166277" id="r_a5c9d2da3e41e4cc90c7a552258166277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c9d2da3e41e4cc90c7a552258166277">getLoadStoreVecRegBitWidth</a> (<a class="el" href="classunsigned.html">unsigned</a> AddrSpace) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a5c9d2da3e41e4cc90c7a552258166277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aaf2f1c4d2a4bb801bc9aeea94de3c" id="r_a03aaf2f1c4d2a4bb801bc9aeea94de3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03aaf2f1c4d2a4bb801bc9aeea94de3c">isLegalToVectorizeLoad</a> (<a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a03aaf2f1c4d2a4bb801bc9aeea94de3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de4290b00b162ec20705cad42047b64" id="r_a0de4290b00b162ec20705cad42047b64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0de4290b00b162ec20705cad42047b64">isLegalToVectorizeStore</a> (<a class="el" href="classllvm_1_1StoreInst.html">StoreInst</a> *SI) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a0de4290b00b162ec20705cad42047b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa75efd79296070e4c5f24fa3ea6f01" id="r_aaaa75efd79296070e4c5f24fa3ea6f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaa75efd79296070e4c5f24fa3ea6f01">isLegalToVectorizeLoadChain</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ChainSizeInBytes</a>, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aaaa75efd79296070e4c5f24fa3ea6f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b0dcd9d3ef39aa308b7d7371e5da88" id="r_a58b0dcd9d3ef39aa308b7d7371e5da88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58b0dcd9d3ef39aa308b7d7371e5da88">isLegalToVectorizeStoreChain</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ChainSizeInBytes</a>, <a class="el" href="structllvm_1_1Align.html">Align</a> Alignment, <a class="el" href="classunsigned.html">unsigned</a> AddrSpace) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a58b0dcd9d3ef39aa308b7d7371e5da88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b174ae4841c69cd671ed4bf4834db64" id="r_a7b174ae4841c69cd671ed4bf4834db64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b174ae4841c69cd671ed4bf4834db64">isLegalToVectorizeReduction</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1RecurrenceDescriptor.html">RecurrenceDescriptor</a> &amp;RdxDesc, <a class="el" href="classllvm_1_1ElementCount.html">ElementCount</a> VF) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a7b174ae4841c69cd671ed4bf4834db64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e28d7d5da07059305e09ff16ee5d0b" id="r_a64e28d7d5da07059305e09ff16ee5d0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64e28d7d5da07059305e09ff16ee5d0b">isElementTypeLegalForScalableVector</a> (<a class="el" href="classllvm_1_1Type.html">Type</a> *Ty) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a64e28d7d5da07059305e09ff16ee5d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e51850e7e39c4bd2424ad98c12e700" id="r_a84e51850e7e39c4bd2424ad98c12e700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84e51850e7e39c4bd2424ad98c12e700">getLoadVectorFactor</a> (<a class="el" href="classunsigned.html">unsigned</a> VF, <a class="el" href="classunsigned.html">unsigned</a> LoadSize, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ChainSizeInBytes</a>, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a84e51850e7e39c4bd2424ad98c12e700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47da5df7f765cada1df9036a3433e1a4" id="r_a47da5df7f765cada1df9036a3433e1a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47da5df7f765cada1df9036a3433e1a4">getStoreVectorFactor</a> (<a class="el" href="classunsigned.html">unsigned</a> VF, <a class="el" href="classunsigned.html">unsigned</a> StoreSize, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">ChainSizeInBytes</a>, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a47da5df7f765cada1df9036a3433e1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2b30bdeffa3fb4a4fd881e25d01817" id="r_a1a2b30bdeffa3fb4a4fd881e25d01817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a2b30bdeffa3fb4a4fd881e25d01817">preferInLoopReduction</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1ReductionFlags.html">ReductionFlags</a> Flags) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a1a2b30bdeffa3fb4a4fd881e25d01817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8f7af4c35e8c6bc6e9a4f0850a7847" id="r_a8e8f7af4c35e8c6bc6e9a4f0850a7847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e8f7af4c35e8c6bc6e9a4f0850a7847">preferPredicatedReductionSelect</a> (<a class="el" href="classunsigned.html">unsigned</a> Opcode, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="structllvm_1_1TargetTransformInfo_1_1ReductionFlags.html">ReductionFlags</a> Flags) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a8e8f7af4c35e8c6bc6e9a4f0850a7847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987fde1294b059921cb381631fa3747b" id="r_a987fde1294b059921cb381631fa3747b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a987fde1294b059921cb381631fa3747b">preferEpilogueVectorization</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a987fde1294b059921cb381631fa3747b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the loop vectorizer should consider vectorizing an otherwise scalar epilogue loop.  <br /></td></tr>
<tr class="separator:a987fde1294b059921cb381631fa3747b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeefc63fa057f5050b78547c6cdf0e1" id="r_aefeefc63fa057f5050b78547c6cdf0e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefeefc63fa057f5050b78547c6cdf0e1">shouldExpandReduction</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *II) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:aefeefc63fa057f5050b78547c6cdf0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2f1ef61f1c352da3b8121d4ea2c585" id="r_acd2f1ef61f1c352da3b8121d4ea2c585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd2f1ef61f1c352da3b8121d4ea2c585">getGISelRematGlobalCost</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:acd2f1ef61f1c352da3b8121d4ea2c585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50791ac3dd33dc3dc522df16116a27b" id="r_ac50791ac3dd33dc3dc522df16116a27b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac50791ac3dd33dc3dc522df16116a27b">getMinTripCountTailFoldingThreshold</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ac50791ac3dd33dc3dc522df16116a27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0215ddedbe9f8179c491308a56aaceb" id="r_ab0215ddedbe9f8179c491308a56aaceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0215ddedbe9f8179c491308a56aaceb">supportsScalableVectors</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ab0215ddedbe9f8179c491308a56aaceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac912bf74dab55fe744b25c739e29d7b0" id="r_ac912bf74dab55fe744b25c739e29d7b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac912bf74dab55fe744b25c739e29d7b0">enableScalableVectorization</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ac912bf74dab55fe744b25c739e29d7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fecba95c1ba20950ea8e2139127e621" id="r_a5fecba95c1ba20950ea8e2139127e621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="structllvm_1_1TargetTransformInfo_1_1OperandValueInfo.html">OperandValueInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fecba95c1ba20950ea8e2139127e621">getOperandInfo</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *V)</td></tr>
<tr class="memdesc:a5fecba95c1ba20950ea8e2139127e621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect properties of V used in cost analysis, e.g. OP_PowerOf2.  <br /></td></tr>
<tr class="separator:a5fecba95c1ba20950ea8e2139127e621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096c8b641174dc0e486006926c5202cf" id="r_a096c8b641174dc0e486006926c5202cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="#af84cce349a77262269fd3f6756f37a64">CastContextHint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a096c8b641174dc0e486006926c5202cf">getCastContextHint</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="memdesc:a096c8b641174dc0e486006926c5202cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a CastContextHint from <code>I</code>.  <br /></td></tr>
<tr class="separator:a096c8b641174dc0e486006926c5202cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aecc3cf03beff532c2b8bfe81e500c8" id="r_a7aecc3cf03beff532c2b8bfe81e500c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aecc3cf03beff532c2b8bfe81e500c8">requiresOrderedReduction</a> (std::optional&lt; <a class="el" href="classllvm_1_1FastMathFlags.html">FastMathFlags</a> &gt; FMF)</td></tr>
<tr class="memdesc:a7aecc3cf03beff532c2b8bfe81e500c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to determine the type of reduction algorithm used for a given <code>Opcode</code> and set of <a class="el" href="classllvm_1_1FastMathFlags.html" title="Convenience struct for specifying and reasoning about fast-math flags.">FastMathFlags</a> <code>FMF</code>.  <br /></td></tr>
<tr class="separator:a7aecc3cf03beff532c2b8bfe81e500c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This pass provides access to the codegen interfaces that are needed for IR-level transformations. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00210">210</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad88649498463e1fe02380ad98886ce43" name="ad88649498463e1fe02380ad98886ce43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88649498463e1fe02380ad98886ce43">&#9670;&#160;</a></span>AddressingModeKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#ad88649498463e1fe02380ad98886ce43">llvm::TargetTransformInfo::AddressingModeKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad88649498463e1fe02380ad98886ce43a7cb26b7792c751612e634c36dce16f9a" name="ad88649498463e1fe02380ad98886ce43a7cb26b7792c751612e634c36dce16f9a"></a>AMK_PreIndexed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad88649498463e1fe02380ad98886ce43a0e72bd25d3608a66eac09e4cfbb7c658" name="ad88649498463e1fe02380ad98886ce43a0e72bd25d3608a66eac09e4cfbb7c658"></a>AMK_PostIndexed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad88649498463e1fe02380ad98886ce43afcb500aacd74955fc04edc890f5e5d1a" name="ad88649498463e1fe02380ad98886ce43afcb500aacd74955fc04edc890f5e5d1a"></a>AMK_None&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00732">732</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="afbde4c30736df440ecdeee35a0608f6b" name="afbde4c30736df440ecdeee35a0608f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbde4c30736df440ecdeee35a0608f6b">&#9670;&#160;</a></span>CacheLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> <a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">llvm::TargetTransformInfo::CacheLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The possible cache levels. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afbde4c30736df440ecdeee35a0608f6ba4ea39ed13dabbda09e2782f5529eb1ac" name="afbde4c30736df440ecdeee35a0608f6ba4ea39ed13dabbda09e2782f5529eb1ac"></a>L1D&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afbde4c30736df440ecdeee35a0608f6baecc9f58d2b1c17e94659be202c01b55b" name="afbde4c30736df440ecdeee35a0608f6baecc9f58d2b1c17e94659be202c01b55b"></a>L2D&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l01129">1129</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="af84cce349a77262269fd3f6756f37a64" name="af84cce349a77262269fd3f6756f37a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84cce349a77262269fd3f6756f37a64">&#9670;&#160;</a></span>CastContextHint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">class</a> <a class="el" href="#af84cce349a77262269fd3f6756f37a64">llvm::TargetTransformInfo::CastContextHint</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents a hint about the context in which a cast is used. </p>
<p>For zext/sext, the context of the cast is the operand, which must be a load of some kind. For trunc, the context is of the cast is the single user of the instruction, which must be a store of some kind.</p>
<p>This enum allows the vectorizer to give getCastInstrCost an idea of the type of cast it's dealing with, as not every cast is equal. For instance, the zext of a load may be free, but the zext of an interleaving load can be (very) expensive!</p>
<p>See <code>getCastContextHint</code> to compute a CastContextHint from a cast Instruction*. Callers can use it if they don't need to override the context and just want it to be calculated from the instruction.</p>
<p>FIXME: This handles the types of load/store that the vectorizer can produce, which are the cases where the context instruction is most likely to be incorrect. There are other situations where that can happen too, which might be handled here but in the long run a more general solution of costing multiple instructions at the same times may be better. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af84cce349a77262269fd3f6756f37a64a6adf97f83acf6453d4a6a4b1070f3754" name="af84cce349a77262269fd3f6756f37a64a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>The cast is not used with a load/store of any kind. </p>
</td></tr>
<tr><td class="fieldname"><a id="af84cce349a77262269fd3f6756f37a64a960b44c579bc2f6818d2daaf9e4c16f0" name="af84cce349a77262269fd3f6756f37a64a960b44c579bc2f6818d2daaf9e4c16f0"></a>Normal&#160;</td><td class="fielddoc"><p>The cast is used with a normal load/store. </p>
</td></tr>
<tr><td class="fieldname"><a id="af84cce349a77262269fd3f6756f37a64a6864311f985d160ad4bd46a9fbe4a4d4" name="af84cce349a77262269fd3f6756f37a64a6864311f985d160ad4bd46a9fbe4a4d4"></a>Masked&#160;</td><td class="fielddoc"><p>The cast is used with a masked load/store. </p>
</td></tr>
<tr><td class="fieldname"><a id="af84cce349a77262269fd3f6756f37a64afc2e3edeec59afcdc10f55205713f14b" name="af84cce349a77262269fd3f6756f37a64afc2e3edeec59afcdc10f55205713f14b"></a>GatherScatter&#160;</td><td class="fielddoc"><p>The cast is used with a gather/scatter. </p>
</td></tr>
<tr><td class="fieldname"><a id="af84cce349a77262269fd3f6756f37a64ad392556b3674a98332cc2938ba0bfeb7" name="af84cce349a77262269fd3f6756f37a64ad392556b3674a98332cc2938ba0bfeb7"></a>Interleave&#160;</td><td class="fielddoc"><p>The cast is used with an interleaved load/store. </p>
</td></tr>
<tr><td class="fieldname"><a id="af84cce349a77262269fd3f6756f37a64a030aa94015bd11d183b897ddb541e4e3" name="af84cce349a77262269fd3f6756f37a64a030aa94015bd11d183b897ddb541e4e3"></a>Reversed&#160;</td><td class="fielddoc"><p>The cast is used with a reversed load/store. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l01248">1248</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="acf5cc8324c33cb1f59869456263f9f4b" name="acf5cc8324c33cb1f59869456263f9f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5cc8324c33cb1f59869456263f9f4b">&#9670;&#160;</a></span>MemIndexedMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">llvm::TargetTransformInfo::MemIndexedMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of load/store indexing. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acf5cc8324c33cb1f59869456263f9f4ba24234938a33e357e0c86f1d71295a2f6" name="acf5cc8324c33cb1f59869456263f9f4ba24234938a33e357e0c86f1d71295a2f6"></a>MIM_Unindexed&#160;</td><td class="fielddoc"><p>No indexing. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf5cc8324c33cb1f59869456263f9f4baf049517e9a49117b5225ee67455f5dea" name="acf5cc8324c33cb1f59869456263f9f4baf049517e9a49117b5225ee67455f5dea"></a>MIM_PreInc&#160;</td><td class="fielddoc"><p>Pre-incrementing. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf5cc8324c33cb1f59869456263f9f4ba7367f3267f2bfe1a200655097784f4a1" name="acf5cc8324c33cb1f59869456263f9f4ba7367f3267f2bfe1a200655097784f4a1"></a>MIM_PreDec&#160;</td><td class="fielddoc"><p>Pre-decrementing. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf5cc8324c33cb1f59869456263f9f4ba3a471f30b7a193785b57c081776ad3cb" name="acf5cc8324c33cb1f59869456263f9f4ba3a471f30b7a193785b57c081776ad3cb"></a>MIM_PostInc&#160;</td><td class="fielddoc"><p>Post-incrementing. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf5cc8324c33cb1f59869456263f9f4ba57dbcb88640a74d04f7e0ddeefa76d1b" name="acf5cc8324c33cb1f59869456263f9f4ba57dbcb88640a74d04f7e0ddeefa76d1b"></a>MIM_PostDec&#160;</td><td class="fielddoc"><p>Post-decrementing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l01514">1514</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="afa38851d75434d1476444ac93f94cb4c" name="afa38851d75434d1476444ac93f94cb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa38851d75434d1476444ac93f94cb4c">&#9670;&#160;</a></span>OperandValueKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#afa38851d75434d1476444ac93f94cb4c">llvm::TargetTransformInfo::OperandValueKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Additional information about an operand's possible values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac" name="afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac"></a>OK_AnyValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afa38851d75434d1476444ac93f94cb4ca7aa61d9e9d33bdf28478754c69c59640" name="afa38851d75434d1476444ac93f94cb4ca7aa61d9e9d33bdf28478754c69c59640"></a>OK_UniformValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afa38851d75434d1476444ac93f94cb4ca76d8855d96b8e66b9411ed74737ca8f7" name="afa38851d75434d1476444ac93f94cb4ca76d8855d96b8e66b9411ed74737ca8f7"></a>OK_UniformConstantValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afa38851d75434d1476444ac93f94cb4cacf63326297610dfbedd0ad408b54e3e4" name="afa38851d75434d1476444ac93f94cb4cacf63326297610dfbedd0ad408b54e3e4"></a>OK_NonUniformConstantValue&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l01012">1012</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="a733fb237f3037c95ed59de6055b176c5" name="a733fb237f3037c95ed59de6055b176c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733fb237f3037c95ed59de6055b176c5">&#9670;&#160;</a></span>OperandValueProperties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#a733fb237f3037c95ed59de6055b176c5">llvm::TargetTransformInfo::OperandValueProperties</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Additional properties of an operand's values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072" name="a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072"></a>OP_None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a733fb237f3037c95ed59de6055b176c5a974f46ced0fd416db695ce5da6059dcc" name="a733fb237f3037c95ed59de6055b176c5a974f46ced0fd416db695ce5da6059dcc"></a>OP_PowerOf2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a733fb237f3037c95ed59de6055b176c5a19af6b5f4f70eaefcc0b6734f1f06cd8" name="a733fb237f3037c95ed59de6055b176c5a19af6b5f4f70eaefcc0b6734f1f06cd8"></a>OP_NegatedPowerOf2&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l01020">1020</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="aa4c17e89b1ef061ed69f42b7cee93dbe" name="aa4c17e89b1ef061ed69f42b7cee93dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c17e89b1ef061ed69f42b7cee93dbe">&#9670;&#160;</a></span>PopcntSupportKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbe">llvm::TargetTransformInfo::PopcntSupportKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags indicating the kind of support for population count. </p>
<p>Compared to the SW implementation, HW support is supposed to significantly boost the performance when the population is dense, and it may or may not degrade performance if the population is sparse. A HW support is considered as "Fast" if it can outperform, or is on a par with, SW implementation when the population is sparse; otherwise, it is considered as "Slow". </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa4c17e89b1ef061ed69f42b7cee93dbea0ce99a3a4fe2b7f2771a7b288a99ed2c" name="aa4c17e89b1ef061ed69f42b7cee93dbea0ce99a3a4fe2b7f2771a7b288a99ed2c"></a>PSK_Software&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa4c17e89b1ef061ed69f42b7cee93dbea01deb9d0bc6399399b0d8377bd09201d" name="aa4c17e89b1ef061ed69f42b7cee93dbea01deb9d0bc6399399b0d8377bd09201d"></a>PSK_SlowHardware&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa4c17e89b1ef061ed69f42b7cee93dbeac71465fd61f1ba8aa2c7c397722b5e05" name="aa4c17e89b1ef061ed69f42b7cee93dbeac71465fd61f1ba8aa2c7c397722b5e05"></a>PSK_FastHardware&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00685">685</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="a8bb3b1ccf19b8c85429b777dfa4a0166" name="a8bb3b1ccf19b8c85429b777dfa4a0166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb3b1ccf19b8c85429b777dfa4a0166">&#9670;&#160;</a></span>RegisterKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#a8bb3b1ccf19b8c85429b777dfa4a0166">llvm::TargetTransformInfo::RegisterKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8bb3b1ccf19b8c85429b777dfa4a0166ad8f233645107107ed48d2e4a915152cc" name="a8bb3b1ccf19b8c85429b777dfa4a0166ad8f233645107107ed48d2e4a915152cc"></a>RGK_Scalar&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8bb3b1ccf19b8c85429b777dfa4a0166a183020fbea95c99db23f6d3594f4c4af" name="a8bb3b1ccf19b8c85429b777dfa4a0166a183020fbea95c99db23f6d3594f4c4af"></a>RGK_FixedWidthVector&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8bb3b1ccf19b8c85429b777dfa4a0166a331413d3887a08546d0973091f6a4993" name="a8bb3b1ccf19b8c85429b777dfa4a0166a331413d3887a08546d0973091f6a4993"></a>RGK_ScalableVector&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l01070">1070</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="af46433d0e36d3f80afc3a8c67b5c53ec" name="af46433d0e36d3f80afc3a8c67b5c53ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46433d0e36d3f80afc3a8c67b5c53ec">&#9670;&#160;</a></span>ShuffleKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ec">llvm::TargetTransformInfo::ShuffleKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The various kinds of shuffle patterns for vector queries. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53ecab1ac8982cdb119f39a5fe74610a46796" name="af46433d0e36d3f80afc3a8c67b5c53ecab1ac8982cdb119f39a5fe74610a46796"></a>SK_Broadcast&#160;</td><td class="fielddoc"><p>Broadcast element 0 to all other elements. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53ecaea788d98147161f25d5adc3ec6ce7e1f" name="af46433d0e36d3f80afc3a8c67b5c53ecaea788d98147161f25d5adc3ec6ce7e1f"></a>SK_Reverse&#160;</td><td class="fielddoc"><p>Reverse the order of the vector. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53eca64d439485545faa793c20de7fbfd274c" name="af46433d0e36d3f80afc3a8c67b5c53eca64d439485545faa793c20de7fbfd274c"></a>SK_Select&#160;</td><td class="fielddoc"><p>Selects elements from the corresponding lane of either source operand. </p>
<p>This is equivalent to a vector select with a constant condition operand. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53eca7cc176c1463af0d9820e7981c32db478" name="af46433d0e36d3f80afc3a8c67b5c53eca7cc176c1463af0d9820e7981c32db478"></a>SK_Transpose&#160;</td><td class="fielddoc"><p>Transpose two vectors. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53eca466a4d581cf3a553414b9c2e889b944a" name="af46433d0e36d3f80afc3a8c67b5c53eca466a4d581cf3a553414b9c2e889b944a"></a>SK_InsertSubvector&#160;</td><td class="fielddoc"><p>InsertSubvector. Index indicates start offset. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53ecafd6c03f570400fcb24d861aa21ddffe9" name="af46433d0e36d3f80afc3a8c67b5c53ecafd6c03f570400fcb24d861aa21ddffe9"></a>SK_ExtractSubvector&#160;</td><td class="fielddoc"><p>ExtractSubvector Index indicates start offset. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53ecab4616961a3bfdaec42aedc4fc426ccfe" name="af46433d0e36d3f80afc3a8c67b5c53ecab4616961a3bfdaec42aedc4fc426ccfe"></a>SK_PermuteTwoSrc&#160;</td><td class="fielddoc"><p>Merge elements from two source vectors into one with any shuffle mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53eca7beec9815d0197f2d31fac9968e9205b" name="af46433d0e36d3f80afc3a8c67b5c53eca7beec9815d0197f2d31fac9968e9205b"></a>SK_PermuteSingleSrc&#160;</td><td class="fielddoc"><p>Shuffle elements of single source vector with any shuffle mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="af46433d0e36d3f80afc3a8c67b5c53ecaa9e18b2636661e341804da24971997df" name="af46433d0e36d3f80afc3a8c67b5c53ecaa9e18b2636661e341804da24971997df"></a>SK_Splice&#160;</td><td class="fielddoc"><p>Concatenates elements from the first input vector with elements of the second input vector. </p>
<p>Returning a vector of the same type as the input vectors. Index indicates start offset in first input vector. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00992">992</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="ac44f6b9fdbb5f9cc199f8329cb0b272c" name="ac44f6b9fdbb5f9cc199f8329cb0b272c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44f6b9fdbb5f9cc199f8329cb0b272c">&#9670;&#160;</a></span>TargetCostConstants</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#ac44f6b9fdbb5f9cc199f8329cb0b272c">llvm::TargetTransformInfo::TargetCostConstants</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Underlying constants for 'cost' values in this interface. </p>
<p>Many APIs in this interface return a cost. This enum defines the fundamental values that should be used to interpret (and produce) those costs. The costs are returned as an int rather than a member of this enumeration because it is expected that the cost of one IR instruction may have a multiplicative factor to it or otherwise won't fit directly into the enum. Moreover, it is common to sum or average costs which works better as simple integral values. Thus this enum only provides constants. Also note that the returned costs are signed integers to make it natural to add, subtract, and test with zero (a common boundary condition). It is not expected that 2^32 is a realistic cost to be modeling at any point.</p>
<p>Note that these costs should usually reflect the intersection of code-size cost and execution cost. A free instruction is typically one that folds into another instruction. For example, reg-to-reg moves can often be skipped by renaming the registers in the CPU, but they still are encoded and thus wouldn't be considered 'free' here. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac44f6b9fdbb5f9cc199f8329cb0b272ca89f768b1267e3083b4eb05b4ab77e717" name="ac44f6b9fdbb5f9cc199f8329cb0b272ca89f768b1267e3083b4eb05b4ab77e717"></a>TCC_Free&#160;</td><td class="fielddoc"><p><a class="el" href="classllvm_1_1Expected.html" title="Tagged union holding either a T or a Error.">Expected</a> to fold away in lowering. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac44f6b9fdbb5f9cc199f8329cb0b272cae46c9eecc49bd2dc253c607e78a0fb86" name="ac44f6b9fdbb5f9cc199f8329cb0b272cae46c9eecc49bd2dc253c607e78a0fb86"></a>TCC_Basic&#160;</td><td class="fielddoc"><p>The cost of a typical 'add' instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac44f6b9fdbb5f9cc199f8329cb0b272ca022565d444ccf496c0414bccefbcd9c8" name="ac44f6b9fdbb5f9cc199f8329cb0b272ca022565d444ccf496c0414bccefbcd9c8"></a>TCC_Expensive&#160;</td><td class="fielddoc"><p>The cost of a 'div' instruction on x86. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00280">280</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="a706f223f760b55668fbae74202b816bb" name="a706f223f760b55668fbae74202b816bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706f223f760b55668fbae74202b816bb">&#9670;&#160;</a></span>TargetCostKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#a706f223f760b55668fbae74202b816bb">llvm::TargetTransformInfo::TargetCostKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The kind of cost model. </p>
<p>There are several different cost models that can be customized by the target. The normalization of each cost model may be target specific. e.g. TCK_SizeAndLatency should be comparable to target thresholds such as those derived from <a class="el" href="structllvm_1_1MCSchedModel.html#a74a33138b76ebc2cae1b3cf65411a9e6">MCSchedModel::LoopMicroOpBufferSize</a> etc. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b" name="a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b"></a>TCK_RecipThroughput&#160;</td><td class="fielddoc"><p>Reciprocal throughput. </p>
</td></tr>
<tr><td class="fieldname"><a id="a706f223f760b55668fbae74202b816bba81b2c6f1f1e13e4a575e6d1c8b29b6e1" name="a706f223f760b55668fbae74202b816bba81b2c6f1f1e13e4a575e6d1c8b29b6e1"></a>TCK_Latency&#160;</td><td class="fielddoc"><p>The latency of instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a706f223f760b55668fbae74202b816bba737cfc93e5a2ff961677d57186167e7c" name="a706f223f760b55668fbae74202b816bba737cfc93e5a2ff961677d57186167e7c"></a>TCK_CodeSize&#160;</td><td class="fielddoc"><p><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> code size. </p>
</td></tr>
<tr><td class="fieldname"><a id="a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8" name="a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8"></a>TCK_SizeAndLatency&#160;</td><td class="fielddoc"><p>The weighted sum of size and latency. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00255">255</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af1bf12b2f33b7e30f8f361a1e7642079" name="af1bf12b2f33b7e30f8f361a1e7642079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bf12b2f33b7e30f8f361a1e7642079">&#9670;&#160;</a></span>TargetTransformInfo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">llvm::TargetTransformInfo::TargetTransformInfo </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>Impl</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a TTI object using a type implementing the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below. </p>
<p>This is used by targets to construct a TTI wrapping their target-specific implementation that encodes appropriate costs for their target. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l02751">2751</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="ac7b62dddca1c89d43af02d0e2ab06030" name="ac7b62dddca1c89d43af02d0e2ab06030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b62dddca1c89d43af02d0e2ab06030">&#9670;&#160;</a></span>TargetTransformInfo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TargetTransformInfo::TargetTransformInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DL</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a baseline TTI object using a minimal implementation of the <code><a class="el" href="classllvm_1_1TargetTransformInfo_1_1Concept.html">Concept</a></code> API below. </p>
<p>The TTI implementation will reflect the information in the <a class="el" href="classllvm_1_1DataLayout.html" title="A parsed version of the target data layout string in and methods for querying it.">DataLayout</a> provided if non-null. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00198">198</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ab158463a734f57c86e685364527ebaa4" name="ab158463a734f57c86e685364527ebaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab158463a734f57c86e685364527ebaa4">&#9670;&#160;</a></span>TargetTransformInfo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TargetTransformInfo::TargetTransformInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00203">203</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="af9e9d106cef4491370c43c4f136fc050" name="af9e9d106cef4491370c43c4f136fc050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e9d106cef4491370c43c4f136fc050">&#9670;&#160;</a></span>~TargetTransformInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TargetTransformInfo::~TargetTransformInfo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0a3e39d2d1306afddf277fd3fca9aebb" name="a0a3e39d2d1306afddf277fd3fca9aebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3e39d2d1306afddf277fd3fca9aebb">&#9670;&#160;</a></span>addrspacesMayAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetTransformInfo::addrspacesMayAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AS0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AS1</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return false if a <code>AS0</code> address cannot possibly alias a <code>AS1</code> address. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00283">283</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerMemIntrinsics_8cpp_source.html#l00554">llvm::expandMemMoveAsLoop()</a>.</p>

</div>
</div>
<a id="a7e5dd9267d6c9b90b4daa6410be3da6a" name="a7e5dd9267d6c9b90b4daa6410be3da6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5dd9267d6c9b90b4daa6410be3da6a">&#9670;&#160;</a></span>adjustInliningThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::adjustInliningThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1CallBase.html">CallBase</a> *</td>          <td class="paramname"><span class="paramname"><em>CB</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A value to be added to the inlining threshold. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00216">216</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a9e737ae000f542eba6ebc679637144d9" name="a9e737ae000f542eba6ebc679637144d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e737ae000f542eba6ebc679637144d9">&#9670;&#160;</a></span>allowsMisalignedMemoryAccesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::allowsMisalignedMemoryAccesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>BitWidth</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddressSpace</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structllvm_1_1Align.html">Align</a>(1)</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *</td>          <td class="paramname"><span class="paramname"><em>Fast</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the target supports unaligned memory accesses. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00601">601</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="BitmaskEnum_8h_source.html#l00184">llvm::BitWidth</a>, and <a class="el" href="CallingConv_8h_source.html#l00041">llvm::CallingConv::Fast</a>.</p>

<p class="reference">Referenced by <a class="el" href="AggressiveInstCombine_8cpp_source.html#l00770">foldConsecutiveLoads()</a>.</p>

</div>
</div>
<a id="ad2e1f19379514bb06cdcedb2bae8748d" name="ad2e1f19379514bb06cdcedb2bae8748d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e1f19379514bb06cdcedb2bae8748d">&#9670;&#160;</a></span>areInlineCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::areInlineCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>Caller</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>Callee</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the two functions have compatible attributes for inlining purposes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01120">1120</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00187">Callee</a>.</p>

</div>
</div>
<a id="a71773f01b77047575c95791e12f91246" name="a71773f01b77047575c95791e12f91246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71773f01b77047575c95791e12f91246">&#9670;&#160;</a></span>areTypesABICompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::areTypesABICompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>Caller</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>Callee</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Types</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the caller and callee agree on how <code>Types</code> will be passed to or returned from the callee. to the callee. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Types</td><td>List of types to check. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01125">1125</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00187">Callee</a>.</p>

</div>
</div>
<a id="a68ca9af33d7674947e80df6bd7e22758" name="a68ca9af33d7674947e80df6bd7e22758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ca9af33d7674947e80df6bd7e22758">&#9670;&#160;</a></span>canHaveNonUndefGlobalInitializerInAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::canHaveNonUndefGlobalInitializerInAddressSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AS</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if globals in this address space can have initializers other than <code>undef</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00302">302</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ad5711c8e7ef4d1848c44e839242316c3" name="ad5711c8e7ef4d1848c44e839242316c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5711c8e7ef4d1848c44e839242316c3">&#9670;&#160;</a></span>canMacroFuseCmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::canMacroFuseCmp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target can fuse a compare and branch. </p>
<p>Loop-strength-reduction (LSR) uses that knowledge to adjust its cost calculation for the instructions in a loop. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00409">409</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a884326e08a0f3d72b4f5006cf31eb76f" name="a884326e08a0f3d72b4f5006cf31eb76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884326e08a0f3d72b4f5006cf31eb76f">&#9670;&#160;</a></span>canSaveCmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::canSaveCmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Loop.html">Loop</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BranchInst.html">BranchInst</a> **</td>          <td class="paramname"><span class="paramname"><em>BI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *</td>          <td class="paramname"><span class="paramname"><em>SE</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>LI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *</td>          <td class="paramname"><span class="paramname"><em>DT</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> *</td>          <td class="paramname"><span class="paramname"><em>AC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>LibInfo</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target can save a compare for loop count, for example hardware loop saves a compare. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00413">413</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a7313158dcc10a1569a2333c78cde8621" name="a7313158dcc10a1569a2333c78cde8621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7313158dcc10a1569a2333c78cde8621">&#9670;&#160;</a></span>collectFlatAddressOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::collectFlatAddressOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OpIndexes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a></td>          <td class="paramname"><span class="paramname"><em>IID</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return any intrinsic address operand indexes which may be rewritten if they use a flat address space pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the intrinsic was handled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00292">292</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a12f25864d2ad4955cb285d871a36345b" name="a12f25864d2ad4955cb285d871a36345b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f25864d2ad4955cb285d871a36345b">&#9670;&#160;</a></span>enableAggressiveInterleaving()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::enableAggressiveInterleaving </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>LoopHasReductions</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Don't restrict interleaved unrolling to small loops. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00574">574</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l05801">llvm::LoopVectorizationCostModel::selectInterleaveCount()</a>.</p>

</div>
</div>
<a id="ac501bf52c07df51c9e1242117cfc7b2f" name="ac501bf52c07df51c9e1242117cfc7b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac501bf52c07df51c9e1242117cfc7b2f">&#9670;&#160;</a></span>enableInterleavedAccessVectorization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::enableInterleavedAccessVectorization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable matching of interleaved access groups. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00588">588</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l10181">llvm::LoopVectorizePass::processLoop()</a>.</p>

</div>
</div>
<a id="a6b0734de892207738014317d233c72ad" name="a6b0734de892207738014317d233c72ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0734de892207738014317d233c72ad">&#9670;&#160;</a></span>enableMaskedInterleavedAccessVectorization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::enableMaskedInterleavedAccessVectorization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable matching of interleaved access groups that contain predicated accesses or gaps and therefore vectorized using masked vector loads/stores. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00592">592</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l02541">useMaskedInterleavedAccesses()</a>.</p>

</div>
</div>
<a id="a24629c2792a37162cf0ef4b1c38ba00c" name="a24629c2792a37162cf0ef4b1c38ba00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24629c2792a37162cf0ef4b1c38ba00c">&#9670;&#160;</a></span>enableMemCmpExpansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1MemCmpExpansionOptions.html">TargetTransformInfo::MemCmpExpansionOptions</a> TargetTransformInfo::enableMemCmpExpansion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>OptSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsZeroCmp</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00580">580</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a3e034d813ec5b7818252ac121d20a5aa" name="a3e034d813ec5b7818252ac121d20a5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e034d813ec5b7818252ac121d20a5aa">&#9670;&#160;</a></span>enableOrderedReductions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::enableOrderedReductions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if we should be enabling ordered reductions for the target. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00484">484</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l10181">llvm::LoopVectorizePass::processLoop()</a>.</p>

</div>
</div>
<a id="ac912bf74dab55fe744b25c739e29d7b0" name="ac912bf74dab55fe744b25c739e29d7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac912bf74dab55fe744b25c739e29d7b0">&#9670;&#160;</a></span>enableScalableVectorization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::enableScalableVectorization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true when scalable vectorization is preferred. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01231">1231</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorizationLegality_8cpp_source.html#l00102">llvm::LoopVectorizeHints::LoopVectorizeHints()</a>.</p>

</div>
</div>
<a id="a72110d5a1a43e21651a36bd96cfdec98" name="a72110d5a1a43e21651a36bd96cfdec98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72110d5a1a43e21651a36bd96cfdec98">&#9670;&#160;</a></span>enableSelectOptimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::enableSelectOptimize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should the Select Optimization pass be enabled and ran. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00584">584</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a4ec5838370bf4a0d0af43e443ee99325" name="a4ec5838370bf4a0d0af43e443ee99325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec5838370bf4a0d0af43e443ee99325">&#9670;&#160;</a></span>enableWritePrefetching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::enableWritePrefetching </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if prefetching should also be done for writes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00760">760</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a661bd4bd069ee48ef7bf8a7892790468" name="a661bd4bd069ee48ef7bf8a7892790468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661bd4bd069ee48ef7bf8a7892790468">&#9670;&#160;</a></span>forceScalarizeMaskedGather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::forceScalarizeMaskedGather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target forces scalarizing of llvm.masked.gather intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00466">466</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l03865">canVectorizeLoads()</a>, and <a class="el" href="ScalarizeMaskedMemIntrin_8cpp_source.html#l00917">optimizeCallInst()</a>.</p>

</div>
</div>
<a id="aebda4a819a6130c6c0f37a8b05dfac67" name="aebda4a819a6130c6c0f37a8b05dfac67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebda4a819a6130c6c0f37a8b05dfac67">&#9670;&#160;</a></span>forceScalarizeMaskedScatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::forceScalarizeMaskedScatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target forces scalarizing of llvm.masked.scatter intrinsics. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00471">471</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarizeMaskedMemIntrin_8cpp_source.html#l00917">optimizeCallInst()</a>.</p>

</div>
</div>
<a id="a246f298958a4a730bf7d3a64440dd47b" name="a246f298958a4a730bf7d3a64440dd47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246f298958a4a730bf7d3a64440dd47b">&#9670;&#160;</a></span>getAddressComputationCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getAddressComputationCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *</td>          <td class="paramname"><span class="paramname"><em>SE</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SCEV.html">SCEV</a> *</td>          <td class="paramname"><span class="paramname"><em>Ptr</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of the address computation. For most targets this can be merged into the instruction indexing mode. Some targets might want to distinguish between address computation for memory operations on vector types and scalar types. Such targets should override this function. The 'SE' parameter holds pointer for the scalar evolution object which is used in order to get the Ptr step value in case of constant stride. The 'Ptr' parameter holds <a class="el" href="classllvm_1_1SCEV.html" title="This class represents an analyzed expression in the program.">SCEV</a> of the access pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01034">1034</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="TargetLibraryInfo_8cpp_source.html#l00064">Ptr</a>.</p>

<p class="reference">Referenced by <a class="el" href="RewriteStatepointsForGC_8cpp_source.html#l02258">chainToBasePointerCost()</a>.</p>

</div>
</div>
<a id="a9679969ae87f8a08d5f6948be6cf7210" name="a9679969ae87f8a08d5f6948be6cf7210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9679969ae87f8a08d5f6948be6cf7210">&#9670;&#160;</a></span>getArithmeticInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getArithmeticInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1OperandValueInfo.html">TTI::OperandValueInfo</a></td>          <td class="paramname"><span class="paramname"><em>Opd1Info</em><span class="paramdefsep"> = </span><span class="paramdefval">{<a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">TTI::OK_AnyValue</a>,&#160;<a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">TTI::OP_None</a>}</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1OperandValueInfo.html">TTI::OperandValueInfo</a></td>          <td class="paramname"><span class="paramname"><em>Opd2Info</em><span class="paramdefsep"> = </span><span class="paramdefval">{<a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">TTI::OK_AnyValue</a>,&#160;<a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">TTI::OP_None</a>}</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Args</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a>&#160;<a class="el" href="classllvm_1_1Value.html">Value</a>&#160;*&gt;()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>CxtI</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an approximation of reciprocal throughput of a math/logic op. </p>
<p>A higher cost indicates less expected throughput. From Agner Fog's guides, reciprocal throughput is "the average number of
clock cycles per instruction when the instructions are not part of a
limiting dependency chain." Therefore, costs should be scaled to account for multiple execution units on the target that can process this type of instruction. For example, if there are 5 scalar integer units and 2 vector integer units that can calculate an 'add' in a single cycle, this model should indicate that the cost of the vector add instruction is 2.5 times the cost of the scalar add instruction. <code>Args</code> is an optional argument which holds the instruction operands values so the TTI can analyze those values searching for special cases or optimizations based on those values. <code>CxtI</code> is the optional original context instruction, if one exists, to provide even more information. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00833">833</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolutionExpander_8cpp_source.html#l01779">costAndCollectOperands()</a>, <a class="el" href="SimplifyCFG_8cpp_source.html#l03686">llvm::FoldBranchToCommonDest()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l04509">llvm::LoopVectorizationCostModel::getDivRemSpeculationCost()</a>, and <a class="el" href="IndVarSimplify_8cpp_source.html#l00502">visitIVCast()</a>.</p>

</div>
</div>
<a id="a421ee26483edf3fd0cd1dca34513f45e" name="a421ee26483edf3fd0cd1dca34513f45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421ee26483edf3fd0cd1dca34513f45e">&#9670;&#160;</a></span>getArithmeticReductionCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getArithmeticReductionCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classllvm_1_1FastMathFlags.html">FastMathFlags</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>FMF</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the cost of vector reduction intrinsics. </p>
<p>This is the cost of reducing the vector value of type <code>Ty</code> to a scalar value using the operation denoted by <code>Opcode</code>. The <a class="el" href="classllvm_1_1FastMathFlags.html" title="Convenience struct for specifying and reasoning about fast-math flags.">FastMathFlags</a> parameter <code>FMF</code> indicates what type of reduction we are performing:</p><ol type="1">
<li>Tree-wise. This is the typical 'fast' reduction performed that involves successively splitting a vector into half and doing the operation on the pair of halves until you have a scalar value. For example: (v0, v1, v2, v3) ((v0+v2), (v1+v3), undef, undef) ((v0+v2+v1+v3), undef, undef, undef) This is the default behaviour for integer operations, whereas for floating point we only do this if <code>FMF</code> indicates that reassociation is allowed.</li>
<li>Ordered. For a vector with N elements this involves performing N operations in lane order, starting with an initial scalar value, i.e. result = InitVal + v0 result = result + v1 result = result + v2 result = result + v3 This is only the case for FP operations and when reassociation is not allowed. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01051">1051</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

</div>
</div>
<a id="a1bf8eeaf9756076f0eea55ab20adf4bc" name="a1bf8eeaf9756076f0eea55ab20adf4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf8eeaf9756076f0eea55ab20adf4bc">&#9670;&#160;</a></span>getAssumedAddrSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getAssumedAddrSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00307">307</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InferAddressSpaces_8cpp_source.html#l00302">isAddressExpression()</a>.</p>

</div>
</div>
<a id="a422b020a05731c432411d574a7728af5" name="a422b020a05731c432411d574a7728af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422b020a05731c432411d574a7728af5">&#9670;&#160;</a></span>getAtomicMemIntrinsicMaxElementSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getAtomicMemIntrinsicMaxElementSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The maximum element size, in bytes, for an element unordered-atomic memory intrinsic. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01092">1092</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a7b210e7ba1c2c222ab9d01202a55f723" name="a7b210e7ba1c2c222ab9d01202a55f723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b210e7ba1c2c222ab9d01202a55f723">&#9670;&#160;</a></span>getCacheAssociativity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; TargetTransformInfo::getCacheAssociativity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">CacheLevel</a></td>          <td class="paramname"><span class="paramname"><em>Level</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The associativity of the cache level, if available. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00741">741</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a9d04cbecfee76b1c4a5ea83aa6bb113c" name="a9d04cbecfee76b1c4a5ea83aa6bb113c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d04cbecfee76b1c4a5ea83aa6bb113c">&#9670;&#160;</a></span>getCacheLineSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getCacheLineSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size of a cache line in bytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00730">730</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetTransformInfo_8cpp.html#af6ab0b42b53810d4456cb51537349222">CacheLineSize</a>.</p>

</div>
</div>
<a id="ac0d6473c3ac48c1d2d9436408e6b9e82" name="ac0d6473c3ac48c1d2d9436408e6b9e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d6473c3ac48c1d2d9436408e6b9e82">&#9670;&#160;</a></span>getCacheSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; TargetTransformInfo::getCacheSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afbde4c30736df440ecdeee35a0608f6b">CacheLevel</a></td>          <td class="paramname"><span class="paramname"><em>Level</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size of the cache level in bytes, if available. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00736">736</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a9ac02d3d31a66774a2a021b7db942dc2" name="a9ac02d3d31a66774a2a021b7db942dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac02d3d31a66774a2a021b7db942dc2">&#9670;&#160;</a></span>getCallerAllocaCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getCallerAllocaCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1CallBase.html">CallBase</a> *</td>          <td class="paramname"><span class="paramname"><em>CB</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *</td>          <td class="paramname"><span class="paramname"><em>AI</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of having an Alloca in the caller if not inlined, to be added to the threshold </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00220">220</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="af67833027bb46ddb390684a6f0b75398" name="af67833027bb46ddb390684a6f0b75398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67833027bb46ddb390684a6f0b75398">&#9670;&#160;</a></span>getCallInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getCallInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>F</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>RetTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Tys</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of Call instructions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01021">1021</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, and <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00361">RetTy</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l08166">llvm::slpvectorizer::BoUpSLP::getSpillCost()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l03448">llvm::LoopVectorizationCostModel::getVectorCallCost()</a>, and <a class="el" href="SLPVectorizer_8cpp_source.html#l06336">getVectorCallCosts()</a>.</p>

</div>
</div>
<a id="a096c8b641174dc0e486006926c5202cf" name="a096c8b641174dc0e486006926c5202cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096c8b641174dc0e486006926c5202cf">&#9670;&#160;</a></span>getCastContextHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af84cce349a77262269fd3f6756f37a64">TTI::CastContextHint</a> TargetTransformInfo::getCastContextHint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a CastContextHint from <code>I</code>. </p>
<p>This should be used by callers of getCastInstrCost if they wish to determine the context from some instruction. </p><dl class="section return"><dt>Returns</dt><dd>the CastContextHint for ZExt/SExt/Trunc, None if <code>I</code> is nullptr, or if it's another type of cast. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00856">856</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="#af84cce349a77262269fd3f6756f37a64afc2e3edeec59afcdc10f55205713f14b">GatherScatter</a>, <a class="el" href="IntrinsicInst_8h_source.html#l00054">llvm::IntrinsicInst::getIntrinsicID()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html#a01609a46da35cca87e8ada6f7de40d23">llvm::ilist_node_impl&lt; ilist_detail::compute_node_options&lt; T, Options... &gt;::type &gt;::ilist_node_impl()</a>, <a class="el" href="#af84cce349a77262269fd3f6756f37a64a6864311f985d160ad4bd46a9fbe4a4d4">Masked</a>, <a class="el" href="#af84cce349a77262269fd3f6756f37a64a6adf97f83acf6453d4a6a4b1070f3754">None</a>, and <a class="el" href="#af84cce349a77262269fd3f6756f37a64a960b44c579bc2f6818d2daaf9e4c16f0">Normal</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l07104">llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator::adjustExtracts()</a>, <a class="el" href="RewriteStatepointsForGC_8cpp_source.html#l02258">chainToBasePointerCost()</a>, <a class="el" href="TargetTransformInfoImpl_8h_source.html#l01104">llvm::TargetTransformInfoImplCRTPBase&lt; T &gt;::getInstructionCost()</a>, and <a class="el" href="AArch64ISelLowering_8cpp_source.html#l14676">llvm::AArch64TargetLowering::optimizeExtendOrTruncateConversion()</a>.</p>

</div>
</div>
<a id="a425eab58717b81784602a0b169dd9ff8" name="a425eab58717b81784602a0b169dd9ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425eab58717b81784602a0b169dd9ff8">&#9670;&#160;</a></span>getCastInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getCastInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af84cce349a77262269fd3f6756f37a64">TTI::CastContextHint</a></td>          <td class="paramname"><span class="paramname"><em>CCH</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The expected cost of cast instructions, such as bitcast, trunc, zext, etc. If there is an existing instruction that holds Opcode, it may be passed in the 'I' parameter. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00899">899</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l07104">llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator::adjustExtracts()</a>, <a class="el" href="RewriteStatepointsForGC_8cpp_source.html#l02258">chainToBasePointerCost()</a>, <a class="el" href="ScalarEvolutionExpander_8cpp_source.html#l01779">costAndCollectOperands()</a>, <a class="el" href="BasicTTIImpl_8h_source.html#l01000">llvm::BasicTTIImplBase&lt; T &gt;::getCastInstrCost()</a>, <a class="el" href="AArch64ISelLowering_8cpp_source.html#l14676">llvm::AArch64TargetLowering::optimizeExtendOrTruncateConversion()</a>, and <a class="el" href="AggressiveInstCombine_8cpp_source.html#l00346">tryToFPToSat()</a>.</p>

</div>
</div>
<a id="af7b131843b386c6e3cc39bd6f8141357" name="af7b131843b386c6e3cc39bd6f8141357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b131843b386c6e3cc39bd6f8141357">&#9670;&#160;</a></span>getCFInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getCFInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TTI::TCK_SizeAndLatency</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The expected cost of control-flow related instructions such as Phi, Ret, Br, Switch. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00918">918</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02557">findCostForOutputBlocks()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l04509">llvm::LoopVectorizationCostModel::getDivRemSpeculationCost()</a>.</p>

</div>
</div>
<a id="af89277d8bd76d6348291e29b6076796a" name="af89277d8bd76d6348291e29b6076796a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89277d8bd76d6348291e29b6076796a">&#9670;&#160;</a></span>getCmpSelInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getCmpSelInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>ValTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>CondTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CmpInst.html#a2be3583dac92a031fa1458d4d992c78b">CmpInst::Predicate</a></td>          <td class="paramname"><span class="paramname"><em>VecPred</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The expected cost of compare and select instructions. If there is an existing instruction that holds Opcode, it may be passed in the 'I' parameter. The <code>VecPred</code> parameter can be used to indicate the select is using a compare with the specified predicate as condition. When vector types are passed, <code>VecPred</code> must be used for all lanes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00927">927</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarEvolutionExpander_8cpp_source.html#l01779">costAndCollectOperands()</a>, <a class="el" href="IROutliner_8cpp_source.html#l02557">findCostForOutputBlocks()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l04509">llvm::LoopVectorizationCostModel::getDivRemSpeculationCost()</a>, and <a class="el" href="SimplifyCFG_8cpp_source.html#l02753">validateAndCostRequiredSelects()</a>.</p>

</div>
</div>
<a id="a8920039419b33a0b7248a0957e262ee7" name="a8920039419b33a0b7248a0957e262ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8920039419b33a0b7248a0957e262ee7">&#9670;&#160;</a></span>getCostOfKeepingLiveOverCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getCostOfKeepingLiveOverCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Tys</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost, if any, of keeping values of the given types alive over a callsite.</dd></dl>
<p>Some types may require the use of register classes that do not have any callee-saved registers, so would require a spill and fill. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01083">1083</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l08166">llvm::slpvectorizer::BoUpSLP::getSpillCost()</a>.</p>

</div>
</div>
<a id="a64b0a3c3724fe2cb1b335007c068179d" name="a64b0a3c3724fe2cb1b335007c068179d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b0a3c3724fe2cb1b335007c068179d">&#9670;&#160;</a></span>getEstimatedNumberOfCaseClusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getEstimatedNumberOfCaseClusters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SwitchInst.html">SwitchInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>JTSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ProfileSummaryInfo.html">ProfileSummaryInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>PSI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BlockFrequencyInfo.html">BlockFrequencyInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>BFI</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The estimated number of case clusters when lowering <code>'<a class="el" href="namespacellvm_1_1SI.html">SI</a>'</code>. <code>JTSize</code> Set a jump table size only when <code><a class="el" href="namespacellvm_1_1SI.html">SI</a></code> is suitable for a jump table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00244">244</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a5f958d8d050bfd1a5b0ea73186f2e36e" name="a5f958d8d050bfd1a5b0ea73186f2e36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f958d8d050bfd1a5b0ea73186f2e36e">&#9670;&#160;</a></span>getExtendedReductionCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getExtendedReductionCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsUnsigned</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>ResTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1FastMathFlags.html">FastMathFlags</a></td>          <td class="paramname"><span class="paramname"><em>FMF</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the cost of an extended reduction pattern, similar to getArithmeticReductionCost of a reduction with an extension. </p>
<p>This is the cost of as: ResTy vecreduce.opcode(ext(Ty A)). </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01069">1069</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

</div>
</div>
<a id="acbea7151f5e66776f92f7b4e305418d6" name="acbea7151f5e66776f92f7b4e305418d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbea7151f5e66776f92f7b4e305418d6">&#9670;&#160;</a></span>getExtractWithExtendCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getExtractWithExtendCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>VecTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The expected cost of a sign- or zero-extended vector extract. <a class="el" href="classllvm_1_1Use.html" title="A Use represents the edge between a Value definition and its users.">Use</a> Index = -1 to indicate that there is no information about the index value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00910">910</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l07104">llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator::adjustExtracts()</a>, and <a class="el" href="SLPVectorizer_8cpp_source.html#l08437">llvm::slpvectorizer::BoUpSLP::getTreeCost()</a>.</p>

</div>
</div>
<a id="a93e74cc1819ce2f8f151a1900284ce89" name="a93e74cc1819ce2f8f151a1900284ce89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e74cc1819ce2f8f151a1900284ce89">&#9670;&#160;</a></span>getFlatAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getFlatAddressSpace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the address space ID for a target's 'flat' address space. </p>
<p>Note this is not necessarily the same as addrspace(0), which LLVM sometimes refers to as the generic address space. The flat address space is a generic address space that can be used access multiple segments of memory with different address spaces. Access of a memory location through a pointer with this address space is expected to be legal but slower compared to the same memory location accessed through a pointer with a different address space. This is for targets with different pointer representations which can be converted with the addrspacecast instruction. If a pointer is converted to this address space, optimizations should attempt to replace the access with the source address space.</p>
<dl class="section return"><dt>Returns</dt><dd>~0u if the target does not have such a flat address space to optimize away. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00288">288</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ad3b0e7df7704fa34e356e1178374b49e" name="ad3b0e7df7704fa34e356e1178374b49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b0e7df7704fa34e356e1178374b49e">&#9670;&#160;</a></span>getFPOpCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getFPOpCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the expected cost of supporting the floating point operation of the specified type. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00628">628</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>.</p>

</div>
</div>
<a id="aa0f4a801858ac7255f623ca0ec53394f" name="aa0f4a801858ac7255f623ca0ec53394f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f4a801858ac7255f623ca0ec53394f">&#9670;&#160;</a></span>getGatherScatterOpCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getGatherScatterOpCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>VariableMask</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of Gather or Scatter operation <code>Opcode</code> - is a type of memory access Load or Store <code>DataTy</code> - a vector type of the data to be loaded or stored <code>Ptr</code> - pointer [or vector of pointers] - address[es] in memory <code>VariableMask</code> - true when the memory access is predicated with a mask that is not a compile-time constant <code>Alignment</code> - alignment of single element <code>I</code> - the optional original context instruction, if one exists, e.g. the load/store to transform or the call to the gather/scatter intrinsic </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00992">992</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="TargetLibraryInfo_8cpp_source.html#l00064">Ptr</a>.</p>

</div>
</div>
<a id="a57fca44604259f23a346fdc969aaefeb" name="a57fca44604259f23a346fdc969aaefeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fca44604259f23a346fdc969aaefeb">&#9670;&#160;</a></span>getGEPCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getGEPCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>PointeeType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Operands</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>AccessType</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba7f80055e1969cb850739546467460ad8">TCK_SizeAndLatency</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the cost of a GEP operation when lowered. </p>
<p><code>PointeeType</code> is the source element type of the GEP. <code>Ptr</code> is the base pointer operand. <code>Operands</code> is the list of indices following the base pointer.</p>
<p><code>AccessType</code> is a hint as to what type of memory might be accessed by users of the GEP. getGEPCost will use it to determine if the GEP can be folded into the addressing mode of a load/store. If AccessType is null, then the resulting target type based off of PointeeType will be used as an approximation. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00229">229</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, <a class="el" href="MIRNamerPass_8cpp_source.html#l00074">Operands</a>, and <a class="el" href="TargetLibraryInfo_8cpp_source.html#l00064">Ptr</a>.</p>

<p class="reference">Referenced by <a class="el" href="NaryReassociate_8cpp_source.html#l00328">isGEPFoldable()</a>, and <a class="el" href="StraightLineStrengthReduce_8cpp_source.html#l00285">isGEPFoldable()</a>.</p>

</div>
</div>
<a id="acd2f1ef61f1c352da3b8121d4ea2c585" name="acd2f1ef61f1c352da3b8121d4ea2c585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2f1ef61f1c352da3b8121d4ea2c585">&#9670;&#160;</a></span>getGISelRematGlobalCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getGISelRematGlobalCost </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size cost of rematerializing a <a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> address relative to a stack reload. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01219">1219</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TargetLoweringBase_8cpp_source.html#l02363">llvm::TargetLoweringBase::shouldLocalize()</a>.</p>

</div>
</div>
<a id="aa30e16357eef0a6bb3dc98fb7fd67684" name="aa30e16357eef0a6bb3dc98fb7fd67684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30e16357eef0a6bb3dc98fb7fd67684">&#9670;&#160;</a></span>getInlinerVectorBonusPercent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TargetTransformInfo::getInlinerVectorBonusPercent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Vector bonus in percent.</dd></dl>
<p>Vector bonuses: We want to more aggressively inline vector-dense kernels and apply this bonus based on the percentage of vector instructions. A bonus is applied if the vector instructions exceed 50% and half that amount is applied if it exceeds 10%. Note that these bonuses are some what arbitrary and evolved over time by accident as much as because they are principled bonuses. FIXME: It would be nice to base the bonus values on something more scientific. A target may has no bonus on vector instructions. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00225">225</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="aab827381fb7034818435387572088683" name="aab827381fb7034818435387572088683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab827381fb7034818435387572088683">&#9670;&#160;</a></span>getInliningThresholdMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getInliningThresholdMultiplier </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A value by which our inlining threshold should be multiplied. This is primarily used to bump up the inlining threshold wholesale on targets where calls are unusually expensive.</dd></dl>
<p>TODO: This is a rather blunt instrument. Perhaps altering the costs of individual classes of instructions would be better. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00211">211</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ac77dbedcfd916a5c9b58e753b2678a98" name="ac77dbedcfd916a5c9b58e753b2678a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77dbedcfd916a5c9b58e753b2678a98">&#9670;&#160;</a></span>getInstructionCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getInstructionCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1User.html">User</a> *</td>          <td class="paramname"><span class="paramname"><em>U</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Operands</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the cost of a given IR user when lowered. </p>
<p>This can estimate the cost of either a <a class="el" href="classllvm_1_1ConstantExpr.html" title="A constant value that is initialized with an expression using other constant values.">ConstantExpr</a> or <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> when lowered.</p>
<p><code>Operands</code> is a list of operands which can be a result of transformations of the current operands. The number of the operands on the list must equal to the number of the current operands the IR user has. Their order on the list must be the same as the order of the current operands the IR user has.</p>
<p>The returned cost is defined in terms of <code>TargetCostConstants</code>, see its comments for a detailed explanation of the cost values. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00251">251</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, <a class="el" href="MIRNamerPass_8cpp_source.html#l00074">Operands</a>, and <a class="el" href="TargetTransformInfo_8h_source.html#l00256">TCK_RecipThroughput</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeMetrics_8cpp_source.html#l00116">llvm::CodeMetrics::analyzeBasicBlock()</a>, <a class="el" href="LoopUnrollPass_8cpp_source.html#l00346">analyzeLoopUnrollCost()</a>, <a class="el" href="CallSiteSplitting_8cpp_source.html#l00186">canSplitCallSite()</a>, <a class="el" href="LoopFlatten_8cpp_source.html#l00541">checkOuterLoopInsts()</a>, <a class="el" href="SpeculativeExecution_8cpp_source.html#l00213">llvm::ComputeSpeculationCost()</a>, <a class="el" href="SimplifyCFG_8cpp_source.html#l00384">computeSpeculationCost()</a>, <a class="el" href="FunctionSpecialization_8cpp_source.html#l00106">estimateBasicBlocks()</a>, <a class="el" href="SimpleLoopUnswitch_8cpp_source.html#l03265">findBestNonTrivialUnswitchCandidate()</a>, <a class="el" href="SimplifyCFG_8cpp_source.html#l03686">llvm::FoldBranchToCommonDest()</a>, <a class="el" href="IROutliner_8cpp_source.html#l00487">llvm::OutlinableRegion::getBenefit()</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l00405">getInstructionCost()</a>, <a class="el" href="JumpThreading_8cpp_source.html#l00435">getJumpThreadDuplicationCost()</a>, <a class="el" href="HotColdSplitting_8cpp_source.html#l00210">getOutliningBenefit()</a>, <a class="el" href="FunctionSpecialization_8cpp_source.html#l00155">llvm::InstCostVisitor::getUserBonus()</a>, <a class="el" href="LICM_8cpp_source.html#l01348">isFoldableInLoop()</a>, <a class="el" href="SimplifyCFG_8cpp_source.html#l03879">mergeConditionalStoreToAddress()</a>, and <a class="el" href="CostModel_8cpp_source.html#l00123">llvm::CostModelPrinterPass::run()</a>.</p>

</div>
</div>
<a id="a3e2a0583912318be02194abf401fdf1e" name="a3e2a0583912318be02194abf401fdf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2a0583912318be02194abf401fdf1e">&#9670;&#160;</a></span>getInstructionCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> llvm::TargetTransformInfo::getInstructionCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1User.html">User</a> *</td>          <td class="paramname"><span class="paramname"><em>U</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a helper function which calls the three-argument getInstructionCost with <code>Operands</code> which are the current operands U has. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00405">405</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

<p class="reference">References <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, <a class="el" href="TargetTransformInfo_8cpp_source.html#l00251">getInstructionCost()</a>, and <a class="el" href="MIRNamerPass_8cpp_source.html#l00074">Operands</a>.</p>

</div>
</div>
<a id="a38000267bdb6bb25b9c33f9fd7053b1d" name="a38000267bdb6bb25b9c33f9fd7053b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38000267bdb6bb25b9c33f9fd7053b1d">&#9670;&#160;</a></span>getInterleavedMemoryOpCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getInterleavedMemoryOpCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>VecTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Factor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Indices</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddressSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>UseMaskForCond</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>UseMaskForGaps</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of the interleaved memory operation. <code>Opcode</code> is the memory operation code <code>VecTy</code> is the vector type of the interleaved access. <code>Factor</code> is the interleave factor <code>Indices</code> is the indices for interleaved load members (as interleaved load allows gaps) <code>Alignment</code> is the alignment of the memory operation <code>AddressSpace</code> is address space of the pointer. <code>UseMaskForCond</code> indicates if the memory access is predicated. <code>UseMaskForGaps</code> indicates if gaps should be masked. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01001">1001</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

</div>
</div>
<a id="aa8771f57e56c0bc0e9ace92ede634839" name="aa8771f57e56c0bc0e9ace92ede634839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8771f57e56c0bc0e9ace92ede634839">&#9670;&#160;</a></span>getIntImmCodeSizeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getIntImmCodeSizeCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Idx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Imm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the expected cost for the given integer when optimising for size. </p>
<p>This is different than the other integer immediate cost functions in that it is subtarget agnostic. This is useful when you e.g. target one ISA such as Aarch32 but smaller encodings could be possible with another such as Thumb. This return value is used as a penalty when the total costs for a constant is calculated (the bigger the cost, the more beneficial constant hoisting is). </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00634">634</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00353">Idx</a>.</p>

</div>
</div>
<a id="a8f708e28c4cf4fcdbbe363849b779a00" name="a8f708e28c4cf4fcdbbe363849b779a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f708e28c4cf4fcdbbe363849b779a00">&#9670;&#160;</a></span>getIntImmCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getIntImmCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Imm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the expected cost of materializing for the given integer immediate of the specified type. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00644">644</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeGenPrepare_8cpp_source.html#l07935">tryUnmergingGEPsAcrossIndirectBr()</a>.</p>

</div>
</div>
<a id="a6c5798a479ce88e66e1b53d70d678332" name="a6c5798a479ce88e66e1b53d70d678332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5798a479ce88e66e1b53d70d678332">&#9670;&#160;</a></span>getIntImmCostInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getIntImmCostInst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Idx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Imm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>Inst</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the expected cost of materialization for the given integer immediate of the specified type for a given instruction. </p>
<p>The cost can be zero if the immediate can be folded into the specified instruction. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00651">651</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, and <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00353">Idx</a>.</p>

</div>
</div>
<a id="a6abe636878bffb348ed313016ab1c21b" name="a6abe636878bffb348ed313016ab1c21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abe636878bffb348ed313016ab1c21b">&#9670;&#160;</a></span>getIntImmCostIntrin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getIntImmCostIntrin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a></td>          <td class="paramname"><span class="paramname"><em>IID</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Idx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Imm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00661">661</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, and <a class="el" href="DeadArgumentElimination_8cpp_source.html#l00353">Idx</a>.</p>

</div>
</div>
<a id="a4218f47749d093473e680ad0199fb239" name="a4218f47749d093473e680ad0199fb239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4218f47749d093473e680ad0199fb239">&#9670;&#160;</a></span>getIntrinsicInstrCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getIntrinsicInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1IntrinsicCostAttributes.html">IntrinsicCostAttributes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ICA</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of <a class="el" href="namespacellvm_1_1Intrinsic.html" title="This namespace contains an enum with a value for every intrinsic/builtin function known by LLVM.">Intrinsic</a> instructions. Analyses the real arguments. Three cases are handled: 1. scalar instruction 2. vector instruction<ol type="1">
<li>scalar instruction which is to be vectorized. </li>
</ol>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01013">1013</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l08166">llvm::slpvectorizer::BoUpSLP::getSpillCost()</a>, <a class="el" href="SLPVectorizer_8cpp_source.html#l06336">getVectorCallCosts()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l03527">llvm::LoopVectorizationCostModel::getVectorIntrinsicCost()</a>, <a class="el" href="CostModel_8cpp_source.html#l00123">llvm::CostModelPrinterPass::run()</a>, and <a class="el" href="AggressiveInstCombine_8cpp_source.html#l00346">tryToFPToSat()</a>.</p>

</div>
</div>
<a id="a5c9d2da3e41e4cc90c7a552258166277" name="a5c9d2da3e41e4cc90c7a552258166277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9d2da3e41e4cc90c7a552258166277">&#9670;&#160;</a></span>getLoadStoreVecRegBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getLoadStoreVecRegBitWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The bitwidth of the largest vector type that should be used to load/store in the given address space. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01141">1141</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a84e51850e7e39c4bd2424ad98c12e700" name="a84e51850e7e39c4bd2424ad98c12e700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e51850e7e39c4bd2424ad98c12e700">&#9670;&#160;</a></span>getLoadVectorFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getLoadVectorFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>VF</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>LoadSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ChainSizeInBytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>VecTy</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The new vector factor value if the target doesn't support <code>SizeInBytes</code> loads or has a better vector factor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01174">1174</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a8718d4f9740c67449057887b386fb348" name="a8718d4f9740c67449057887b386fb348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8718d4f9740c67449057887b386fb348">&#9670;&#160;</a></span>getMaskedMemoryOpCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getMaskedMemoryOpCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddressSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of masked Load and Store instructions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00983">983</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

</div>
</div>
<a id="a785bcc5cab17bd5d96f800247dad0649" name="a785bcc5cab17bd5d96f800247dad0649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785bcc5cab17bd5d96f800247dad0649">&#9670;&#160;</a></span>getMaximumVF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMaximumVF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ElemWidth</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The maximum vectorization factor for types of given element bit width and opcode, or 0 if there is no maximum VF. Currently only used by the SLP vectorizer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00714">714</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l01264">llvm::slpvectorizer::BoUpSLP::getMaximumVF()</a>.</p>

</div>
</div>
<a id="ac8c60443d89e7ed0d199dfddafd5885f" name="ac8c60443d89e7ed0d199dfddafd5885f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c60443d89e7ed0d199dfddafd5885f">&#9670;&#160;</a></span>getMaxInterleaveFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMaxInterleaveFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ElementCount.html">ElementCount</a></td>          <td class="paramname"><span class="paramname"><em>VF</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The maximum interleave factor that any transform should try to perform for this target. This number depends on the level of parallelism and the number of execution units in the CPU. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00768">768</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l05603">llvm::LoopVectorizationCostModel::isEpilogueVectorizationProfitable()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l10620">llvm::LoopVectorizePass::runImpl()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l05801">llvm::LoopVectorizationCostModel::selectInterleaveCount()</a>.</p>

</div>
</div>
<a id="af202c774afe951c5c841c5bf356efaae" name="af202c774afe951c5c841c5bf356efaae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af202c774afe951c5c841c5bf356efaae">&#9670;&#160;</a></span>getMaxMemIntrinsicInlineSizeThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint64__t.html">uint64_t</a> TargetTransformInfo::getMaxMemIntrinsicInlineSizeThreshold </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum memset / memcpy size in bytes that still makes it profitable to inline the call. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01047">1047</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a0a234a5bae6ee891cc95421752592ec7" name="a0a234a5bae6ee891cc95421752592ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a234a5bae6ee891cc95421752592ec7">&#9670;&#160;</a></span>getMaxNumArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMaxNumArgs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The maximum number of function arguments the target supports. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01211">1211</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ArgumentPromotion_8cpp_source.html#l00682">promoteArguments()</a>.</p>

</div>
</div>
<a id="a66cb8d0f215f1b7b66e4a7d6581b3a16" name="a66cb8d0f215f1b7b66e4a7d6581b3a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cb8d0f215f1b7b66e4a7d6581b3a16">&#9670;&#160;</a></span>getMaxPrefetchIterationsAhead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMaxPrefetchIterationsAhead </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The maximum number of iterations to prefetch ahead. If the required number of iterations is more than this number, no prefetching is performed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00756">756</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a3586d4f687e1a068f879bf29b046eb3a" name="a3586d4f687e1a068f879bf29b046eb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3586d4f687e1a068f879bf29b046eb3a">&#9670;&#160;</a></span>getMaxVScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; TargetTransformInfo::getMaxVScale </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The maximum value of vscale if the target specifies an architectural maximum vector length, and std::nullopt otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00692">692</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l02483">getMaxVScale()</a>.</p>

</div>
</div>
<a id="a7cd4d71624770e0e121a19b1efd26e52" name="a7cd4d71624770e0e121a19b1efd26e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd4d71624770e0e121a19b1efd26e52">&#9670;&#160;</a></span>getMemcpyCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getMemcpyCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the expected cost of a memcpy, which could e.g. depend on the source/destination type and alignment and the number of bytes copied. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01041">1041</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="ae027119490c2c4cfbb11092a28832cac" name="ae027119490c2c4cfbb11092a28832cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae027119490c2c4cfbb11092a28832cac">&#9670;&#160;</a></span>getMemcpyLoopLoweringType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Type.html">Type</a> * TargetTransformInfo::getMemcpyLoopLoweringType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>SrcAddrSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DestAddrSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>SrcAlign</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DestAlign</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classuint32__t.html">uint32_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>AtomicElementSize</em><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The type to use in a loop expansion of a memcpy call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01101">1101</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="DWP_8cpp_source.html#l00440">llvm::Length</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerMemIntrinsics_8cpp_source.html#l00023">llvm::createMemCpyLoopKnownSize()</a>.</p>

</div>
</div>
<a id="a13609bc726de8e7758fd9d6c8bc67c94" name="a13609bc726de8e7758fd9d6c8bc67c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13609bc726de8e7758fd9d6c8bc67c94">&#9670;&#160;</a></span>getMemcpyLoopResidualLoweringType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">void</a> TargetTransformInfo::getMemcpyLoopResidualLoweringType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OpsOut</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Context</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>RemainingBytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>SrcAddrSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DestAddrSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>SrcAlign</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>DestAlign</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classuint32__t.html">uint32_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>AtomicCpySize</em><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">OpsOut</td><td>The operand types to copy RemainingBytes of memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">RemainingBytes</td><td>The number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>Calculates the operand types to use when copying <code>RemainingBytes</code> of memory, where source and destination alignments are <code>SrcAlign</code> and <code>DestAlign</code> respectively. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01110">1110</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerMemIntrinsics_8cpp_source.html#l00023">llvm::createMemCpyLoopKnownSize()</a>.</p>

</div>
</div>
<a id="a34c987c590db0e5cff66d9869a34c556" name="a34c987c590db0e5cff66d9869a34c556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c987c590db0e5cff66d9869a34c556">&#9670;&#160;</a></span>getMemoryOpCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getMemoryOpCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddressSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1OperandValueInfo.html">TTI::OperandValueInfo</a></td>          <td class="paramname"><span class="paramname"><em>OpInfo</em><span class="paramdefsep"> = </span><span class="paramdefval">{<a class="el" href="#afa38851d75434d1476444ac93f94cb4ca9c0eecea29e9fa58e4dac7ee32b9b2ac">OK_AnyValue</a>,&#160;<a class="el" href="#a733fb237f3037c95ed59de6055b176c5a2bc39e3785b29fe7bc4af768842a2072">OP_None</a>}</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of Load and Store instructions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00971">971</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="IROutliner_8cpp_source.html#l02557">findCostForOutputBlocks()</a>.</p>

</div>
</div>
<a id="a6a94a8710c9c41b64870559c9098f305" name="a6a94a8710c9c41b64870559c9098f305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a94a8710c9c41b64870559c9098f305">&#9670;&#160;</a></span>getMinimumVF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ElementCount.html">ElementCount</a> TargetTransformInfo::getMinimumVF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ElemWidth</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsScalable</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The minimum vectorization factor for types of given element bit width, or 0 if there is no minimum VF. The returned value only applies when shouldMaximizeVectorBandwidth returns true. If IsScalable is true, the returned <a class="el" href="classllvm_1_1ElementCount.html">ElementCount</a> must be a scalable VF. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00709">709</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a6da1f2e3b471cce50680e800c05e4d6b" name="a6da1f2e3b471cce50680e800c05e4d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da1f2e3b471cce50680e800c05e4d6b">&#9670;&#160;</a></span>getMinMaxReductionCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getMinMaxReductionCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">Intrinsic::ID</a></td>          <td class="paramname"><span class="paramname"><em>IID</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1FastMathFlags.html">FastMathFlags</a></td>          <td class="paramname"><span class="paramname"><em>FMF</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1FastMathFlags.html">FastMathFlags</a>()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01060">1060</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

</div>
</div>
<a id="a8dcadecc95e9e49f77a70ab8b99a8c35" name="a8dcadecc95e9e49f77a70ab8b99a8c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcadecc95e9e49f77a70ab8b99a8c35">&#9670;&#160;</a></span>getMinPrefetchStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMinPrefetchStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumMemAccesses</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumStridedMemAccesses</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>NumPrefetches</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>HasCall</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some HW prefetchers can handle accesses up to a certain constant stride. </p>
<p>Sometimes prefetching is beneficial even below the HW prefetcher limit, and the arguments provided are meant to serve as a basis for deciding this for a particular loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumMemAccesses</td><td>Number of memory accesses in the loop. </td></tr>
    <tr><td class="paramname">NumStridedMemAccesses</td><td>Number of the memory accesses that <a class="el" href="classllvm_1_1ScalarEvolution.html" title="The main scalar evolution driver.">ScalarEvolution</a> could find a known stride for. </td></tr>
    <tr><td class="paramname">NumPrefetches</td><td>Number of software prefetches that will be emitted as determined by the addresses involved and the cache line size. </td></tr>
    <tr><td class="paramname">HasCall</td><td>True if the loop contains a call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is the minimum stride in bytes where it makes sense to start adding SW prefetches. The default is 1, i.e. prefetch with any stride. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00749">749</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ac50791ac3dd33dc3dc522df16116a27b" name="ac50791ac3dd33dc3dc522df16116a27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50791ac3dd33dc3dc522df16116a27b">&#9670;&#160;</a></span>getMinTripCountTailFoldingThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMinTripCountTailFoldingThreshold </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the lower bound of a trip count to decide on vectorization while tail-folding. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01223">1223</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l10181">llvm::LoopVectorizePass::processLoop()</a>.</p>

</div>
</div>
<a id="a8fa8b3631e74e836453f972aac6b4b65" name="a8fa8b3631e74e836453f972aac6b4b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa8b3631e74e836453f972aac6b4b65">&#9670;&#160;</a></span>getMinVectorRegisterBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getMinVectorRegisterBitWidth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The width of the smallest vector register type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00688">688</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l01105">llvm::slpvectorizer::BoUpSLP::BoUpSLP()</a>, and <a class="el" href="VectorCombine_8cpp_source.html#l00131">canWidenLoad()</a>.</p>

</div>
</div>
<a id="a61fd571365b64379faf5eb0b3caa1b27" name="a61fd571365b64379faf5eb0b3caa1b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fd571365b64379faf5eb0b3caa1b27">&#9670;&#160;</a></span>getMulAccReductionCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getMulAccReductionCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsUnsigned</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>ResTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the cost of an extended reduction pattern, similar to getArithmeticReductionCost of an Add reduction with multiply and optional extensions. </p>
<p>This is the cost of as: ResTy vecreduce.add(mul (A, B)). ResTy vecreduce.add(mul(ext(Ty A), ext(Ty B)). </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01076">1076</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

</div>
</div>
<a id="ad67b7e389a52ada1d5264e23d09f4cbe" name="ad67b7e389a52ada1d5264e23d09f4cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67b7e389a52ada1d5264e23d09f4cbe">&#9670;&#160;</a></span>getNumberOfParts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getNumberOfParts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Tp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of pieces into which the provided type must be split during legalization. Zero is returned when the answer is unknown. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01029">1029</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l07104">llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator::adjustExtracts()</a>, and <a class="el" href="SLPVectorizer_8cpp_source.html#l11180">llvm::slpvectorizer::BoUpSLP::optimizeGatherSequence()</a>.</p>

</div>
</div>
<a id="aae0e8ca52658f54e5cc6214eb1a291ef" name="aae0e8ca52658f54e5cc6214eb1a291ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0e8ca52658f54e5cc6214eb1a291ef">&#9670;&#160;</a></span>getNumberOfRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getNumberOfRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ClassID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of registers in the target-provided register class. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00670">670</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l10620">llvm::LoopVectorizePass::runImpl()</a>, <a class="el" href="SLPVectorizer_8cpp_source.html#l12219">llvm::SLPVectorizerPass::runImpl()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l05801">llvm::LoopVectorizationCostModel::selectInterleaveCount()</a>.</p>

</div>
</div>
<a id="a5fecba95c1ba20950ea8e2139127e621" name="a5fecba95c1ba20950ea8e2139127e621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fecba95c1ba20950ea8e2139127e621">&#9670;&#160;</a></span>getOperandInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1OperandValueInfo.html">TargetTransformInfo::OperandValueInfo</a> TargetTransformInfo::getOperandInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect properties of V used in cost analysis, e.g. OP_PowerOf2. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00773">773</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00242">llvm::getSplatValue()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l01013">OK_AnyValue</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l01016">OK_NonUniformConstantValue</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l01015">OK_UniformConstantValue</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l01014">OK_UniformValue</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l01023">OP_NegatedPowerOf2</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l01021">OP_None</a>, <a class="el" href="TargetTransformInfo_8h_source.html#l01022">OP_PowerOf2</a>, and <a class="el" href="namespacellvm.html#a766456df1dd21e804cd4596304e10764a5b9bf50c6579a978e5c1104bf8787651">llvm::Splat</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l04509">llvm::LoopVectorizationCostModel::getDivRemSpeculationCost()</a>, <a class="el" href="TargetTransformInfoImpl_8h_source.html#l01104">llvm::TargetTransformInfoImplCRTPBase&lt; T &gt;::getInstructionCost()</a>, <a class="el" href="BasicTTIImpl_8h_source.html#l01483">llvm::BasicTTIImplBase&lt; T &gt;::getIntrinsicInstrCost()</a>, and <a class="el" href="AArch64TargetTransformInfo_8cpp_source.html#l00395">llvm::AArch64TTIImpl::getIntrinsicInstrCost()</a>.</p>

</div>
</div>
<a id="a296acd14b143ce1e1b0db86f4c221662" name="a296acd14b143ce1e1b0db86f4c221662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296acd14b143ce1e1b0db86f4c221662">&#9670;&#160;</a></span>getOperandsScalarizationOverhead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getOperandsScalarizationOverhead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Args</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Type.html">Type</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Tys</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the overhead of scalarizing an instructions unique non-constant operands. </p>
<p>The (potentially vector) types to use for each of argument are passes via Tys. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00556">556</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

</div>
</div>
<a id="ad5e18a8730e428b4967b375d57c2e401" name="ad5e18a8730e428b4967b375d57c2e401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e18a8730e428b4967b375d57c2e401">&#9670;&#160;</a></span>getOrCreateResultFromMemIntrinsic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Value.html">Value</a> * TargetTransformInfo::getOrCreateResultFromMemIntrinsic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Inst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>ExpectedType</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A value which is the result of the given memory intrinsic. New instructions may be created to extract the result from the given intrinsic memory operation. Returns nullptr if the target cannot create a result from the given intrinsic. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01096">1096</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="af513fb5e9b4731b5b8315d757d5a252f" name="af513fb5e9b4731b5b8315d757d5a252f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af513fb5e9b4731b5b8315d757d5a252f">&#9670;&#160;</a></span>getPeelingPreferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">void</a> TargetTransformInfo::getPeelingPreferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Loop.html">Loop</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SE</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1PeelingPreferences.html">PeelingPreferences</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>PP</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target-customized preferences for the generic loop peeling transformation. </p>
<p>The caller will initialize <code>PP</code> with the current target-independent defaults with information from <code>L</code> and <code>SE</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00374">374</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopPeel_8cpp_source.html#l00828">llvm::gatherPeelingPreferences()</a>.</p>

</div>
</div>
<a id="a75bdd6764746631f64902145e7dd7872" name="a75bdd6764746631f64902145e7dd7872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bdd6764746631f64902145e7dd7872">&#9670;&#160;</a></span>getPointersChainCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getPointersChainCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Ptrs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Base</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1TargetTransformInfo_1_1PointersChainInfo.html">PointersChainInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Info</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>AccessTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the cost of a chain of pointers (typically pointer operands of a chain of loads or stores within same block) operations set when lowered. </p>
<p><code>AccessTy</code> is the type of the loads/stores that will ultimately use the <code>Ptrs</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00235">235</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Discriminator_8h_source.html#l00058">llvm::sampleprof::Base</a>, and <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

</div>
</div>
<a id="a6480799b120b617b9b34f1313afe6661" name="a6480799b120b617b9b34f1313afe6661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6480799b120b617b9b34f1313afe6661">&#9670;&#160;</a></span>getPopcntSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa4c17e89b1ef061ed69f42b7cee93dbe">TargetTransformInfo::PopcntSupportKind</a> TargetTransformInfo::getPopcntSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>IntTyWidthInBit</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return hardware support for population count. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00611">611</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a5aa721827d7115203f1eb5a3479e7d5e" name="a5aa721827d7115203f1eb5a3479e7d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa721827d7115203f1eb5a3479e7d5e">&#9670;&#160;</a></span>getPredicatedAddrSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *, <a class="el" href="classunsigned.html">unsigned</a> &gt; TargetTransformInfo::getPredicatedAddrSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00316">316</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a99b320fd35acaf648a0a7826a0bdd777" name="a99b320fd35acaf648a0a7826a0bdd777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b320fd35acaf648a0a7826a0bdd777">&#9670;&#160;</a></span>getPredictableBranchThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1BranchProbability.html">BranchProbability</a> TargetTransformInfo::getPredictableBranchThreshold </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a branch or a select condition is skewed in one direction by more than this factor, it is very likely to be predicted correctly. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00260">260</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="TargetTransformInfo_8cpp.html#a8e2625c3d933e9755aa91dbbaadd5eb5">PredictableBranchThreshold</a>.</p>

<p class="reference">Referenced by <a class="el" href="SimplifyCFG_8cpp_source.html#l03292">FoldTwoEntryPHINode()</a>, <a class="el" href="CodeGenPrepare_8cpp_source.html#l06796">isFormingBranchFromSelectProfitable()</a>, and <a class="el" href="SimplifyCFG_8cpp_source.html#l03525">shouldFoldCondBranchesToCommonDestination()</a>.</p>

</div>
</div>
<a id="aa89a5a037e90eef4edcffea07a423748" name="aa89a5a037e90eef4edcffea07a423748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89a5a037e90eef4edcffea07a423748">&#9670;&#160;</a></span>getPreferredAddressingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad88649498463e1fe02380ad98886ce43">TTI::AddressingModeKind</a> TargetTransformInfo::getPreferredAddressingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Loop.html">Loop</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *</td>          <td class="paramname"><span class="paramname"><em>SE</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the preferred addressing mode LSR should make efforts to generate. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00421">421</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a579a550a75fcdd6ebdb773fb2efd10de" name="a579a550a75fcdd6ebdb773fb2efd10de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579a550a75fcdd6ebdb773fb2efd10de">&#9670;&#160;</a></span>getPreferredTailFoldingStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacellvm.html#ada31142763d41520644d228c139a4bdd">TailFoldingStyle</a> TargetTransformInfo::getPreferredTailFoldingStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IVUpdateMayOverflow</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="BasicAliasAnalysis_8cpp.html#af6d5cafbdfc5313e65d990120021a3ec">true</a></span></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target what the preferred style of tail folding is. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IVUpdateMayOverflow</td><td>Tells whether it is known if the IV update may (or will never) overflow for the suggested VF/UF in the given loop. Targets can use this information to select a more optimal tail folding style. The value conservatively defaults to true, such that no assumptions are made on overflow. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00340">340</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l01587">llvm::LoopVectorizationCostModel::getTailFoldingStyle()</a>.</p>

</div>
</div>
<a id="a1e3f3a3d549cf057479e744e7ecfd7e1" name="a1e3f3a3d549cf057479e744e7ecfd7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3f3a3d549cf057479e744e7ecfd7e1">&#9670;&#160;</a></span>getPrefetchDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getPrefetchDistance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>How much before a load we should place the prefetch instruction. This is currently measured in number of instructions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00745">745</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a2d30dd50c6b2d64ca3bc2826ca229fdb" name="a2d30dd50c6b2d64ca3bc2826ca229fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d30dd50c6b2d64ca3bc2826ca229fdb">&#9670;&#160;</a></span>getRegisterBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1TypeSize.html">TypeSize</a> TargetTransformInfo::getRegisterBitWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8bb3b1ccf19b8c85429b777dfa4a0166">TargetTransformInfo::RegisterKind</a></td>          <td class="paramname"><span class="paramname"><em>K</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The width of the largest scalar or vector register type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00683">683</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l01105">llvm::slpvectorizer::BoUpSLP::BoUpSLP()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l07551">llvm::LoopVectorizationPlanner::planInVPlanNativePath()</a>.</p>

</div>
</div>
<a id="a623cced59353f83cc5eaba4068c57694" name="a623cced59353f83cc5eaba4068c57694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623cced59353f83cc5eaba4068c57694">&#9670;&#160;</a></span>getRegisterClassForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getRegisterClassForType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>Vector</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the target-provided register class ID for the provided type, accounting for type promotion and other type-legalization techniques that the target might apply. However, it specifically does not account for the scalarization or splitting of vector types. Should a vector type require scalarization or splitting into multiple underlying vector registers, that type should be mapped to a register class containing no registers. Specifically, this is designed to provide a simple, high-level view of the register allocation later performed by the backend. These register classes don't necessarily map onto the register classes used by the backend. FIXME: It's not currently possible to determine how many registers are used by the provided type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00674">674</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacellvm.html#add480f2ed87faa59c16d4c01ffb4bf39a57dea6f5039281b7fee517fc43bf3110">llvm::Vector</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l06048">llvm::LoopVectorizationCostModel::calculateRegisterUsage()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l10620">llvm::LoopVectorizePass::runImpl()</a>, and <a class="el" href="SLPVectorizer_8cpp_source.html#l12219">llvm::SLPVectorizerPass::runImpl()</a>.</p>

</div>
</div>
<a id="a97503ae3ef00c5f1eaffa5bbeb0a4357" name="a97503ae3ef00c5f1eaffa5bbeb0a4357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97503ae3ef00c5f1eaffa5bbeb0a4357">&#9670;&#160;</a></span>getRegisterClassName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classchar.html">char</a> * TargetTransformInfo::getRegisterClassName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ClassID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the target-provided register class name </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00679">679</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l06048">llvm::LoopVectorizationCostModel::calculateRegisterUsage()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l05801">llvm::LoopVectorizationCostModel::selectInterleaveCount()</a>.</p>

</div>
</div>
<a id="a5a6989eb41033f67be080858c27d840a" name="a5a6989eb41033f67be080858c27d840a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6989eb41033f67be080858c27d840a">&#9670;&#160;</a></span>getRegUsageForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getRegUsageForType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the estimated number of registers required to represent <code>Ty</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00528">528</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a0d10bacb766fd94e20c1af0bfd52b9bd" name="a0d10bacb766fd94e20c1af0bfd52b9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d10bacb766fd94e20c1af0bfd52b9bd">&#9670;&#160;</a></span>getReplicationShuffleCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getReplicationShuffleCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>EltTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ReplicationFactor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>VF</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DemandedDstElts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of replication shuffle of <code>VF</code> elements typed <code>EltTy</code> <code>ReplicationFactor</code> times.</dd></dl>
<p>For example, the mask for <code>ReplicationFactor=3</code> and <code>VF=4</code> is: &lt;0,0,0,1,1,1,2,2,2,3,3,3&gt; </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00962">962</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

</div>
</div>
<a id="ae7fe2d1bb4f708d68fe7a908ba675d1b" name="ae7fe2d1bb4f708d68fe7a908ba675d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fe2d1bb4f708d68fe7a908ba675d1b">&#9670;&#160;</a></span>getScalarizationOverhead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getScalarizationOverhead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DemandedElts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>Insert</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>Extract</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the overhead of scalarizing an instruction. </p>
<p>Insert and Extract are set if the demanded result elements need to be inserted and/or extracted from vectors. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00549">549</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l08437">llvm::slpvectorizer::BoUpSLP::getTreeCost()</a>.</p>

</div>
</div>
<a id="a886c5c16f6fb41c44e57b24543f0dc7d" name="a886c5c16f6fb41c44e57b24543f0dc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886c5c16f6fb41c44e57b24543f0dc7d">&#9670;&#160;</a></span>getScalingFactorCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getScalingFactorCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *</td>          <td class="paramname"><span class="paramname"><em>BaseGV</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>BaseOffset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>HasBaseReg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Scale</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the cost of the scaling factor used in the addressing mode represented by AM for this target, for a load/store of the specified type. </p>
<p>If the AM is supported, the return value must be &gt;= 0. If the AM is not supported, it returns a negative value. TODO: Handle pre/postinc as well. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00501">501</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l01809">getScalingFactorCost()</a>.</p>

</div>
</div>
<a id="aa0519f26bcb15c25ac0ff557061fa7af" name="aa0519f26bcb15c25ac0ff557061fa7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0519f26bcb15c25ac0ff557061fa7af">&#9670;&#160;</a></span>getShuffleCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getShuffleCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af46433d0e36d3f80afc3a8c67b5c53ec">ShuffleKind</a></td>          <td class="paramname"><span class="paramname"><em>Kind</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>Tp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>Mask</em><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>Index</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>SubTp</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>Args</em><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of a shuffle instruction of kind Kind and of type Tp. The exact mask may be passed as Mask, or else the array will be empty. The index and subtype parameters are used by the subvector insertion and extraction shuffle kinds to show the insert/extract point and the type of the subvector being inserted/extracted. The operands of the shuffle can be passed through <code>Args</code>, which helps improve the cost estimation in some cases, like in broadcast loads. NOTE: For subvector extractions Tp represents the source type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00845">845</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l07104">llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator::adjustExtracts()</a>, <a class="el" href="SLPVectorizer_8cpp_source.html#l04081">llvm::slpvectorizer::BoUpSLP::getReorderingData()</a>, <a class="el" href="SLPVectorizer_8cpp_source.html#l08437">llvm::slpvectorizer::BoUpSLP::getTreeCost()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l03448">llvm::LoopVectorizationCostModel::getVectorCallCost()</a>.</p>

</div>
</div>
<a id="abdf352ba0545cdb2ad70f4d72b594cfa" name="abdf352ba0545cdb2ad70f4d72b594cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf352ba0545cdb2ad70f4d72b594cfa">&#9670;&#160;</a></span>getStoreMinimumVF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getStoreMinimumVF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>VF</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>ScalarMemTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>ScalarValTy</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The minimum vectorization factor for the store instruction. Given the initial estimation of the minimum vector factor and store value type, it tries to find possible lowest VF, which still might be profitable for the vectorization. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">VF</td><td>Initial estimation of the minimum vector factor. </td></tr>
    <tr><td class="paramname">ScalarMemTy</td><td>Scalar memory type of the store operation. </td></tr>
    <tr><td class="paramname">ScalarValTy</td><td>Scalar type of the stored value. Currently only used by the SLP vectorizer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00719">719</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a47da5df7f765cada1df9036a3433e1a4" name="a47da5df7f765cada1df9036a3433e1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47da5df7f765cada1df9036a3433e1a4">&#9670;&#160;</a></span>getStoreVectorFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetTransformInfo::getStoreVectorFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>VF</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>StoreSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ChainSizeInBytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>VecTy</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The new vector factor value if the target doesn't support <code>SizeInBytes</code> stores or has a better vector factor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01181">1181</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a02e4dcfc435f179592619b03330f643b" name="a02e4dcfc435f179592619b03330f643b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e4dcfc435f179592619b03330f643b">&#9670;&#160;</a></span>getTgtMemIntrinsic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::getTgtMemIntrinsic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Inst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1MemIntrinsicInfo.html">MemIntrinsicInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Info</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the intrinsic is a supported memory intrinsic. Info will contain additional information - whether the intrinsic may write or read to memory, volatility and the pointer. Info is undefined if false is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01087">1087</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l00897">getAccessType()</a>, and <a class="el" href="LoopStrengthReduce_8cpp_source.html#l00852">isAddressUse()</a>.</p>

</div>
</div>
<a id="a25f5cd1eed2a2102d7a012dbc5c08e1a" name="a25f5cd1eed2a2102d7a012dbc5c08e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f5cd1eed2a2102d7a012dbc5c08e1a">&#9670;&#160;</a></span>getUnrollingPreferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">void</a> TargetTransformInfo::getUnrollingPreferences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Loop.html">Loop</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SE</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1UnrollingPreferences.html">UnrollingPreferences</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UP</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1OptimizationRemarkEmitter.html">OptimizationRemarkEmitter</a> *</td>          <td class="paramname"><span class="paramname"><em>ORE</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get target-customized preferences for the generic loop unrolling transformation. </p>
<p>The caller will initialize UP with the current target-independent defaults. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00368">368</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l07729">llvm::LoopVectorizationPlanner::executePlan()</a>, and <a class="el" href="LoopUnrollPass_8cpp_source.html#l00183">llvm::gatherUnrollingPreferences()</a>.</p>

</div>
</div>
<a id="a8faf795a9033768e63f8907829339ccf" name="a8faf795a9033768e63f8907829339ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8faf795a9033768e63f8907829339ccf">&#9670;&#160;</a></span>getVectorInstrCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getVectorInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Val</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Index</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The expected cost of vector Insert and Extract. This is used when instruction is available, and implementation asserts 'I' is not nullptr.</dd></dl>
<p>A typical suitable use case is cost estimation when vector instruction exists (e.g., from basic blocks during transformation). </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00951">951</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="af37b2842424eb63440bdcacca0af9820" name="af37b2842424eb63440bdcacca0af9820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37b2842424eb63440bdcacca0af9820">&#9670;&#160;</a></span>getVectorInstrCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> TargetTransformInfo::getVectorInstrCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Val</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Index</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Op0</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Op1</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The expected cost of vector Insert and Extract. <a class="el" href="classllvm_1_1Use.html" title="A Use represents the edge between a Value definition and its users.">Use</a> -1 to indicate that there is no information on the index value. This is used when the instruction is not available; a typical use case is to provision the cost of vectorization/scalarization in vectorizer passes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00938">938</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, and <a class="el" href="CostModel_8cpp.html#a162d8b2b3865594d1e14d828d2b8336a">CostKind</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l07104">llvm::slpvectorizer::BoUpSLP::ShuffleCostEstimator::adjustExtracts()</a>, <a class="el" href="SLPVectorizer_8cpp_source.html#l04081">llvm::slpvectorizer::BoUpSLP::getReorderingData()</a>, and <a class="el" href="SLPVectorizer_8cpp_source.html#l08437">llvm::slpvectorizer::BoUpSLP::getTreeCost()</a>.</p>

</div>
</div>
<a id="a4843aaa2647f4f1fb037f957beda8eaa" name="a4843aaa2647f4f1fb037f957beda8eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4843aaa2647f4f1fb037f957beda8eaa">&#9670;&#160;</a></span>getVPLegalizationStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1VPLegalization.html">TargetTransformInfo::VPLegalization</a> TargetTransformInfo::getVPLegalizationStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1VPIntrinsic.html">VPIntrinsic</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>PI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>How the target needs this vector-predicated operation to be transformed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01203">1203</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a846e472a2fb24cec08762c2c26624a35" name="a846e472a2fb24cec08762c2c26624a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846e472a2fb24cec08762c2c26624a35">&#9670;&#160;</a></span>getVPMemoryOpCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1InstructionCost.html">InstructionCost</a> llvm::TargetTransformInfo::getVPMemoryOpCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddressSpace</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a706f223f760b55668fbae74202b816bb">TTI::TargetCostKind</a></td>          <td class="paramname"><span class="paramname"><em>CostKind</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a706f223f760b55668fbae74202b816bba59b32ea7b6f10564abd40ad90602ca5b">TTI::TCK_RecipThroughput</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The cost of VP Load and Store instructions. </dd></dl>

</div>
</div>
<a id="a04394f31b3d57c89fd8211783a12736d" name="a04394f31b3d57c89fd8211783a12736d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04394f31b3d57c89fd8211783a12736d">&#9670;&#160;</a></span>getVScaleForTuning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; TargetTransformInfo::getVScaleForTuning </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the value of vscale to tune the cost model for. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00696">696</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l05363">getVScaleForTuning()</a>.</p>

</div>
</div>
<a id="aa3898235ae1cbefb03b09d1ddebae0e5" name="aa3898235ae1cbefb03b09d1ddebae0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3898235ae1cbefb03b09d1ddebae0e5">&#9670;&#160;</a></span>hasActiveVectorLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::hasActiveVectorLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01235">1235</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a959a58a9740a235c53703a287e722906" name="a959a58a9740a235c53703a287e722906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959a58a9740a235c53703a287e722906">&#9670;&#160;</a></span>hasArmWideBranch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::hasArmWideBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>Thumb</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether a 32-bit branch instruction is available in Arm or Thumb state.</dd></dl>
<p>Used by the LowerTypeTests pass, which constructs an IR inline assembler node containing a jump table in a format suitable for the target, so it needs to know what format of jump table it can legally use.</p>
<p>For non-Arm targets, this function isn't used. It defaults to returning false, but it shouldn't matter what it returns anyway. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01207">1207</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a233996b13b5fa2774af23282d8870204" name="a233996b13b5fa2774af23282d8870204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233996b13b5fa2774af23282d8870204">&#9670;&#160;</a></span>hasBranchDivergence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::hasBranchDivergence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>F</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if branch divergence exists. </p>
<p>Branch divergence has a significantly negative impact on GPU performance when threads in the same wavefront take different paths due to conditional branches.</p>
<p>If <code>F</code> is passed, provides a context function. If <code>F</code> is known to only execute in a single threaded environment, the target may choose to skip uniformity analysis and assume all values are uniform. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00266">266</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00055">F</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l05096">llvm::LoopVectorizationCostModel::computeMaxVF()</a>, <a class="el" href="UniformityAnalysis_8cpp_source.html#l00116">llvm::UniformityInfoAnalysis::run()</a>, <a class="el" href="JumpThreading_8cpp_source.html#l00245">llvm::JumpThreadingPass::run()</a>, <a class="el" href="SpeculativeExecution_8cpp_source.html#l00154">llvm::SpeculativeExecutionPass::runImpl()</a>, and <a class="el" href="SimpleLoopUnswitch_8cpp_source.html#l03533">unswitchLoop()</a>.</p>

</div>
</div>
<a id="ac31bf22f119c5a99c36646d8e0eb2c0f" name="ac31bf22f119c5a99c36646d8e0eb2c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31bf22f119c5a99c36646d8e0eb2c0f">&#9670;&#160;</a></span>hasDivRemOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::hasDivRemOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsSigned</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target has a unified operation to calculate division and remainder. </p>
<p>If so, the additional implicit multiplication and subtraction required to calculate a remainder from division are free. This can enable more aggressive transformations for division and remainder than would typically be allowed using throughput or size cost models. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00488">488</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DivRemPairs_8cpp_source.html#l00181">optimizeDivRem()</a>.</p>

</div>
</div>
<a id="ab33e1370498d06e0760c2861ff25e43a" name="ab33e1370498d06e0760c2861ff25e43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33e1370498d06e0760c2861ff25e43a">&#9670;&#160;</a></span>hasVolatileVariant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::hasVolatileVariant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the given instruction (assumed to be a memory access instruction) has a volatile variant. </p>
<p>If that's the case then we can avoid addrspacecast to generic AS for volatile loads/stores. Default implementation returns false, which prevents address space inference for volatile loads/stores. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00492">492</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="InferAddressSpaces_8cpp_source.html#l01001">isSimplePointerUseValidToReplace()</a>.</p>

</div>
</div>
<a id="aef998bb15ea045fc769232b62ad0d968" name="aef998bb15ea045fc769232b62ad0d968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef998bb15ea045fc769232b62ad0d968">&#9670;&#160;</a></span>haveFastSqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::haveFastSqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the hardware has a fast square-root instruction. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00615">615</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AggressiveInstCombine_8cpp_source.html#l00402">foldSqrt()</a>, and <a class="el" href="PartiallyInlineLibCalls_8cpp_source.html#l00104">runPartiallyInlineLibCalls()</a>.</p>

</div>
</div>
<a id="a2c34992cf5a6125fc637fbde99b88890" name="a2c34992cf5a6125fc637fbde99b88890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c34992cf5a6125fc637fbde99b88890">&#9670;&#160;</a></span>instCombineIntrinsic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * &gt; TargetTransformInfo::instCombineIntrinsic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>II</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Targets can implement their own combinations for target-specific intrinsics. </p>
<p>This function will be called from the InstCombine pass every time a target-specific intrinsic is encountered.</p>
<dl class="section return"><dt>Returns</dt><dd>std::nullopt to not do anything target specific or a value that will be returned from the <a class="el" href="classllvm_1_1InstCombiner.html" title="The core instruction combiner logic.">InstCombiner</a>. It is possible to return null and stop further processing of the intrinsic by returning nullptr. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00346">346</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstructionCombining_8cpp_source.html#l00169">llvm::InstCombiner::targetInstCombineIntrinsic()</a>.</p>

</div>
</div>
<a id="a2528c700b439460d668d188813ebf08c" name="a2528c700b439460d668d188813ebf08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2528c700b439460d668d188813ebf08c">&#9670;&#160;</a></span>invalidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetTransformInfo::invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1PreservedAnalyses.html">PreservedAnalyses</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1AnalysisManager_1_1Invalidator.html">FunctionAnalysisManager::Invalidator</a> &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the invalidation of this information. </p>
<p>When used as a result of <code><a class="el" href="classllvm_1_1TargetIRAnalysis.html" title="Analysis pass providing the TargetTransformInfo.">TargetIRAnalysis</a></code> this method will be called when the function this was computed for changes. When it returns false, the information is preserved across those changes. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l00239">239</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

</div>
</div>
<a id="a1b21625ceb4a9d9eb225fa18cbf951de" name="a1b21625ceb4a9d9eb225fa18cbf951de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b21625ceb4a9d9eb225fa18cbf951de">&#9670;&#160;</a></span>isAlwaysUniform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetTransformInfo::isAlwaysUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00274">274</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="UniformityAnalysis_8cpp_source.html#l00033">llvm::GenericUniformityAnalysisImpl&lt; ContextT &gt;::initialize()</a>.</p>

</div>
</div>
<a id="a64e28d7d5da07059305e09ff16ee5d0b" name="a64e28d7d5da07059305e09ff16ee5d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e28d7d5da07059305e09ff16ee5d0b">&#9670;&#160;</a></span>isElementTypeLegalForScalableVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isElementTypeLegalForScalableVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the given type is supported for scalable vectors </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01170">1170</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a30646d63c1f1ca132d37dff17cf5daae" name="a30646d63c1f1ca132d37dff17cf5daae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30646d63c1f1ca132d37dff17cf5daae">&#9670;&#160;</a></span>isExpensiveToSpeculativelyExecute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isExpensiveToSpeculativelyExecute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the cost of the instruction is too high to speculatively execute and should be kept behind a branch. </p>
<p>This normally just wraps around a <a class="el" href="#ac77dbedcfd916a5c9b58e753b2678a98" title="Estimate the cost of a given IR user when lowered.">getInstructionCost()</a> call, but some targets might report a low TCK_SizeAndLatency value that is incompatible with the fixed TCC_Expensive value. NOTE: This assumes the instruction passes <a class="el" href="namespacellvm.html#abe76d72cda6b2b4562c72accb510040b" title="Return true if the instruction does not have any effects besides calculating the result and does not ...">isSafeToSpeculativelyExecute()</a>. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00619">619</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeGenPrepare_8cpp_source.html#l06787">sinkSelectOperand()</a>.</p>

</div>
</div>
<a id="a199e3382d45514816f88cb65310decb4" name="a199e3382d45514816f88cb65310decb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199e3382d45514816f88cb65310decb4">&#9670;&#160;</a></span>isFCmpOrdCheaperThanFCmpZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isFCmpOrdCheaperThanFCmpZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if it is faster to check if a floating-point value is NaN (or not-NaN) versus a comparison against a constant FP zero value. </p>
<p>Targets should override this if materializing a 0.0 for comparison is generally as cheap as checking for ordered/unordered. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00624">624</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="PartiallyInlineLibCalls_8cpp_source.html#l00034">optimizeSQRT()</a>.</p>

</div>
</div>
<a id="ab75d51988243f8ea9086b110401f8758" name="ab75d51988243f8ea9086b110401f8758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75d51988243f8ea9086b110401f8758">&#9670;&#160;</a></span>isFPVectorizationPotentiallyUnsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isFPVectorizationPotentiallyUnsafe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate that it is potentially unsafe to automatically vectorize floating-point operations because the semantics of vector and scalar floating-point semantics may differ. </p>
<p>For example, <a class="el" href="namespacellvm_1_1ARM.html" title="Define some predicates that are used for node matching.">ARM</a> NEON v7 SIMD math does not support IEEE-754 denormal numbers, while depending on the platform, scalar floating-point math does. This applies to floating-point math operations and calls, not memory operations, shuffles, or casts. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00596">596</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l10181">llvm::LoopVectorizePass::processLoop()</a>.</p>

</div>
</div>
<a id="aaae1d7de61213a91194e93174081ab4d" name="aaae1d7de61213a91194e93174081ab4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae1d7de61213a91194e93174081ab4d">&#9670;&#160;</a></span>isHardwareLoopProfitable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isHardwareLoopProfitable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Loop.html">Loop</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>SE</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1AssumptionCache.html">AssumptionCache</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>AC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>LibInfo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1HardwareLoopInfo.html">HardwareLoopInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>HWLoopInfo</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target whether it would be profitable to convert the given loop into a hardware loop. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00329">329</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a7716bda26c61738e624214efa149e83e" name="a7716bda26c61738e624214efa149e83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7716bda26c61738e624214efa149e83e">&#9670;&#160;</a></span>isIndexedLoadLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isIndexedLoadLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">MemIndexedMode</a></td>          <td class="paramname"><span class="paramname"><em>Mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the specified indexed load for the given type is legal. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01131">1131</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l05746">canHoistIVInc()</a>, and <a class="el" href="LoopStrengthReduce_8cpp_source.html#l03669">mayUsePostIncMode()</a>.</p>

</div>
</div>
<a id="a5a768ef7bcf1b5059f409327c1f83591" name="a5a768ef7bcf1b5059f409327c1f83591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a768ef7bcf1b5059f409327c1f83591">&#9670;&#160;</a></span>isIndexedStoreLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isIndexedStoreLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#acf5cc8324c33cb1f59869456263f9f4b">MemIndexedMode</a></td>          <td class="paramname"><span class="paramname"><em>Mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the specified indexed store for the given type is legal. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01136">1136</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l05746">canHoistIVInc()</a>, and <a class="el" href="LoopStrengthReduce_8cpp_source.html#l03669">mayUsePostIncMode()</a>.</p>

</div>
</div>
<a id="a7f5c32f4b5bd13b1279016cd9a6db37b" name="a7f5c32f4b5bd13b1279016cd9a6db37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5c32f4b5bd13b1279016cd9a6db37b">&#9670;&#160;</a></span>isLegalAddImmediate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalAddImmediate </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Imm</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified immediate is legal add immediate, that is the target has add instructions which can add a register with the immediate without having to materialize the immediate into a register. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00379">379</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a5c84ca19e254840865cd33cc5aaedb81" name="a5c84ca19e254840865cd33cc5aaedb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c84ca19e254840865cd33cc5aaedb81">&#9670;&#160;</a></span>isLegalAddressingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalAddressingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1GlobalValue.html">GlobalValue</a> *</td>          <td class="paramname"><span class="paramname"><em>BaseGV</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>BaseOffset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>HasBaseReg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Scale</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classllvm_1_1ilist__node__impl.html">nullptr</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the addressing mode represented by AM is legal for this target, for a load/store of the specified type. </p>
<p>The type may be VoidTy, in which case only return true if the addressing mode is legal for a load/store of any legal type. If target returns true in <a class="el" href="#a4746d964f754f53ce75d48a418196674" title="Return true if the loop strength reduce pass should make Instruction* based TTI queries to isLegalAdd...">LSRWithInstrQueries()</a>, I may be valid. TODO: Handle pre/postinc as well. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00387">387</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="StraightLineStrengthReduce_8cpp_source.html#l00293">isAddFoldable()</a>, <a class="el" href="LoopStrengthReduce_8cpp_source.html#l01679">isAMCompletelyFolded()</a>, and <a class="el" href="LoopStrengthReduce_8cpp_source.html#l05030">IsSimplerBaseSCEVForTarget()</a>.</p>

</div>
</div>
<a id="aae67acb89326f200683e3d0b872a5329" name="aae67acb89326f200683e3d0b872a5329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae67acb89326f200683e3d0b872a5329">&#9670;&#160;</a></span>isLegalAltInstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalAltInstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>VecTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1SmallBitVector.html">SmallBitVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OpcodeMask</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an alternating opcode pattern that can be lowered to a single instruction on the target. </p>
<p>In <a class="el" href="namespacellvm_1_1X86.html" title="Define some predicates that are used for node matching.">X86</a> this is for the addsub instruction which corrsponds to a Shuffle + Fadd + FSub pattern in IR. This function expectes two opcodes: <code>Opcode1</code> and <code>Opcode2</code> being selected by <code>OpcodeMask</code>. The mask contains one bit per lane and is a <code>0</code> when <code>Opcode0</code> is selected and <code>1</code> when Opcode1 is selected. <code>VecTy</code> is the vector type of the instruction to be generated. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00455">455</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a5a6b14ee0f0d259ea09d847875be536f" name="a5a6b14ee0f0d259ea09d847875be536f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6b14ee0f0d259ea09d847875be536f">&#9670;&#160;</a></span>isLegalBroadcastLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalBroadcastLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>ElementTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ElementCount.html">ElementCount</a></td>          <td class="paramname"><span class="paramname"><em>NumElements</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>\Returns true if the target supports broadcasting a load to a vector of type &lt;NumElements x ElementTy&gt;. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00445">445</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a78ff38d597ee5f9da28bb64c812520d8" name="a78ff38d597ee5f9da28bb64c812520d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ff38d597ee5f9da28bb64c812520d8">&#9670;&#160;</a></span>isLegalICmpImmediate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalICmpImmediate </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>Imm</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified immediate is legal icmp immediate, that is the target has icmp instructions which can compare a register against the immediate without having to materialize the immediate into a register. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00383">383</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l01679">isAMCompletelyFolded()</a>.</p>

</div>
</div>
<a id="a78f71d89b22106738d72d963725f0860" name="a78f71d89b22106738d72d963725f0860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f71d89b22106738d72d963725f0860">&#9670;&#160;</a></span>isLegalMaskedCompressStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedCompressStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked compress store. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00476">476</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarizeMaskedMemIntrin_8cpp_source.html#l00917">optimizeCallInst()</a>.</p>

</div>
</div>
<a id="aa143359355225ce76a666b1758bb2d3d" name="aa143359355225ce76a666b1758bb2d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa143359355225ce76a666b1758bb2d3d">&#9670;&#160;</a></span>isLegalMaskedExpandLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedExpandLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked expand load. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00480">480</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ScalarizeMaskedMemIntrin_8cpp_source.html#l00917">optimizeCallInst()</a>.</p>

</div>
</div>
<a id="a33ac7704be5bd5455f78caf0b5371012" name="a33ac7704be5bd5455f78caf0b5371012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ac7704be5bd5455f78caf0b5371012">&#9670;&#160;</a></span>isLegalMaskedGather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedGather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked gather. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00450">450</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SLPVectorizer_8cpp_source.html#l03865">canVectorizeLoads()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l01475">llvm::LoopVectorizationCostModel::isLegalGatherOrScatter()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l04428">llvm::LoopVectorizationCostModel::isScalarWithPredication()</a>, and <a class="el" href="ScalarizeMaskedMemIntrin_8cpp_source.html#l00917">optimizeCallInst()</a>.</p>

</div>
</div>
<a id="aff5a70644f05b7731348861016ff2af1" name="aff5a70644f05b7731348861016ff2af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5a70644f05b7731348861016ff2af1">&#9670;&#160;</a></span>isLegalMaskedLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked load. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00431">431</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l04574">llvm::LoopVectorizationCostModel::interleavedAccessCanBeWidened()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l01468">llvm::LoopVectorizationCostModel::isLegalMaskedLoad()</a>, and <a class="el" href="ScalarizeMaskedMemIntrin_8cpp_source.html#l00917">optimizeCallInst()</a>.</p>

</div>
</div>
<a id="a0a973aabc3b5429e5e05beee35892de0" name="a0a973aabc3b5429e5e05beee35892de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a973aabc3b5429e5e05beee35892de0">&#9670;&#160;</a></span>isLegalMaskedScatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedScatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked scatter. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00461">461</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l01475">llvm::LoopVectorizationCostModel::isLegalGatherOrScatter()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l04428">llvm::LoopVectorizationCostModel::isScalarWithPredication()</a>, and <a class="el" href="ScalarizeMaskedMemIntrin_8cpp_source.html#l00917">optimizeCallInst()</a>.</p>

</div>
</div>
<a id="ab9bcc7733985bba3ab58e5c2abbc129e" name="ab9bcc7733985bba3ab58e5c2abbc129e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bcc7733985bba3ab58e5c2abbc129e">&#9670;&#160;</a></span>isLegalMaskedStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalMaskedStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports masked store. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00426">426</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l04574">llvm::LoopVectorizationCostModel::interleavedAccessCanBeWidened()</a>, <a class="el" href="LoopVectorize_8cpp_source.html#l01461">llvm::LoopVectorizationCostModel::isLegalMaskedStore()</a>, and <a class="el" href="ScalarizeMaskedMemIntrin_8cpp_source.html#l00917">optimizeCallInst()</a>.</p>

</div>
</div>
<a id="a7bdad414050f44dd51fe2c193b7992b6" name="a7bdad414050f44dd51fe2c193b7992b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bdad414050f44dd51fe2c193b7992b6">&#9670;&#160;</a></span>isLegalNTLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalNTLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports nontemporal load. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00441">441</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a923b761c973df44658c12ab18b29365c" name="a923b761c973df44658c12ab18b29365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923b761c973df44658c12ab18b29365c">&#9670;&#160;</a></span>isLegalNTStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalNTStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>DataType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the target supports nontemporal store. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00436">436</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a03aaf2f1c4d2a4bb801bc9aeea94de3c" name="a03aaf2f1c4d2a4bb801bc9aeea94de3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03aaf2f1c4d2a4bb801bc9aeea94de3c">&#9670;&#160;</a></span>isLegalToVectorizeLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalToVectorizeLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> *</td>          <td class="paramname"><span class="paramname"><em>LI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the load instruction is legal to vectorize. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01145">1145</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="aaaa75efd79296070e4c5f24fa3ea6f01" name="aaaa75efd79296070e4c5f24fa3ea6f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa75efd79296070e4c5f24fa3ea6f01">&#9670;&#160;</a></span>isLegalToVectorizeLoadChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalToVectorizeLoadChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ChainSizeInBytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if it is legal to vectorize the given load chain. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01153">1153</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a7b174ae4841c69cd671ed4bf4834db64" name="a7b174ae4841c69cd671ed4bf4834db64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b174ae4841c69cd671ed4bf4834db64">&#9670;&#160;</a></span>isLegalToVectorizeReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalToVectorizeReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1RecurrenceDescriptor.html">RecurrenceDescriptor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>RdxDesc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ElementCount.html">ElementCount</a></td>          <td class="paramname"><span class="paramname"><em>VF</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if it is legal to vectorize the given reduction kind. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01165">1165</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a0de4290b00b162ec20705cad42047b64" name="a0de4290b00b162ec20705cad42047b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de4290b00b162ec20705cad42047b64">&#9670;&#160;</a></span>isLegalToVectorizeStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalToVectorizeStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StoreInst.html">StoreInst</a> *</td>          <td class="paramname"><span class="paramname"><em>SI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the store instruction is legal to vectorize. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01149">1149</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a58b0dcd9d3ef39aa308b7d7371e5da88" name="a58b0dcd9d3ef39aa308b7d7371e5da88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b0dcd9d3ef39aa308b7d7371e5da88">&#9670;&#160;</a></span>isLegalToVectorizeStoreChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLegalToVectorizeStoreChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ChainSizeInBytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1Align.html">Align</a></td>          <td class="paramname"><span class="paramname"><em>Alignment</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AddrSpace</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if it is legal to vectorize the given store chain. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01159">1159</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="aa8b08fb48c8c58e63aa231a1099475d9" name="aa8b08fb48c8c58e63aa231a1099475d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b08fb48c8c58e63aa231a1099475d9">&#9670;&#160;</a></span>isLoweredToCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLoweredToCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Function.html">Function</a> *</td>          <td class="paramname"><span class="paramname"><em>F</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether calls to a function lower to actual program function calls. </p>
<p>The idea is to test whether the program is likely to require a 'call' instruction or equivalent in order to call the given function.</p>
<p>FIXME: It's not clear that this is a good or useful query API. Client's should probably move to simpler cost metrics using the above. Alternatively, we could split the cost interface into distinct code-size and execution-speed costs. This would allow modelling the core of this query more accurately as a call is a single small instruction, but incurs significant execution cost. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00325">325</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00055">F</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeMetrics_8cpp_source.html#l00116">llvm::CodeMetrics::analyzeBasicBlock()</a>, <a class="el" href="LoopUnrollPass_8cpp_source.html#l00346">analyzeLoopUnrollCost()</a>, and <a class="el" href="CGProfile_8cpp_source.html#l00047">runCGProfilePass()</a>.</p>

</div>
</div>
<a id="a1d57a8095a918e8a7ebe31f964c16bbe" name="a1d57a8095a918e8a7ebe31f964c16bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d57a8095a918e8a7ebe31f964c16bbe">&#9670;&#160;</a></span>isLSRCostLess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isLSRCostLess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1TargetTransformInfo_1_1LSRCost.html">TargetTransformInfo::LSRCost</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1TargetTransformInfo_1_1LSRCost.html">TargetTransformInfo::LSRCost</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if LSR cost of C1 is lower than C2. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00396">396</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a50c845c07da9fd93a05ec29509486166" name="a50c845c07da9fd93a05ec29509486166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c845c07da9fd93a05ec29509486166">&#9670;&#160;</a></span>isNoopAddrSpaceCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isNoopAddrSpaceCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>FromAS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ToAS</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00297">297</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InferAddressSpaces_8cpp_source.html#l00268">isNoopPtrIntCastPair()</a>.</p>

</div>
</div>
<a id="acb09869158c4446f417427d102199632" name="acb09869158c4446f417427d102199632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb09869158c4446f417427d102199632">&#9670;&#160;</a></span>isNumRegsMajorCostOfLSR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isNumRegsMajorCostOfLSR </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if LSR major cost is number of registers. </p>
<p>Targets which implement their own isLSRCostLess and unset number of registers as major cost should return false, otherwise return true. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00401">401</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a2c5b11c76ffc12a4dde038d77dc4d5ae" name="a2c5b11c76ffc12a4dde038d77dc4d5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5b11c76ffc12a4dde038d77dc4d5ae">&#9670;&#160;</a></span>isProfitableLSRChainElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isProfitableLSRChainElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if LSR should not optimize a chain that includes <code>I</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00405">405</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l02886">isProfitableChain()</a>.</p>

</div>
</div>
<a id="aafcbf4e3010950dd8ea0be1c4b0d3281" name="aafcbf4e3010950dd8ea0be1c4b0d3281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcbf4e3010950dd8ea0be1c4b0d3281">&#9670;&#160;</a></span>isProfitableToHoist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isProfitableToHoist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if it is profitable to hoist instruction in the then/else to before if. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00518">518</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="SimplifyCFG_8cpp_source.html#l01489">shouldHoistCommonInstructions()</a>.</p>

</div>
</div>
<a id="a3ba50f0bbbe7b4ae53a66e70c614cce2" name="a3ba50f0bbbe7b4ae53a66e70c614cce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba50f0bbbe7b4ae53a66e70c614cce2">&#9670;&#160;</a></span>isSingleThreaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isSingleThreaded </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00311">311</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a787ddce53dcb1b93b5c173dbbba4d3f0" name="a787ddce53dcb1b93b5c173dbbba4d3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787ddce53dcb1b93b5c173dbbba4d3f0">&#9670;&#160;</a></span>isSourceOfDivergence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isSourceOfDivergence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether V is a source of divergence. </p>
<p>This function provides the target-dependent information for the target-independent UniformityAnalysis. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00270">270</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="UniformityAnalysis_8cpp_source.html#l00033">llvm::GenericUniformityAnalysisImpl&lt; ContextT &gt;::initialize()</a>.</p>

</div>
</div>
<a id="ae3e55cf13c60a8b90145f1411367b975" name="ae3e55cf13c60a8b90145f1411367b975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e55cf13c60a8b90145f1411367b975">&#9670;&#160;</a></span>isTruncateFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isTruncateFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if it's free to truncate a value of type Ty1 to type Ty2. </p>
<p>e.g. On x86 it's free to truncate a i32 value in register EAX to i16 by referencing its sub-register AX. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00514">514</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l01420">llvm::LoopVectorizationCostModel::isOptimizableIVTruncate()</a>, and <a class="el" href="ScalarEvolutionExpander_8cpp_source.html#l01597">llvm::SCEVExpander::replaceCongruentIVs()</a>.</p>

</div>
</div>
<a id="a7a84209b8495d8fd3d2799eb01f1ab2b" name="a7a84209b8495d8fd3d2799eb01f1ab2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a84209b8495d8fd3d2799eb01f1ab2b">&#9670;&#160;</a></span>isTypeLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isTypeLegal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this type is legal. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00524">524</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUtils_8cpp_source.html#l00537">llvm::computeMinimumValueSizes()</a>, <a class="el" href="AggressiveInstCombine_8cpp_source.html#l00770">foldConsecutiveLoads()</a>, <a class="el" href="SLPVectorizer_8cpp_source.html#l08074">isLoadCombineCandidateImpl()</a>, and <a class="el" href="SimplifyCFG_8cpp_source.html#l06204">isTypeLegalForLookupTable()</a>.</p>

</div>
</div>
<a id="ad61de27a7641e7ce57bc6e3fdc8cd8d2" name="ad61de27a7641e7ce57bc6e3fdc8cd8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61de27a7641e7ce57bc6e3fdc8cd8d2">&#9670;&#160;</a></span>isValidAddrSpaceCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::TargetTransformInfo::isValidAddrSpaceCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>FromAS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>ToAS</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target whether the specified address space cast from FromAS to ToAS is valid. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00278">278</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerMemIntrinsics_8cpp_source.html#l00554">llvm::expandMemMoveAsLoop()</a>, and <a class="el" href="InstructionCombining_8cpp_source.html#l00202">llvm::InstCombiner::isValidAddrSpaceCast()</a>.</p>

</div>
</div>
<a id="a761a2a864705382c56d6406a6a97e6fc" name="a761a2a864705382c56d6406a6a97e6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761a2a864705382c56d6406a6a97e6fc">&#9670;&#160;</a></span>isVScaleKnownToBeAPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::isVScaleKnownToBeAPowerOfTwo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if vscale is known to be a power of 2 </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00700">700</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l05096">llvm::LoopVectorizationCostModel::computeMaxVF()</a>.</p>

</div>
</div>
<a id="a4746d964f754f53ce75d48a418196674" name="a4746d964f754f53ce75d48a418196674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4746d964f754f53ce75d48a418196674">&#9670;&#160;</a></span>LSRWithInstrQueries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::LSRWithInstrQueries </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the loop strength reduce pass should make Instruction* based TTI queries to <a class="el" href="#a5c84ca19e254840865cd33cc5aaedb81" title="Return true if the addressing mode represented by AM is legal for this target, for a load/store of th...">isLegalAddressingMode()</a>. </p>
<p>This is needed on <a class="el" href="namespacellvm_1_1SystemZ.html">SystemZ</a>, where e.g. a memcpy can only have a 12 bit unsigned immediate offset and no index register. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00510">510</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopStrengthReduce_8cpp_source.html#l01792">isAMCompletelyFolded()</a>.</p>

</div>
</div>
<a id="a6d955ca0eda3479b562ccc505575049b" name="a6d955ca0eda3479b562ccc505575049b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d955ca0eda3479b562ccc505575049b">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp; TargetTransformInfo::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TargetTransformInfo.html">TargetTransformInfo</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00206">206</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a987fde1294b059921cb381631fa3747b" name="a987fde1294b059921cb381631fa3747b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987fde1294b059921cb381631fa3747b">&#9670;&#160;</a></span>preferEpilogueVectorization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::preferEpilogueVectorization </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the loop vectorizer should consider vectorizing an otherwise scalar epilogue loop. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01198">1198</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l05603">llvm::LoopVectorizationCostModel::isEpilogueVectorizationProfitable()</a>.</p>

</div>
</div>
<a id="a1a2b30bdeffa3fb4a4fd881e25d01817" name="a1a2b30bdeffa3fb4a4fd881e25d01817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2b30bdeffa3fb4a4fd881e25d01817">&#9670;&#160;</a></span>preferInLoopReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::preferInLoopReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1ReductionFlags.html">ReductionFlags</a></td>          <td class="paramname"><span class="paramname"><em>Flags</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the target prefers reductions in loop. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01188">1188</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l05757">llvm::LoopVectorizationCostModel::collectElementTypesForWidening()</a>, and <a class="el" href="LoopVectorize_8cpp_source.html#l07501">llvm::LoopVectorizationCostModel::collectInLoopReductions()</a>.</p>

</div>
</div>
<a id="a8e8f7af4c35e8c6bc6e9a4f0850a7847" name="a8e8f7af4c35e8c6bc6e9a4f0850a7847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8f7af4c35e8c6bc6e9a4f0850a7847">&#9670;&#160;</a></span>preferPredicatedReductionSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::preferPredicatedReductionSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Opcode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TargetTransformInfo_1_1ReductionFlags.html">ReductionFlags</a></td>          <td class="paramname"><span class="paramname"><em>Flags</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the target prefers reductions select kept in the loop when tail folding. i.e. loop: p = phi (0, s) a = add (p, x) s = select (mask, a, p) vecreduce.add(s)</dd></dl>
<p>As opposed to the normal scheme of p = phi (0, a) which allows the select to be pulled out of the loop. If the select(.., add, ..) can be predicated by the target, this can lead to cleaner code generation. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01193">1193</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l03945">llvm::InnerLoopVectorizer::fixReduction()</a>.</p>

</div>
</div>
<a id="ae953310cea2ff4ae78d8fcf9269f9259" name="ae953310cea2ff4ae78d8fcf9269f9259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae953310cea2ff4ae78d8fcf9269f9259">&#9670;&#160;</a></span>preferPredicateOverEpilogue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::preferPredicateOverEpilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllvm_1_1TailFoldingInfo.html">TailFoldingInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>TFI</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the target whether it would be prefered to create a predicated vector loop, which can avoid the need to emit a scalar epilogue loop. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00335">335</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l09835">getScalarEpilogueLowering()</a>.</p>

</div>
</div>
<a id="a215ea3605f88c5b21ffbdf76a72a8554" name="a215ea3605f88c5b21ffbdf76a72a8554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215ea3605f88c5b21ffbdf76a72a8554">&#9670;&#160;</a></span>prefersVectorizedAddressing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::prefersVectorizedAddressing </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if target doesn't mind addresses in vectors. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00497">497</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopVectorize_8cpp_source.html#l06944">llvm::LoopVectorizationCostModel::setCostBasedWideningDecision()</a>.</p>

</div>
</div>
<a id="a7aecc3cf03beff532c2b8bfe81e500c8" name="a7aecc3cf03beff532c2b8bfe81e500c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aecc3cf03beff532c2b8bfe81e500c8">&#9670;&#160;</a></span>requiresOrderedReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> llvm::TargetTransformInfo::requiresOrderedReduction </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classllvm_1_1FastMathFlags.html">FastMathFlags</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>FMF</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function to determine the type of reduction algorithm used for a given <code>Opcode</code> and set of <a class="el" href="classllvm_1_1FastMathFlags.html" title="Convenience struct for specifying and reasoning about fast-math flags.">FastMathFlags</a> <code>FMF</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8h_source.html#l01379">1379</a> of file <a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="BasicTTIImpl_8h_source.html#l02354">llvm::BasicTTIImplBase&lt; T &gt;::getArithmeticReductionCost()</a>, <a class="el" href="AArch64TargetTransformInfo_8cpp_source.html#l03329">llvm::AArch64TTIImpl::getArithmeticReductionCost()</a>, <a class="el" href="AMDGPUTargetTransformInfo_8cpp_source.html#l00773">llvm::GCNTTIImpl::getArithmeticReductionCost()</a>, <a class="el" href="RISCVTargetTransformInfo_8cpp_source.html#l01249">llvm::RISCVTTIImpl::getArithmeticReductionCost()</a>, <a class="el" href="X86TargetTransformInfo_8cpp_source.html#l05009">llvm::X86TTIImpl::getArithmeticReductionCost()</a>, and <a class="el" href="ARMTargetTransformInfo_8cpp_source.html#l01670">llvm::ARMTTIImpl::getArithmeticReductionCost()</a>.</p>

</div>
</div>
<a id="a88bd45e10d1f1069da1b4d216d0f5f73" name="a88bd45e10d1f1069da1b4d216d0f5f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bd45e10d1f1069da1b4d216d0f5f73">&#9670;&#160;</a></span>rewriteIntrinsicWithAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Value.html">Value</a> * TargetTransformInfo::rewriteIntrinsicWithAddressSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *</td>          <td class="paramname"><span class="paramname"><em>II</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>OldV</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>NewV</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite intrinsic call <code>II</code> such that <code>OldV</code> will be replaced with <code>NewV</code>, which has a different address space. </p>
<p>This should happen for every operand index that collectFlatAddressOperands returned for the intrinsic. </p><dl class="section return"><dt>Returns</dt><dd>nullptr if the intrinsic was not handled. Otherwise, returns the new value (which may be the original <code>II</code> with modified operands). </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00320">320</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a0d5b47e1f017620a784b726852915d58" name="a0d5b47e1f017620a784b726852915d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5b47e1f017620a784b726852915d58">&#9670;&#160;</a></span>shouldBuildLookupTables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldBuildLookupTables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if switches should be turned into lookup tables for the target. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00532">532</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SimplifyCFG_8cpp_source.html#l06390">SwitchToLookupTable()</a>.</p>

</div>
</div>
<a id="a265e334c170d96e5cbcf8b420db520d4" name="a265e334c170d96e5cbcf8b420db520d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265e334c170d96e5cbcf8b420db520d4">&#9670;&#160;</a></span>shouldBuildLookupTablesForConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldBuildLookupTablesForConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Constant.html">Constant</a> *</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if switches should be turned into lookup tables containing this constant value for the target. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00536">536</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>.</p>

<p class="reference">Referenced by <a class="el" href="SimplifyCFG_8cpp_source.html#l05587">ValidLookupTableConstant()</a>.</p>

</div>
</div>
<a id="abcb1dfc8333359b25dda0d8cbef24e4a" name="abcb1dfc8333359b25dda0d8cbef24e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb1dfc8333359b25dda0d8cbef24e4a">&#9670;&#160;</a></span>shouldBuildRelLookupTables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldBuildRelLookupTables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if lookup tables should be turned into relative lookup tables. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00541">541</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a9880b7512930d879440db073b536d362" name="a9880b7512930d879440db073b536d362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9880b7512930d879440db073b536d362">&#9670;&#160;</a></span>shouldConsiderAddressTypePromotion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldConsiderAddressTypePromotion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>AllowPromotionWithoutCommonHeader</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if it should be considered for address type promotion. <code>AllowPromotionWithoutCommonHeader</code> Set true if promoting <code>I</code> is profitable without finding other extensions fed by the same input. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00724">724</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

</div>
</div>
<a id="aefeefc63fa057f5050b78547c6cdf0e1" name="aefeefc63fa057f5050b78547c6cdf0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefeefc63fa057f5050b78547c6cdf0e1">&#9670;&#160;</a></span>shouldExpandReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldExpandReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *</td>          <td class="paramname"><span class="paramname"><em>II</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the target wants to expand the given reduction intrinsic into a shuffle sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01215">1215</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a525b5174ebf7ac1db045dde5f579ddcb" name="a525b5174ebf7ac1db045dde5f579ddcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525b5174ebf7ac1db045dde5f579ddcb">&#9670;&#160;</a></span>shouldMaximizeVectorBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldMaximizeVectorBandwidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8bb3b1ccf19b8c85429b777dfa4a0166">TargetTransformInfo::RegisterKind</a></td>          <td class="paramname"><span class="paramname"><em>K</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the vectorization factor should be chosen to make the vector of the smallest element type match the size of a vector register. For wider element types, this could result in creating vectors that span multiple vector registers. If false, the vectorization factor will be chosen based on the size of the widest element type. <code>K</code> <a class="el" href="classllvm_1_1Register.html" title="Wrapper class representing virtual and physical registers.">Register</a> Kind for vectorization. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00704">704</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a8f4eb225c0b7b93c8b8e6c0de860fb5f" name="a8f4eb225c0b7b93c8b8e6c0de860fb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4eb225c0b7b93c8b8e6c0de860fb5f">&#9670;&#160;</a></span>shouldPrefetchAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::shouldPrefetchAddressSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>AS</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if target want to issue a prefetch in address space <code>AS</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00764">764</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ac17fdac44c73248d9e36df4fd8d93b28" name="ac17fdac44c73248d9e36df4fd8d93b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17fdac44c73248d9e36df4fd8d93b28">&#9670;&#160;</a></span>simplifyDemandedUseBitsIntrinsic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; TargetTransformInfo::simplifyDemandedUseBitsIntrinsic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>II</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a></td>          <td class="paramname"><span class="paramname"><em>DemandedMask</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllvm_1_1KnownBits.html">KnownBits</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Known</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>KnownBitsComputed</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can be used to implement target-specific instruction combining. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2c34992cf5a6125fc637fbde99b88890" title="Targets can implement their own combinations for target-specific intrinsics.">instCombineIntrinsic</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00351">351</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstructionCombining_8cpp_source.html#l00177">llvm::InstCombiner::targetSimplifyDemandedUseBitsIntrinsic()</a>.</p>

</div>
</div>
<a id="a3c63492d1e619b740c6e6d123efeb4f8" name="a3c63492d1e619b740c6e6d123efeb4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c63492d1e619b740c6e6d123efeb4f8">&#9670;&#160;</a></span>simplifyDemandedVectorEltsIntrinsic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; TargetTransformInfo::simplifyDemandedVectorEltsIntrinsic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>II</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a></td>          <td class="paramname"><span class="paramname"><em>DemandedElts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UndefElts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UndefElts2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UndefElts3</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classllvm_1_1ilist__node__impl.html">void</a>(<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *, <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classllvm_1_1APInt.html">APInt</a>, <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>SimplifyAndSetOp</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can be used to implement target-specific instruction combining. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2c34992cf5a6125fc637fbde99b88890" title="Targets can implement their own combinations for target-specific intrinsics.">instCombineIntrinsic</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00358">358</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstructionCombining_8cpp_source.html#l00188">llvm::InstCombiner::targetSimplifyDemandedVectorEltsIntrinsic()</a>.</p>

</div>
</div>
<a id="a1af0805a1dd7afabb0aa6cc1832b5011" name="a1af0805a1dd7afabb0aa6cc1832b5011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af0805a1dd7afabb0aa6cc1832b5011">&#9670;&#160;</a></span>supportsEfficientVectorElementLoadStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::supportsEfficientVectorElementLoadStore </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If target has efficient vector element load/store instructions, it can return true here so that insertion/extraction costs are not added to the scalarization cost of a load/store. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00562">562</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ab0215ddedbe9f8179c491308a56aaceb" name="ab0215ddedbe9f8179c491308a56aaceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0215ddedbe9f8179c491308a56aaceb">&#9670;&#160;</a></span>supportsScalableVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::supportsScalableVectors </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the target supports scalable vectors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l01227">1227</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="a2c143ebdce9475bb57428828fe848e3a" name="a2c143ebdce9475bb57428828fe848e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c143ebdce9475bb57428828fe848e3a">&#9670;&#160;</a></span>supportsTailCallFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::supportsTailCallFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1CallBase.html">CallBase</a> *</td>          <td class="paramname"><span class="paramname"><em>CB</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If target supports tail call on <code>CB</code>. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00570">570</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CoroSplit_8cpp_source.html#l01391">addMustTailToCoroResumes()</a>.</p>

</div>
</div>
<a id="ad4d10c3084307035a3ae29cc2f420440" name="ad4d10c3084307035a3ae29cc2f420440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d10c3084307035a3ae29cc2f420440">&#9670;&#160;</a></span>supportsTailCalls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::supportsTailCalls </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the target supports tail calls. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00566">566</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CoroSplit_8cpp_source.html#l01618">splitSwitchCoroutine()</a>.</p>

</div>
</div>
<a id="a98deb6721fb0ac45c41f71b800700596" name="a98deb6721fb0ac45c41f71b800700596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98deb6721fb0ac45c41f71b800700596">&#9670;&#160;</a></span>useAA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::useAA </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00522">522</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

</div>
</div>
<a id="ad30e432e7796aa46c87440cb54de2243" name="ad30e432e7796aa46c87440cb54de2243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30e432e7796aa46c87440cb54de2243">&#9670;&#160;</a></span>useColdCCForColdCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TargetTransformInfo::useColdCCForColdCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>F</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the input function which is cold at all call sites, should use coldcc calling convention. </p>

<p class="definition">Definition at line <a class="el" href="TargetTransformInfo_8cpp_source.html#l00545">545</a> of file <a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00055">F</a>.</p>

<p class="reference">Referenced by <a class="el" href="GlobalOpt_8cpp_source.html#l01923">OptimizeFunctions()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/llvm/Analysis/<a class="el" href="TargetTransformInfo_8h_source.html">TargetTransformInfo.h</a></li>
<li>lib/Analysis/<a class="el" href="TargetTransformInfo_8cpp_source.html">TargetTransformInfo.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 21 2024 14:02:21 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
