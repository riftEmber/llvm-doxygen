<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Transforms/InstCombine/InstCombineCasts.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;17.0.0rc</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a72932e0778af28115095468f6286ff8.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_99567d9c0c7f3685f25b19ecc341a865.html">InstCombine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">InstCombineCasts.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="InstCombineInternal_8h_source.html">InstCombineInternal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SetVector_8h_source.html">llvm/ADT/SetVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ConstantFolding_8h_source.html">llvm/Analysis/ConstantFolding.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DataLayout_8h_source.html">llvm/IR/DataLayout.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="llvm_2IR_2DebugInfo_8h_source.html">llvm/IR/DebugInfo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">llvm/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="KnownBits_8h_source.html">llvm/Support/KnownBits.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InstCombiner_8h_source.html">llvm/Transforms/InstCombine/InstCombiner.h</a>&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="InstCombineCasts_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;instcombine&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9cad0d942fb5f64b2ec2ce7e7277c492" id="r_a9cad0d942fb5f64b2ec2ce7e7277c492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cad0d942fb5f64b2ec2ce7e7277c492">canAlwaysEvaluateInType</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty)</td></tr>
<tr class="memdesc:a9cad0d942fb5f64b2ec2ce7e7277c492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants and extensions/truncates from the destination type are always free to be evaluated in that type.  <br /></td></tr>
<tr class="separator:a9cad0d942fb5f64b2ec2ce7e7277c492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa977254b83ff622718b40f1aa81271f" id="r_aaa977254b83ff622718b40f1aa81271f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa977254b83ff622718b40f1aa81271f">canNotEvaluateInType</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty)</td></tr>
<tr class="memdesc:aaa977254b83ff622718b40f1aa81271f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out values that we can not evaluate in the destination type for free.  <br /></td></tr>
<tr class="separator:aaa977254b83ff622718b40f1aa81271f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd6331c5fd6ec51f6a9e5558f885f28" id="r_aefd6331c5fd6ec51f6a9e5558f885f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefd6331c5fd6ec51f6a9e5558f885f28">canEvaluateTruncated</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI)</td></tr>
<tr class="memdesc:aefd6331c5fd6ec51f6a9e5558f885f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we can evaluate the specified expression tree as type Ty instead of its larger type, and arrive with the same value.  <br /></td></tr>
<tr class="separator:aefd6331c5fd6ec51f6a9e5558f885f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3e98b16f1c8d8d8b30b9a459a6a602" id="r_aee3e98b16f1c8d8d8b30b9a459a6a602"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee3e98b16f1c8d8d8b30b9a459a6a602">foldVecTruncToExtElt</a> (<a class="el" href="classllvm_1_1TruncInst.html">TruncInst</a> &amp;Trunc, <a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC)</td></tr>
<tr class="memdesc:aee3e98b16f1c8d8d8b30b9a459a6a602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector that is bitcast to an integer, optionally logically right-shifted, and truncated, convert it to an extractelement.  <br /></td></tr>
<tr class="separator:aee3e98b16f1c8d8d8b30b9a459a6a602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c4c6660c6d108c0202fd73c28f2834" id="r_a40c4c6660c6d108c0202fd73c28f2834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40c4c6660c6d108c0202fd73c28f2834">shrinkSplatShuffle</a> (<a class="el" href="classllvm_1_1TruncInst.html">TruncInst</a> &amp;Trunc, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a40c4c6660c6d108c0202fd73c28f2834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to narrow the width of a splat shuffle.  <br /></td></tr>
<tr class="separator:a40c4c6660c6d108c0202fd73c28f2834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77aac577d89abc9411adfdf918d7d539" id="r_a77aac577d89abc9411adfdf918d7d539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77aac577d89abc9411adfdf918d7d539">shrinkInsertElt</a> (<a class="el" href="classllvm_1_1CastInst.html">CastInst</a> &amp;Trunc, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a77aac577d89abc9411adfdf918d7d539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to narrow the width of an insert element.  <br /></td></tr>
<tr class="separator:a77aac577d89abc9411adfdf918d7d539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3ed8206aabad62293aeddd444bab9f" id="r_a3d3ed8206aabad62293aeddd444bab9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d3ed8206aabad62293aeddd444bab9f">canEvaluateZExtd</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classunsigned.html">unsigned</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">BitsToClear</a>, <a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *CxtI)</td></tr>
<tr class="memdesc:a3d3ed8206aabad62293aeddd444bab9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified value can be computed in the specified wider type and produce the same low bits.  <br /></td></tr>
<tr class="separator:a3d3ed8206aabad62293aeddd444bab9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e1399c07ad0fea0b83eaea29c1402e" id="r_a16e1399c07ad0fea0b83eaea29c1402e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16e1399c07ad0fea0b83eaea29c1402e">canEvaluateSExtd</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty)</td></tr>
<tr class="memdesc:a16e1399c07ad0fea0b83eaea29c1402e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if we can take the specified value and return it as type Ty without inserting any new casts and without changing the value of the common low bits.  <br /></td></tr>
<tr class="separator:a16e1399c07ad0fea0b83eaea29c1402e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d58b6cb8f56c90aa445f4857a8d430" id="r_a68d58b6cb8f56c90aa445f4857a8d430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68d58b6cb8f56c90aa445f4857a8d430">fitsInFPType</a> (<a class="el" href="classllvm_1_1ConstantFP.html">ConstantFP</a> *CFP, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1fltSemantics.html">fltSemantics</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">Sem</a>)</td></tr>
<tr class="memdesc:a68d58b6cb8f56c90aa445f4857a8d430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Constant* for the specified floating-point constant if it fits in the specified FP type without changing its value.  <br /></td></tr>
<tr class="separator:a68d58b6cb8f56c90aa445f4857a8d430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa482becddf9cf916dc4ec68fd7a5a679" id="r_aa482becddf9cf916dc4ec68fd7a5a679"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa482becddf9cf916dc4ec68fd7a5a679">shrinkFPConstant</a> (<a class="el" href="classllvm_1_1ConstantFP.html">ConstantFP</a> *CFP)</td></tr>
<tr class="separator:aa482becddf9cf916dc4ec68fd7a5a679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdecfd6018030775941d22e75392cb0c" id="r_acdecfd6018030775941d22e75392cb0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdecfd6018030775941d22e75392cb0c">shrinkFPConstantVector</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V)</td></tr>
<tr class="separator:acdecfd6018030775941d22e75392cb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73ec0e6b4611633546e74ee96cb9e13" id="r_ab73ec0e6b4611633546e74ee96cb9e13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab73ec0e6b4611633546e74ee96cb9e13">getMinimumFPType</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V)</td></tr>
<tr class="memdesc:ab73ec0e6b4611633546e74ee96cb9e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum FP type we can safely truncate to.  <br /></td></tr>
<tr class="separator:ab73ec0e6b4611633546e74ee96cb9e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5576a66149a9259706758d613ba555" id="r_aac5576a66149a9259706758d613ba555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac5576a66149a9259706758d613ba555">isKnownExactCastIntToFP</a> (<a class="el" href="classllvm_1_1CastInst.html">CastInst</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC)</td></tr>
<tr class="memdesc:aac5576a66149a9259706758d613ba555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the cast from integer to FP can be proven to be exact for all possible inputs (the conversion does not lose any precision).  <br /></td></tr>
<tr class="separator:aac5576a66149a9259706758d613ba555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e6b6bf03adf614aaf100a9afdcd612" id="r_a75e6b6bf03adf614aaf100a9afdcd612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75e6b6bf03adf614aaf100a9afdcd612">optimizeVectorResizeWithIntegerBitCasts</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">InVal</a>, <a class="el" href="classVectorType.html">VectorType</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">DestTy</a>, <a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC)</td></tr>
<tr class="memdesc:a75e6b6bf03adf614aaf100a9afdcd612"><td class="mdescLeft">&#160;</td><td class="mdescRight">This input value (which is known to have vector type) is being zero extended or truncated to the specified vector type.  <br /></td></tr>
<tr class="separator:a75e6b6bf03adf614aaf100a9afdcd612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efab72b40fc7836709221d3e97139c6" id="r_a8efab72b40fc7836709221d3e97139c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8efab72b40fc7836709221d3e97139c6">isMultipleOfTypeSize</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1Value.html">Value</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty)</td></tr>
<tr class="separator:a8efab72b40fc7836709221d3e97139c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8947451998676abcce5452a1a8f5848" id="r_ac8947451998676abcce5452a1a8f5848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8947451998676abcce5452a1a8f5848">getTypeSizeIndex</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1Value.html">Value</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty)</td></tr>
<tr class="separator:ac8947451998676abcce5452a1a8f5848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01395be91e03a1a4c5fd713885d8327f" id="r_a01395be91e03a1a4c5fd713885d8327f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01395be91e03a1a4c5fd713885d8327f">collectInsertionElements</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classunsigned.html">unsigned</a> Shift, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;Elements, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">VecEltTy</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="CombinerHelper_8cpp.html#aad6842fbf58844d974611a4915a00aae">isBigEndian</a>)</td></tr>
<tr class="memdesc:a01395be91e03a1a4c5fd713885d8327f"><td class="mdescLeft">&#160;</td><td class="mdescRight">V is a value which is inserted into a vector of VecEltTy.  <br /></td></tr>
<tr class="separator:a01395be91e03a1a4c5fd713885d8327f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f948dd0c375dfeb4cdf99bc33905e66" id="r_a8f948dd0c375dfeb4cdf99bc33905e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f948dd0c375dfeb4cdf99bc33905e66">optimizeIntegerToVectorInsertions</a> (<a class="el" href="classllvm_1_1BitCastInst.html">BitCastInst</a> &amp;CI, <a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC)</td></tr>
<tr class="memdesc:a8f948dd0c375dfeb4cdf99bc33905e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input is an 'or' instruction, we may be doing shifts and ors to assemble the elements of the vector manually.  <br /></td></tr>
<tr class="separator:a8f948dd0c375dfeb4cdf99bc33905e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2793cc62829d80622b78cc681b25c2" id="r_a3e2793cc62829d80622b78cc681b25c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e2793cc62829d80622b78cc681b25c2">canonicalizeBitCastExtElt</a> (<a class="el" href="classllvm_1_1BitCastInst.html">BitCastInst</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">BitCast</a>, <a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC)</td></tr>
<tr class="memdesc:a3e2793cc62829d80622b78cc681b25c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize scalar bitcasts of extracted elements into a bitcast of the vector followed by extract element.  <br /></td></tr>
<tr class="separator:a3e2793cc62829d80622b78cc681b25c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6556e45ee27ad333bf33eda6b1f04b8a" id="r_a6556e45ee27ad333bf33eda6b1f04b8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6556e45ee27ad333bf33eda6b1f04b8a">foldBitCastBitwiseLogic</a> (<a class="el" href="classllvm_1_1BitCastInst.html">BitCastInst</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">BitCast</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a6556e45ee27ad333bf33eda6b1f04b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the type of a bitwise logic operation if we can eliminate a bitcast.  <br /></td></tr>
<tr class="separator:a6556e45ee27ad333bf33eda6b1f04b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0fa3868fb321fcd4b5d632028db897" id="r_a5d0fa3868fb321fcd4b5d632028db897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d0fa3868fb321fcd4b5d632028db897">foldBitCastSelect</a> (<a class="el" href="classllvm_1_1BitCastInst.html">BitCastInst</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">BitCast</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a5d0fa3868fb321fcd4b5d632028db897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the type of a select if we can eliminate a bitcast.  <br /></td></tr>
<tr class="separator:a5d0fa3868fb321fcd4b5d632028db897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b18f2c77f69e54841c51bb3d31cad2" id="r_a24b18f2c77f69e54841c51bb3d31cad2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24b18f2c77f69e54841c51bb3d31cad2">hasStoreUsersOnly</a> (<a class="el" href="classllvm_1_1CastInst.html">CastInst</a> &amp;CI)</td></tr>
<tr class="memdesc:a24b18f2c77f69e54841c51bb3d31cad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all users of CI are StoreInsts.  <br /></td></tr>
<tr class="separator:a24b18f2c77f69e54841c51bb3d31cad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;instcombine&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l00026">26</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9cad0d942fb5f64b2ec2ce7e7277c492" name="a9cad0d942fb5f64b2ec2ce7e7277c492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cad0d942fb5f64b2ec2ce7e7277c492">&#9670;&#160;</a></span>canAlwaysEvaluateInType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> canAlwaysEvaluateInType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constants and extensions/truncates from the destination type are always free to be evaluated in that type. </p>
<p>This is a helper for canEvaluate*. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l00218">218</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01642">llvm::PatternMatch::m_Trunc()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01679">llvm::PatternMatch::m_ZExtOrSExt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l01313">canEvaluateSExtd()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l00254">canEvaluateTruncated()</a>, and <a class="el" href="InstCombineCasts_8cpp_source.html#l00978">canEvaluateZExtd()</a>.</p>

</div>
</div>
<a id="a16e1399c07ad0fea0b83eaea29c1402e" name="a16e1399c07ad0fea0b83eaea29c1402e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e1399c07ad0fea0b83eaea29c1402e">&#9670;&#160;</a></span>canEvaluateSExtd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> canEvaluateSExtd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if we can take the specified value and return it as type Ty without inserting any new casts and without changing the value of the common low bits. </p>
<p>This is used by code that tries to promote integer operations to a wider types will allow us to eliminate the extension.</p>
<p>This function works on both vectors and scalars. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l01313">1313</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l00218">canAlwaysEvaluateInType()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l01313">canEvaluateSExtd()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l00231">canNotEvaluateInType()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="Instructions_8h_source.html#l02798">llvm::PHINode::incoming_values()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l01313">canEvaluateSExtd()</a>, and <a class="el" href="InstCombineCasts_8cpp_source.html#l01361">llvm::InstCombinerImpl::visitSExt()</a>.</p>

</div>
</div>
<a id="aefd6331c5fd6ec51f6a9e5558f885f28" name="aefd6331c5fd6ec51f6a9e5558f885f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd6331c5fd6ec51f6a9e5558f885f28">&#9670;&#160;</a></span>canEvaluateTruncated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> canEvaluateTruncated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>CxtI</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if we can evaluate the specified expression tree as type Ty instead of its larger type, and arrive with the same value. </p>
<p>This is used by code that tries to eliminate truncates.</p>
<p>Ty will always be a type smaller than V. We should return true if trunc(V) can be computed by computing V in the smaller type. If V is an instruction, then trunc(inst(x,y)) can be computed as inst(trunc(x),trunc(y)), which only makes sense if x and y can be efficiently truncated.</p>
<p>This function works on both vectors and scalars. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l00254">254</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BitmaskEnum_8h_source.html#l00184">llvm::BitWidth</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l00218">canAlwaysEvaluateInType()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l00254">canEvaluateTruncated()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l00231">canNotEvaluateInType()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l00162">llvm::computeKnownBits()</a>, <a class="el" href="InstCombiner_8h_source.html#l00485">llvm::InstCombiner::ComputeNumSignBits()</a>, <a class="el" href="APInt_8h_source.html#l00264">llvm::APInt::getBitsSetFrom()</a>, <a class="el" href="InstCombiner_8h_source.html#l00373">llvm::InstCombiner::getDataLayout()</a>, <a class="el" href="Type_8cpp_source.html#l00196">llvm::Type::getScalarSizeInBits()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html#a01609a46da35cca87e8ada6f7de40d23">llvm::ilist_node_impl&lt; ilist_detail::compute_node_options&lt; T, Options... &gt;::type &gt;::ilist_node_impl()</a>, <a class="el" href="Instructions_8h_source.html#l02798">llvm::PHINode::incoming_values()</a>, <a class="el" href="InstCombiner_8h_source.html#l00480">llvm::InstCombiner::MaskedValueIsZero()</a>, and <a class="el" href="APFloat_8cpp_source.html#l00306">llvm::APFloatBase::semanticsIntSizeInBits()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l00254">canEvaluateTruncated()</a>, and <a class="el" href="InstCombineCasts_8cpp_source.html#l00655">llvm::InstCombinerImpl::visitTrunc()</a>.</p>

</div>
</div>
<a id="a3d3ed8206aabad62293aeddd444bab9f" name="a3d3ed8206aabad62293aeddd444bab9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3ed8206aabad62293aeddd444bab9f">&#9670;&#160;</a></span>canEvaluateZExtd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> canEvaluateZExtd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>BitsToClear</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>CxtI</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the specified value can be computed in the specified wider type and produce the same low bits. </p>
<p>If not, return false.</p>
<p>If this function returns true, it can also return a non-zero number of bits (in BitsToClear) which indicates that the value it computes is correct for the zero extend, but that the additional BitsToClear bits need to be zero'd out. For example, to promote something like:</p>
<p>B = trunc i64 A to i32 C = lshr i32 B, 8 E = zext i32 C to i64</p>
<p>CanEvaluateZExtd for the 'lshr' will return true, and BitsToClear will be set to 8 to indicate that the promoted value needs to have bits 24-31 cleared in addition to bits 32-63. Since an 'and' will be generated to clear the top bits anyway, doing this has no extra cost.</p>
<p>This function works on both vectors and scalars. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l00978">978</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineCasts_8cpp_source.html#l00218">canAlwaysEvaluateInType()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l00978">canEvaluateZExtd()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l00231">canNotEvaluateInType()</a>, <a class="el" href="APInt_8h_source.html#l00274">llvm::APInt::getHighBitsSet()</a>, <a class="el" href="Instructions_8h_source.html#l02808">llvm::PHINode::getIncomingValue()</a>, <a class="el" href="Instructions_8h_source.html#l02804">llvm::PHINode::getNumIncomingValues()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="InstCombiner_8h_source.html#l00480">llvm::InstCombiner::MaskedValueIsZero()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l00978">canEvaluateZExtd()</a>, and <a class="el" href="InstCombineCasts_8cpp_source.html#l01091">llvm::InstCombinerImpl::visitZExt()</a>.</p>

</div>
</div>
<a id="aaa977254b83ff622718b40f1aa81271f" name="aaa977254b83ff622718b40f1aa81271f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa977254b83ff622718b40f1aa81271f">&#9670;&#160;</a></span>canNotEvaluateInType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> canNotEvaluateInType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filter out values that we can not evaluate in the destination type for free. </p>
<p>This is a helper for canEvaluate*. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l00231">231</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l01313">canEvaluateSExtd()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l00254">canEvaluateTruncated()</a>, and <a class="el" href="InstCombineCasts_8cpp_source.html#l00978">canEvaluateZExtd()</a>.</p>

</div>
</div>
<a id="a3e2793cc62829d80622b78cc681b25c2" name="a3e2793cc62829d80622b78cc681b25c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2793cc62829d80622b78cc681b25c2">&#9670;&#160;</a></span>canonicalizeBitCastExtElt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * canonicalizeBitCastExtElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BitCastInst.html">BitCastInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>BitCast</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize scalar bitcasts of extracted elements into a bitcast of the vector followed by extract element. </p>
<p>The backend tends to handle bitcasts of vectors better than bitcasts of scalars because vector registers are usually not type-specific like scalar integer or scalar floating-point. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l02230">2230</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombiner_8h_source.html#l00059">llvm::InstCombiner::Builder</a>, <a class="el" href="Instructions_8cpp_source.html#l03425">llvm::CastInst::Create()</a>, <a class="el" href="Instructions_8h_source.html#l01877">llvm::ExtractElementInst::Create()</a>, <a class="el" href="IRBuilder_8h_source.html#l02051">llvm::IRBuilderBase::CreateBitCast()</a>, <a class="el" href="Type_8cpp_source.html#l00732">llvm::VectorType::get()</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html#a01609a46da35cca87e8ada6f7de40d23">llvm::ilist_node_impl&lt; ilist_detail::compute_node_options&lt; T, Options... &gt;::type &gt;::ilist_node_impl()</a>, <a class="el" href="Type_8cpp_source.html#l00739">llvm::VectorType::isValidElementType()</a>, <a class="el" href="PatternMatch_8h_source.html#l01500">llvm::PatternMatch::m_ExtractElt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l02556">llvm::InstCombinerImpl::visitBitCast()</a>.</p>

</div>
</div>
<a id="a01395be91e03a1a4c5fd713885d8327f" name="a01395be91e03a1a4c5fd713885d8327f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01395be91e03a1a4c5fd713885d8327f">&#9670;&#160;</a></span>collectInsertionElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> collectInsertionElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Shift</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Elements</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>VecEltTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isBigEndian</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>V is a value which is inserted into a vector of VecEltTy. </p>
<p>Look through the value to see if we can decompose it into insertions into the vector. See the example in the comment for OptimizeIntegerToVectorInsertions for the pattern this handles. The type of V is always a non-zero multiple of VecEltTy's size. Shift is the number of bits between the lsb of V and the lsb of the vector.</p>
<p>This returns false if the pattern can't be matched or true if it can, filling in Elements with the elements found here. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l02090">2090</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l02090">collectInsertionElements()</a>, <a class="el" href="Type_8cpp_source.html#l00333">llvm::IntegerType::get()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="Constants_8cpp_source.html#l02213">llvm::ConstantExpr::getBitCast()</a>, <a class="el" href="Constants_8cpp_source.html#l02606">llvm::ConstantExpr::getLShr()</a>, <a class="el" href="Constants_8cpp_source.html#l02075">llvm::ConstantExpr::getTrunc()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l02076">getTypeSizeIndex()</a>, <a class="el" href="Constants_8h_source.html#l00145">llvm::ConstantInt::getZExtValue()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html#a01609a46da35cca87e8ada6f7de40d23">llvm::ilist_node_impl&lt; ilist_detail::compute_node_options&lt; T, Options... &gt;::type &gt;::ilist_node_impl()</a>, <a class="el" href="CombinerHelper_8cpp_source.html#l00112">isBigEndian()</a>, and <a class="el" href="InstCombineCasts_8cpp_source.html#l02072">isMultipleOfTypeSize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l02090">collectInsertionElements()</a>, and <a class="el" href="InstCombineCasts_8cpp_source.html#l02201">optimizeIntegerToVectorInsertions()</a>.</p>

</div>
</div>
<a id="a68d58b6cb8f56c90aa445f4857a8d430" name="a68d58b6cb8f56c90aa445f4857a8d430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d58b6cb8f56c90aa445f4857a8d430">&#9670;&#160;</a></span>fitsInFPType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> fitsInFPType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ConstantFP.html">ConstantFP</a> *</td>          <td class="paramname"><span class="paramname"><em>CFP</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1fltSemantics.html">fltSemantics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Sem</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a Constant* for the specified floating-point constant if it fits in the specified FP type without changing its value. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l01499">1499</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="APFloat_8cpp_source.html#l05157">llvm::APFloat::convert()</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="Constants_8h_source.html#l00296">llvm::ConstantFP::getValueAPF()</a>, and <a class="el" href="APFloat_8h_source.html#l00230">llvm::APFloatBase::rmNearestTiesToEven</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l01506">shrinkFPConstant()</a>.</p>

</div>
</div>
<a id="a6556e45ee27ad333bf33eda6b1f04b8a" name="a6556e45ee27ad333bf33eda6b1f04b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6556e45ee27ad333bf33eda6b1f04b8a">&#9670;&#160;</a></span>foldBitCastBitwiseLogic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldBitCastBitwiseLogic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BitCastInst.html">BitCastInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>BitCast</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the type of a bitwise logic operation if we can eliminate a bitcast. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l02257">2257</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="Instructions_8cpp_source.html#l03044">llvm::BinaryOperator::Create()</a>, <a class="el" href="Instructions_8cpp_source.html#l03580">llvm::CastInst::CreateBitOrPointerCast()</a>, <a class="el" href="InstrTypes_8h_source.html#l00391">llvm::BinaryOperator::getOpcode()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00219">llvm::Instruction::isBitwiseLogicOp()</a>, <a class="el" href="Type_8h_source.html#l00266">llvm::Type::isVectorTy()</a>, <a class="el" href="PatternMatch_8h_source.html#l00084">llvm::PatternMatch::m_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l01618">llvm::PatternMatch::m_BitCast()</a>, <a class="el" href="PatternMatch_8h_source.html#l00144">llvm::PatternMatch::m_Constant()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l02556">llvm::InstCombinerImpl::visitBitCast()</a>.</p>

</div>
</div>
<a id="a5d0fa3868fb321fcd4b5d632028db897" name="a5d0fa3868fb321fcd4b5d632028db897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0fa3868fb321fcd4b5d632028db897">&#9670;&#160;</a></span>foldBitCastSelect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldBitCastSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BitCastInst.html">BitCastInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>BitCast</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the type of a select if we can eliminate a bitcast. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l02329">2329</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="RISCVRedundantCopyElimination_8cpp_source.html#l00075">Cond</a>, <a class="el" href="Instructions_8h_source.html#l01760">llvm::SelectInst::Create()</a>, <a class="el" href="PatternMatch_8h_source.html#l01618">llvm::PatternMatch::m_BitCast()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l01470">llvm::PatternMatch::m_Select()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l02556">llvm::InstCombinerImpl::visitBitCast()</a>.</p>

</div>
</div>
<a id="aee3e98b16f1c8d8d8b30b9a459a6a602" name="aee3e98b16f1c8d8d8b30b9a459a6a602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3e98b16f1c8d8d8b30b9a459a6a602">&#9670;&#160;</a></span>foldVecTruncToExtElt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldVecTruncToExtElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TruncInst.html">TruncInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Trunc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a vector that is bitcast to an integer, optionally logically right-shifted, and truncated, convert it to an extractelement. </p>
<p>Example (big endian): trunc (lshr (bitcast &lt;4 x i32&gt; X to i128), 32) to i32 ---&gt; extractelement &lt;4 x i32&gt; X, 1 </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l00383">383</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombiner_8h_source.html#l00059">llvm::InstCombiner::Builder</a>, <a class="el" href="Instructions_8h_source.html#l01877">llvm::ExtractElementInst::Create()</a>, <a class="el" href="IRBuilder_8h_source.html#l02051">llvm::IRBuilderBase::CreateBitCast()</a>, <a class="el" href="Type_8cpp_source.html#l00748">llvm::FixedVectorType::get()</a>, <a class="el" href="InstCombiner_8h_source.html#l00373">llvm::InstCombiner::getDataLayout()</a>, <a class="el" href="IRBuilder_8h_source.html#l00472">llvm::IRBuilderBase::getInt32()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00239">llvm::DataLayout::isBigEndian()</a>, <a class="el" href="PatternMatch_8h_source.html#l01618">llvm::PatternMatch::m_BitCast()</a>, <a class="el" href="PatternMatch_8h_source.html#l00218">llvm::PatternMatch::m_CombineOr()</a>, <a class="el" href="PatternMatch_8h_source.html#l00147">llvm::PatternMatch::m_ConstantInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l01125">llvm::PatternMatch::m_LShr()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l00655">llvm::InstCombinerImpl::visitTrunc()</a>.</p>

</div>
</div>
<a id="ab73ec0e6b4611633546e74ee96cb9e13" name="ab73ec0e6b4611633546e74ee96cb9e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73ec0e6b4611633546e74ee96cb9e13">&#9670;&#160;</a></span>getMinimumFPType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Type.html">Type</a> * getMinimumFPType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the minimum FP type we can safely truncate to. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l01560">1560</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineCasts_8cpp_source.html#l01506">shrinkFPConstant()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l01525">shrinkFPConstantVector()</a>, and <a class="el" href="Mips16ISelLowering_8cpp_source.html#l00341">T</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l01635">llvm::InstCombinerImpl::visitFPTrunc()</a>.</p>

</div>
</div>
<a id="ac8947451998676abcce5452a1a8f5848" name="ac8947451998676abcce5452a1a8f5848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8947451998676abcce5452a1a8f5848">&#9670;&#160;</a></span>getTypeSizeIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classunsigned.html">unsigned</a> getTypeSizeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l02076">2076</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l02090">collectInsertionElements()</a>.</p>

</div>
</div>
<a id="a24b18f2c77f69e54841c51bb3d31cad2" name="a24b18f2c77f69e54841c51bb3d31cad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b18f2c77f69e54841c51bb3d31cad2">&#9670;&#160;</a></span>hasStoreUsersOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> hasStoreUsersOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CastInst.html">CastInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>CI</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all users of CI are StoreInsts. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l02372">2372</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00421">llvm::Value::users()</a>.</p>

</div>
</div>
<a id="aac5576a66149a9259706758d613ba555" name="aac5576a66149a9259706758d613ba555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5576a66149a9259706758d613ba555">&#9670;&#160;</a></span>isKnownExactCastIntToFP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> isKnownExactCastIntToFP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CastInst.html">CastInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the cast from integer to FP can be proven to be exact for all possible inputs (the conversion does not lose any precision). </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l01588">1588</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="InstCombiner_8h_source.html#l00464">llvm::InstCombiner::computeKnownBits()</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html#a01609a46da35cca87e8ada6f7de40d23">llvm::ilist_node_impl&lt; ilist_detail::compute_node_options&lt; T, Options... &gt;::type &gt;::ilist_node_impl()</a>, <a class="el" href="PatternMatch_8h_source.html#l01708">llvm::PatternMatch::m_FPToSI()</a>, <a class="el" href="PatternMatch_8h_source.html#l01703">llvm::PatternMatch::m_FPToUI()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l01837">llvm::InstCombinerImpl::foldItoFPtoI()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l01819">llvm::InstCombinerImpl::visitFPExt()</a>, and <a class="el" href="InstCombineCasts_8cpp_source.html#l01635">llvm::InstCombinerImpl::visitFPTrunc()</a>.</p>

</div>
</div>
<a id="a8efab72b40fc7836709221d3e97139c6" name="a8efab72b40fc7836709221d3e97139c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efab72b40fc7836709221d3e97139c6">&#9670;&#160;</a></span>isMultipleOfTypeSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> isMultipleOfTypeSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *</td>          <td class="paramname"><span class="paramname"><em>Ty</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l02072">2072</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l02090">collectInsertionElements()</a>.</p>

</div>
</div>
<a id="a8f948dd0c375dfeb4cdf99bc33905e66" name="a8f948dd0c375dfeb4cdf99bc33905e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f948dd0c375dfeb4cdf99bc33905e66">&#9670;&#160;</a></span>optimizeIntegerToVectorInsertions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * optimizeIntegerToVectorInsertions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BitCastInst.html">BitCastInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>CI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the input is an 'or' instruction, we may be doing shifts and ors to assemble the elements of the vector manually. </p>
<p>Try to rip the code out and replace it with insertelements. This is to optimize code like this:</p>
<p>tmp37 = bitcast float inc to i32 tmp38 = zext i32 tmp37 to i64 tmp31 = bitcast float inc5 to i32 tmp32 = zext i32 tmp31 to i64 tmp33 = shl i64 tmp32, 32 ins35 = or i64 tmp33, tmp38 tmp43 = bitcast i64 ins35 to &lt;2 x float&gt;</p>
<p>Into two insertelements that do "buildvector{%inc, %inc5}". </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l02201">2201</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombiner_8h_source.html#l00059">llvm::InstCombiner::Builder</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l02090">collectInsertionElements()</a>, <a class="el" href="IRBuilder_8h_source.html#l02396">llvm::IRBuilderBase::CreateInsertElement()</a>, <a class="el" href="InstCombiner_8h_source.html#l00373">llvm::InstCombiner::getDataLayout()</a>, <a class="el" href="IRBuilder_8h_source.html#l00472">llvm::IRBuilderBase::getInt32()</a>, <a class="el" href="Constants_8cpp_source.html#l00356">llvm::Constant::getNullValue()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, and <a class="el" href="DataLayout_8h_source.html#l00239">llvm::DataLayout::isBigEndian()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l02556">llvm::InstCombinerImpl::visitBitCast()</a>.</p>

</div>
</div>
<a id="a75e6b6bf03adf614aaf100a9afdcd612" name="a75e6b6bf03adf614aaf100a9afdcd612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e6b6bf03adf614aaf100a9afdcd612">&#9670;&#160;</a></span>optimizeVectorResizeWithIntegerBitCasts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * optimizeVectorResizeWithIntegerBitCasts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>InVal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> *</td>          <td class="paramname"><span class="paramname"><em>DestTy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This input value (which is known to have vector type) is being zero extended or truncated to the specified vector type. </p>
<p>Since the zext/trunc is done using an integer type, we have a (bitcast(cast(bitcast))) pattern, endianness will impact which end of the vector that is extended or truncated.</p>
<p>A vector is always stored with index 0 at the lowest address, which corresponds to the most significant bits for a big endian stored integer and the least significant bits for little endian. A trunc/zext of an integer impacts the big end of the integer. Thus, we need to add/remove elements at the front of the vector for big endian targets, and the back of the vector for little endian targets.</p>
<p>Try to replace it with a shuffle (and vector/vector bitcast) if possible.</p>
<p>The source and destination vector types may have different element types. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l02002">2002</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="InstCombiner_8h_source.html#l00059">llvm::InstCombiner::Builder</a>, <a class="el" href="IRBuilder_8h_source.html#l02051">llvm::IRBuilderBase::CreateBitCast()</a>, <a class="el" href="Type_8cpp_source.html#l00748">llvm::FixedVectorType::get()</a>, <a class="el" href="Constants_8cpp_source.html#l01743">llvm::PoisonValue::get()</a>, <a class="el" href="InstCombiner_8h_source.html#l00373">llvm::InstCombiner::getDataLayout()</a>, <a class="el" href="Constants_8cpp_source.html#l00356">llvm::Constant::getNullValue()</a>, and <a class="el" href="DataLayout_8h_source.html#l00239">llvm::DataLayout::isBigEndian()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l02556">llvm::InstCombinerImpl::visitBitCast()</a>.</p>

</div>
</div>
<a id="aa482becddf9cf916dc4ec68fd7a5a679" name="aa482becddf9cf916dc4ec68fd7a5a679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa482becddf9cf916dc4ec68fd7a5a679">&#9670;&#160;</a></span>shrinkFPConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Type.html">Type</a> * shrinkFPConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ConstantFP.html">ConstantFP</a> *</td>          <td class="paramname"><span class="paramname"><em>CFP</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l01506">1506</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineCasts_8cpp_source.html#l01499">fitsInFPType()</a>, <a class="el" href="Value_8cpp_source.html#l01069">llvm::Value::getContext()</a>, <a class="el" href="Type_8cpp_source.html#l00237">llvm::Type::getDoubleTy()</a>, <a class="el" href="Type_8cpp_source.html#l00236">llvm::Type::getFloatTy()</a>, <a class="el" href="Type_8cpp_source.html#l00234">llvm::Type::getHalfTy()</a>, <a class="el" href="Type_8cpp_source.html#l00242">llvm::Type::getPPC_FP128Ty()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="APFloat_8cpp_source.html#l00250">llvm::APFloatBase::IEEEdouble()</a>, <a class="el" href="APFloat_8cpp_source.html#l00247">llvm::APFloatBase::IEEEhalf()</a>, <a class="el" href="APFloat_8cpp_source.html#l00249">llvm::APFloatBase::IEEEsingle()</a>, and <a class="el" href="Type_8h_source.html#l00157">llvm::Type::isDoubleTy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l01560">getMinimumFPType()</a>, and <a class="el" href="InstCombineCasts_8cpp_source.html#l01525">shrinkFPConstantVector()</a>.</p>

</div>
</div>
<a id="acdecfd6018030775941d22e75392cb0c" name="acdecfd6018030775941d22e75392cb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdecfd6018030775941d22e75392cb0c">&#9670;&#160;</a></span>shrinkFPConstantVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Type.html">Type</a> * shrinkFPConstantVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l01525">1525</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="Type_8cpp_source.html#l00748">llvm::FixedVectorType::get()</a>, <a class="el" href="InstCombineCasts_8cpp_source.html#l01506">shrinkFPConstant()</a>, and <a class="el" href="Mips16ISelLowering_8cpp_source.html#l00341">T</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l01560">getMinimumFPType()</a>.</p>

</div>
</div>
<a id="a77aac577d89abc9411adfdf918d7d539" name="a77aac577d89abc9411adfdf918d7d539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77aac577d89abc9411adfdf918d7d539">&#9670;&#160;</a></span>shrinkInsertElt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * shrinkInsertElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CastInst.html">CastInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Trunc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to narrow the width of an insert element. </p>
<p>This could be generalized for any vector constant, but we limit the transform to insertion into undef to avoid potential backend problems from unsupported insertion widths. This could also be extended to handle the case of inserting a scalar constant into a vector variable. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l00628">628</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Instructions_8h_source.html#l01942">llvm::InsertElementInst::Create()</a>, <a class="el" href="Constants_8cpp_source.html#l01724">llvm::UndefValue::get()</a>, <a class="el" href="InstrTypes_8h_source.html#l00668">llvm::CastInst::getOpcode()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="classllvm_1_1ilist__node__impl.html#a01609a46da35cca87e8ada6f7de40d23">llvm::ilist_node_impl&lt; ilist_detail::compute_node_options&lt; T, Options... &gt;::type &gt;::ilist_node_impl()</a>, <a class="el" href="PatternMatch_8h_source.html#l00136">llvm::PatternMatch::m_Undef()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l01635">llvm::InstCombinerImpl::visitFPTrunc()</a>, and <a class="el" href="InstCombineCasts_8cpp_source.html#l00655">llvm::InstCombinerImpl::visitTrunc()</a>.</p>

</div>
</div>
<a id="a40c4c6660c6d108c0202fd73c28f2834" name="a40c4c6660c6d108c0202fd73c28f2834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c4c6660c6d108c0202fd73c28f2834">&#9670;&#160;</a></span>shrinkSplatShuffle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * shrinkSplatShuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1TruncInst.html">TruncInst</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Trunc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to narrow the width of a splat shuffle. </p>
<p>This could be generalized to any shuffle with a constant operand, but we limit the transform to avoid creating a shuffle type that targets may not be able to lower effectively. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineCasts_8cpp_source.html#l00608">608</a> of file <a class="el" href="InstCombineCasts_8cpp_source.html">InstCombineCasts.cpp</a>.</p>

<p class="reference">References <a class="el" href="STLExtras_8h_source.html#l02019">llvm::all_equal()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="PatternMatch_8h_source.html#l00136">llvm::PatternMatch::m_Undef()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineCasts_8cpp_source.html#l00655">llvm::InstCombinerImpl::visitTrunc()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 21 2024 13:50:39 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
