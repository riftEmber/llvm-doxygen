<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Transforms/InstCombine/InstCombineAndOrXor.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLVM<span id="projectnumber">&#160;17.0.0rc</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a72932e0778af28115095468f6286ff8.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_99567d9c0c7f3685f25b19ecc341a865.html">InstCombine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">InstCombineAndOrXor.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="InstCombineInternal_8h_source.html">InstCombineInternal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="CmpInstAnalysis_8h_source.html">llvm/Analysis/CmpInstAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InstructionSimplify_8h_source.html">llvm/Analysis/InstructionSimplify.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ConstantRange_8h_source.html">llvm/IR/ConstantRange.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Intrinsics_8h_source.html">llvm/IR/Intrinsics.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">llvm/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InstCombiner_8h_source.html">llvm/Transforms/InstCombine/InstCombiner.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Transforms_2Utils_2Local_8h_source.html">llvm/Transforms/Utils/Local.h</a>&quot;</code><br />
</div>
<p><a href="InstCombineAndOrXor_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIntPart.html">IntPart</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;instcombine&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa9c705ecec80ebd584bb3d54b48f7ee1" id="r_aa9c705ecec80ebd584bb3d54b48f7ee1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1">MaskedICmpType</a> { <br />
&#160;&#160;<a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1a7cc1609a568ad3b240cf86126370e24f">AMask_AllOnes</a> = 1
, <a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1a54ee032f1a4a27e3066fbb88346cd49a">AMask_NotAllOnes</a> = 2
, <a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1a4357ae5a8ec7cec4162a1f25c69558ff">BMask_AllOnes</a> = 4
, <a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1a2b00a345b6b0214f7aa5cbe8203aeb3e">BMask_NotAllOnes</a> = 8
, <br />
&#160;&#160;<a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1a37651a7acaf5871fb8a4d593749c06f4">Mask_AllZeros</a> = 16
, <a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1ac7606c30ddb7a593051b6e5ad209f30c">Mask_NotAllZeros</a> = 32
, <a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1ada8a0932439ca5f15218c4d7cd43d895">AMask_Mixed</a> = 64
, <a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1a1ee37b18b82ef426e90d86a093d45334">AMask_NotMixed</a> = 128
, <br />
&#160;&#160;<a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1a3f5a9337c05ff64ea433ed2d4e9d49d5">BMask_Mixed</a> = 256
, <a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1a10e63e798489e9c5ad2dc2c5ed98ac10">BMask_NotMixed</a> = 512
<br />
 }</td></tr>
<tr class="memdesc:aa9c705ecec80ebd584bb3d54b48f7ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classify (icmp eq (A &amp; B), C) and (icmp ne (A &amp; B), C) as matching patterns that can be simplified.  <a href="#aa9c705ecec80ebd584bb3d54b48f7ee1">More...</a><br /></td></tr>
<tr class="separator:aa9c705ecec80ebd584bb3d54b48f7ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a89cfa00019cb17baa05532705ea198e0" id="r_a89cfa00019cb17baa05532705ea198e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89cfa00019cb17baa05532705ea198e0">getNewICmpValue</a> (<a class="el" href="classunsigned.html">unsigned</a> Code, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">Sign</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a89cfa00019cb17baa05532705ea198e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the complement of getICmpCode, which turns an opcode and two operands into either a constant true or false, or a brand new ICmp instruction.  <br /></td></tr>
<tr class="separator:a89cfa00019cb17baa05532705ea198e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72e7003829df7704d63a8d830742a35" id="r_ab72e7003829df7704d63a8d830742a35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab72e7003829df7704d63a8d830742a35">getFCmpValue</a> (<a class="el" href="classunsigned.html">unsigned</a> Code, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:ab72e7003829df7704d63a8d830742a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the complement of getFCmpCode, which turns an opcode and two operands into either a FCmp instruction, or a true/false constant.  <br /></td></tr>
<tr class="separator:ab72e7003829df7704d63a8d830742a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac480d1a3d980979539ddec168ecd72a4" id="r_ac480d1a3d980979539ddec168ecd72a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac480d1a3d980979539ddec168ecd72a4">SimplifyBSwap</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:ac480d1a3d980979539ddec168ecd72a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform BITWISE_OP(BSWAP(A),BSWAP(B)) or BITWISE_OP(BSWAP(A), Constant) to BSWAP(BITWISE_OP(A, B))  <br /></td></tr>
<tr class="separator:ac480d1a3d980979539ddec168ecd72a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39257c6c73db3440e6d05b9eec5999a0" id="r_a39257c6c73db3440e6d05b9eec5999a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39257c6c73db3440e6d05b9eec5999a0">getMaskedICmpType</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, ICmpInst::Predicate Pred)</td></tr>
<tr class="memdesc:a39257c6c73db3440e6d05b9eec5999a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of patterns (from MaskedICmpType) that (icmp SCC (A &amp; B), C) satisfies.  <br /></td></tr>
<tr class="separator:a39257c6c73db3440e6d05b9eec5999a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c36c07a47775cef8f8e93d8090d919" id="r_a09c36c07a47775cef8f8e93d8090d919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09c36c07a47775cef8f8e93d8090d919">conjugateICmpMask</a> (<a class="el" href="classunsigned.html">unsigned</a> Mask)</td></tr>
<tr class="memdesc:a09c36c07a47775cef8f8e93d8090d919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an analysis of a masked ICmp into its equivalent if all boolean operations had the opposite sense.  <br /></td></tr>
<tr class="separator:a09c36c07a47775cef8f8e93d8090d919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1267ddd1fbc10bd31ab88ecb2109bd" id="r_a1d1267ddd1fbc10bd31ab88ecb2109bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d1267ddd1fbc10bd31ab88ecb2109bd">decomposeBitTestICmp</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classllvm_1_1CmpInst.html#a2be3583dac92a031fa1458d4d992c78b">CmpInst::Predicate</a> &amp;Pred, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;Z)</td></tr>
<tr class="separator:a1d1267ddd1fbc10bd31ab88ecb2109bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9216b6f91863c6f4c51e03aa7147c019" id="r_a9216b6f91863c6f4c51e03aa7147c019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> std::optional&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9216b6f91863c6f4c51e03aa7147c019">getMaskedTypeForICmpPair</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, ICmpInst::Predicate &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">PredL</a>, ICmpInst::Predicate &amp;PredR)</td></tr>
<tr class="memdesc:a9216b6f91863c6f4c51e03aa7147c019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E).  <br /></td></tr>
<tr class="separator:a9216b6f91863c6f4c51e03aa7147c019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30194649427f98c3ceaf7092c83911dc" id="r_a30194649427f98c3ceaf7092c83911dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30194649427f98c3ceaf7092c83911dc">foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsAnd</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, ICmpInst::Predicate <a class="el" href="classllvm_1_1ilist__node__impl.html">PredL</a>, ICmpInst::Predicate PredR, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a30194649427f98c3ceaf7092c83911dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y), where the left-hand side is of type Mask_NotAllZeros and the right hand side is of type BMask_Mixed.  <br /></td></tr>
<tr class="separator:a30194649427f98c3ceaf7092c83911dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea6a6eec165567da33302ad84811f84" id="r_a6ea6a6eec165567da33302ad84811f84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ea6a6eec165567da33302ad84811f84">foldLogOpOfMaskedICmpsAsymmetric</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsAnd</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, ICmpInst::Predicate <a class="el" href="classllvm_1_1ilist__node__impl.html">PredL</a>, ICmpInst::Predicate PredR, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">LHSMask</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">RHSMask</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a6ea6a6eec165567da33302ad84811f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold (icmp(A &amp; B) ==/!= 0) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y), where the left-hand side and the right hand side aren't of the common mask pattern type.  <br /></td></tr>
<tr class="separator:a6ea6a6eec165567da33302ad84811f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c138f9e5e8e5c6a477b297d39d22094" id="r_a6c138f9e5e8e5c6a477b297d39d22094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c138f9e5e8e5c6a477b297d39d22094">foldLogOpOfMaskedICmps</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsAnd</a>, <a class="el" href="classbool.html">bool</a> IsLogical, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a6c138f9e5e8e5c6a477b297d39d22094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y).  <br /></td></tr>
<tr class="separator:a6c138f9e5e8e5c6a477b297d39d22094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f569ebf4402ad560d7c147f688ac05a" id="r_a1f569ebf4402ad560d7c147f688ac05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f569ebf4402ad560d7c147f688ac05a">foldSignedTruncationCheck</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">ICmp0</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">ICmp1</a>, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;CxtI, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a1f569ebf4402ad560d7c147f688ac05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">General pattern: X &amp; Y.  <br /></td></tr>
<tr class="separator:a1f569ebf4402ad560d7c147f688ac05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3634e7e4bbadf2cb8229341858f520f3" id="r_a3634e7e4bbadf2cb8229341858f520f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3634e7e4bbadf2cb8229341858f520f3">foldIsPowerOf2OrZero</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Cmp0</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp1, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsAnd</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a3634e7e4bbadf2cb8229341858f520f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold (icmp eq ctpop(X) 1) | (icmp eq X 0) into (icmp ult ctpop(X) 2) and fold (icmp ne ctpop(X) 1) &amp; (icmp ne X 0) into (icmp ugt ctpop(X) 1).  <br /></td></tr>
<tr class="separator:a3634e7e4bbadf2cb8229341858f520f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4527846f6a8b98d7fe16428ff7a28e" id="r_a6d4527846f6a8b98d7fe16428ff7a28e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d4527846f6a8b98d7fe16428ff7a28e">foldIsPowerOf2</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Cmp0</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp1, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">JoinedByAnd</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a6d4527846f6a8b98d7fe16428ff7a28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a pair of compares that check if a value has exactly 1 bit set.  <br /></td></tr>
<tr class="separator:a6d4527846f6a8b98d7fe16428ff7a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5532e05d5caa4fb5e2b8512aa3095f1e" id="r_a5532e05d5caa4fb5e2b8512aa3095f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5532e05d5caa4fb5e2b8512aa3095f1e">foldNegativePower2AndShiftedMask</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, ICmpInst::Predicate <a class="el" href="classllvm_1_1ilist__node__impl.html">PredL</a>, ICmpInst::Predicate PredR, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a5532e05d5caa4fb5e2b8512aa3095f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold (icmp(A &amp; B) == 0) &amp; (icmp(A &amp; D) != E) into (icmp A u&lt; D) iff B is a contiguous set of ones starting from the most significant bit (negative power of 2), D and E are equal, and D is a contiguous set of ones starting at the most significant zero bit in B.  <br /></td></tr>
<tr class="separator:a5532e05d5caa4fb5e2b8512aa3095f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609a05f40709dea74bb5cd248c5816fd" id="r_a609a05f40709dea74bb5cd248c5816fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a609a05f40709dea74bb5cd248c5816fd">foldPowerOf2AndShiftedMask</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Cmp0</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp1, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">JoinedByAnd</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a609a05f40709dea74bb5cd248c5816fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold ((icmp X u&lt; P) &amp; (icmp(X &amp; M) != M)) or ((icmp X s&gt; -1) &amp; (icmp(X &amp; M) != M)) into (icmp X u&lt; M).  <br /></td></tr>
<tr class="separator:a609a05f40709dea74bb5cd248c5816fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dce8fa354f0f1d52209e805f0ae6a3" id="r_a24dce8fa354f0f1d52209e805f0ae6a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24dce8fa354f0f1d52209e805f0ae6a3">foldUnsignedUnderflowCheck</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">ZeroICmp</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">UnsignedICmp</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsAnd</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1SimplifyQuery.html">SimplifyQuery</a> &amp;Q, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a24dce8fa354f0f1d52209e805f0ae6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commuted variants are assumed to be handled by calling this function again with the parameters swapped.  <br /></td></tr>
<tr class="separator:a24dce8fa354f0f1d52209e805f0ae6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7662d7ee7f100c9455f4a2c7e4992929" id="r_a7662d7ee7f100c9455f4a2c7e4992929"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> std::optional&lt; <a class="el" href="structIntPart.html">IntPart</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7662d7ee7f100c9455f4a2c7e4992929">matchIntPart</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V)</td></tr>
<tr class="memdesc:a7662d7ee7f100c9455f4a2c7e4992929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match an extraction of bits from an integer.  <br /></td></tr>
<tr class="separator:a7662d7ee7f100c9455f4a2c7e4992929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940bbfdea38f2643d0b63c2cc5af4a82" id="r_a940bbfdea38f2643d0b63c2cc5af4a82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a940bbfdea38f2643d0b63c2cc5af4a82">extractIntPart</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structIntPart.html">IntPart</a> &amp;<a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, <a class="el" href="classllvm_1_1IRBuilderBase.html">IRBuilderBase</a> &amp;Builder)</td></tr>
<tr class="memdesc:a940bbfdea38f2643d0b63c2cc5af4a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize an extraction of bits from an integer in IR.  <br /></td></tr>
<tr class="separator:a940bbfdea38f2643d0b63c2cc5af4a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce22397c3eff1d8c0dc8e3d8c464829" id="r_afce22397c3eff1d8c0dc8e3d8c464829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afce22397c3eff1d8c0dc8e3d8c464829">foldAndOrOfICmpsWithConstEq</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">Cmp0</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *Cmp1, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsAnd</a>, <a class="el" href="classbool.html">bool</a> IsLogical, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1SimplifyQuery.html">SimplifyQuery</a> &amp;Q)</td></tr>
<tr class="memdesc:afce22397c3eff1d8c0dc8e3d8c464829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce logic-of-compares with equality to a constant by substituting a common operand with the constant.  <br /></td></tr>
<tr class="separator:afce22397c3eff1d8c0dc8e3d8c464829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ccec2dd2fc482ea50af1764f1db598" id="r_a67ccec2dd2fc482ea50af1764f1db598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67ccec2dd2fc482ea50af1764f1db598">stripSignOnlyFPOps</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *Val)</td></tr>
<tr class="memdesc:a67ccec2dd2fc482ea50af1764f1db598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore all operations which only change the sign of a value, returning the underlying magnitude value.  <br /></td></tr>
<tr class="separator:a67ccec2dd2fc482ea50af1764f1db598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e92e028c2dd81bf7d518dfc3960624a" id="r_a9e92e028c2dd81bf7d518dfc3960624a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e92e028c2dd81bf7d518dfc3960624a">matchIsNotNaN</a> (FCmpInst::Predicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>)</td></tr>
<tr class="memdesc:a9e92e028c2dd81bf7d518dfc3960624a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches canonical form of isnan, fcmp ord x, 0.  <br /></td></tr>
<tr class="separator:a9e92e028c2dd81bf7d518dfc3960624a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9977c80be67ea7e51bb37ee242d1cc4c" id="r_a9977c80be67ea7e51bb37ee242d1cc4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9977c80be67ea7e51bb37ee242d1cc4c">matchUnorderedInfCompare</a> (FCmpInst::Predicate <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>)</td></tr>
<tr class="memdesc:a9977c80be67ea7e51bb37ee242d1cc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches fcmp u__ x, +/-inf.  <br /></td></tr>
<tr class="separator:a9977c80be67ea7e51bb37ee242d1cc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5946d75decfd106d2b75af6d59009f34" id="r_a5946d75decfd106d2b75af6d59009f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5946d75decfd106d2b75af6d59009f34">matchIsFiniteTest</a> (<a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder, <a class="el" href="classllvm_1_1FCmpInst.html">FCmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1FCmpInst.html">FCmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>)</td></tr>
<tr class="memdesc:a5946d75decfd106d2b75af6d59009f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">and (fcmp ord x, 0), (fcmp u* x, inf) -&gt; fcmp o* x, inf  <br /></td></tr>
<tr class="separator:a5946d75decfd106d2b75af6d59009f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151e95d3f063067aa27c74930296a25e" id="r_a151e95d3f063067aa27c74930296a25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a151e95d3f063067aa27c74930296a25e">matchIsFPClassLikeFCmp</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="namespacellvm.html#ab471937b9a227e70c7fe8bd9604014d6">Op</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">ClassVal</a>, <a class="el" href="classuint64__t.html">uint64_t</a> &amp;<a class="el" href="classllvm_1_1ilist__node__impl.html">ClassMask</a>)</td></tr>
<tr class="memdesc:a151e95d3f063067aa27c74930296a25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match an fcmp against a special value that performs a test possible by llvm.is.fpclass.  <br /></td></tr>
<tr class="separator:a151e95d3f063067aa27c74930296a25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8208d3cd3c60073f5c9ceefec06ab2e3" id="r_a8208d3cd3c60073f5c9ceefec06ab2e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8208d3cd3c60073f5c9ceefec06ab2e3">reassociateFCmps</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;BO, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a8208d3cd3c60073f5c9ceefec06ab2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This a limited reassociation for a special case (see above) where we are checking if two values are either both NAN (unordered) or not-NAN (ordered).  <br /></td></tr>
<tr class="separator:a8208d3cd3c60073f5c9ceefec06ab2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d0af3e9f9322e328e67694a9af7d02" id="r_a11d0af3e9f9322e328e67694a9af7d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11d0af3e9f9322e328e67694a9af7d02">matchDeMorgansLaws</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a11d0af3e9f9322e328e67694a9af7d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match variations of De Morgan's Laws: (~A &amp; ~B) == (~(A | B)) (~A | ~B) == (~(A &amp; B))  <br /></td></tr>
<tr class="separator:a11d0af3e9f9322e328e67694a9af7d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71f2a5fb47a5112628bfe2951eed48b" id="r_ad71f2a5fb47a5112628bfe2951eed48b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad71f2a5fb47a5112628bfe2951eed48b">foldLogicCastConstant</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;Logic, <a class="el" href="classllvm_1_1CastInst.html">CastInst</a> *Cast, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:ad71f2a5fb47a5112628bfe2951eed48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold {and,or,xor} (cast X), C.  <br /></td></tr>
<tr class="separator:ad71f2a5fb47a5112628bfe2951eed48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385c1da88456d434ee18caa8f48018c2" id="r_a385c1da88456d434ee18caa8f48018c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a385c1da88456d434ee18caa8f48018c2">foldAndToXor</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="separator:a385c1da88456d434ee18caa8f48018c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26257c73e483eab4b0e15d53340de986" id="r_a26257c73e483eab4b0e15d53340de986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26257c73e483eab4b0e15d53340de986">foldOrToXor</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="separator:a26257c73e483eab4b0e15d53340de986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f025ca3dbad2ca618ad4bf63fa51bb0" id="r_a3f025ca3dbad2ca618ad4bf63fa51bb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f025ca3dbad2ca618ad4bf63fa51bb0">canNarrowShiftAmt</a> (<a class="el" href="classllvm_1_1Constant.html">Constant</a> *<a class="el" href="BuiltinGCs_8cpp.html#a694d9607a781d330039787de0726acc0">C</a>, <a class="el" href="classunsigned.html">unsigned</a> BitWidth)</td></tr>
<tr class="memdesc:a3f025ca3dbad2ca618ad4bf63fa51bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a constant shift amount is always less than the specified bit-width.  <br /></td></tr>
<tr class="separator:a3f025ca3dbad2ca618ad4bf63fa51bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01a210491dcbefc8db253f4dbaa6497" id="r_ab01a210491dcbefc8db253f4dbaa6497"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab01a210491dcbefc8db253f4dbaa6497">foldComplexAndOrPatterns</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:ab01a210491dcbefc8db253f4dbaa6497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try folding relatively complex patterns for both And and Or operations with all And and Or swapped.  <br /></td></tr>
<tr class="separator:ab01a210491dcbefc8db253f4dbaa6497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80e92048884e85b87ddd733785e44d9" id="r_ac80e92048884e85b87ddd733785e44d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac80e92048884e85b87ddd733785e44d9">reassociateForUses</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;BO, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombinerImpl::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:ac80e92048884e85b87ddd733785e44d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to reassociate a pair of binops so that values with one use only are part of the same instruction.  <br /></td></tr>
<tr class="separator:ac80e92048884e85b87ddd733785e44d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8ca6f7206a11fd57d6e194b2523ffe" id="r_a7b8ca6f7206a11fd57d6e194b2523ffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b8ca6f7206a11fd57d6e194b2523ffe">canonicalizeLogicFirst</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="separator:a7b8ca6f7206a11fd57d6e194b2523ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac800cc10159d350923dc27446b9123f0" id="r_ac800cc10159d350923dc27446b9123f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac800cc10159d350923dc27446b9123f0">matchFunnelShift</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;Or, <a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC)</td></tr>
<tr class="memdesc:ac800cc10159d350923dc27446b9123f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match UB-safe variants of the funnel shift intrinsic.  <br /></td></tr>
<tr class="separator:ac800cc10159d350923dc27446b9123f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6840885acb4ffa3e94e81a70b392fc" id="r_a9e6840885acb4ffa3e94e81a70b392fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e6840885acb4ffa3e94e81a70b392fc">matchOrConcat</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;Or, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a9e6840885acb4ffa3e94e81a70b392fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to combine or(zext(x),shl(zext(y),bw/2) concat packing patterns.  <br /></td></tr>
<tr class="separator:a9e6840885acb4ffa3e94e81a70b392fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7934618280f5dc61a34615b689744d1" id="r_aa7934618280f5dc61a34615b689744d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7934618280f5dc61a34615b689744d1">areInverseVectorBitmasks</a> (<a class="el" href="classllvm_1_1Constant.html">Constant</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">C1</a>, <a class="el" href="classllvm_1_1Constant.html">Constant</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">C2</a>)</td></tr>
<tr class="memdesc:aa7934618280f5dc61a34615b689744d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If all elements of two constant vectors are 0/-1 and inverses, return true.  <br /></td></tr>
<tr class="separator:aa7934618280f5dc61a34615b689744d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec897890074179e7de73b934798976" id="r_a45ec897890074179e7de73b934798976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45ec897890074179e7de73b934798976">foldAndOrOfICmpEqConstantAndICmp</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classllvm_1_1ilist__node__impl.html">IsAnd</a>, <a class="el" href="classbool.html">bool</a> IsLogical, <a class="el" href="classllvm_1_1IRBuilderBase.html">IRBuilderBase</a> &amp;Builder)</td></tr>
<tr class="separator:a45ec897890074179e7de73b934798976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3df3036740dfcdeb37c3ad977b039a" id="r_a3b3df3036740dfcdeb37c3ad977b039a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b3df3036740dfcdeb37c3ad977b039a">foldXorToXor</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a3b3df3036740dfcdeb37c3ad977b039a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ^ B can be specified using other logic ops in a variety of patterns.  <br /></td></tr>
<tr class="separator:a3b3df3036740dfcdeb37c3ad977b039a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff7fad11ba04c97f0a4b679c74cb394" id="r_a1ff7fad11ba04c97f0a4b679c74cb394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff7fad11ba04c97f0a4b679c74cb394">visitMaskedMerge</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a1ff7fad11ba04c97f0a4b679c74cb394"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we have a masked merge, in the canonical form of: (assuming that A only has one use.) | A | |B| ((x ^ y) &amp; M) ^ y | D |.  <br /></td></tr>
<tr class="separator:a1ff7fad11ba04c97f0a4b679c74cb394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb32db101ebeefe4466f59c63fcc723a" id="r_abb32db101ebeefe4466f59c63fcc723a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb32db101ebeefe4466f59c63fcc723a">sinkNotIntoXor</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="separator:abb32db101ebeefe4466f59c63fcc723a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e07326546257c169a5aff0d8b822a00" id="r_a0e07326546257c169a5aff0d8b822a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e07326546257c169a5aff0d8b822a00">foldNotXor</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="separator:a0e07326546257c169a5aff0d8b822a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2280e030e66011e1715514cd6965be59" id="r_a2280e030e66011e1715514cd6965be59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2280e030e66011e1715514cd6965be59">canonicalizeAbs</a> (<a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;Xor, <a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;Builder)</td></tr>
<tr class="memdesc:a2280e030e66011e1715514cd6965be59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize a shifty way to code absolute value to the more common pattern that uses negation and select.  <br /></td></tr>
<tr class="separator:a2280e030e66011e1715514cd6965be59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fda26317fcc1b226ecc5a9a28bf68fc" id="r_a4fda26317fcc1b226ecc5a9a28bf68fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fda26317fcc1b226ecc5a9a28bf68fc">canFreelyInvert</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="namespacellvm.html#ab471937b9a227e70c7fe8bd9604014d6">Op</a>, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">IgnoredUser</a>)</td></tr>
<tr class="separator:a4fda26317fcc1b226ecc5a9a28bf68fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf246a84f7e8596777a0231fa7d7bc9" id="r_a6bf246a84f7e8596777a0231fa7d7bc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bf246a84f7e8596777a0231fa7d7bc9">freelyInvert</a> (<a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;IC, <a class="el" href="classllvm_1_1Value.html">Value</a> *<a class="el" href="namespacellvm.html#ab471937b9a227e70c7fe8bd9604014d6">Op</a>, <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="classllvm_1_1ilist__node__impl.html">IgnoredUser</a>)</td></tr>
<tr class="separator:a6bf246a84f7e8596777a0231fa7d7bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;instcombine&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00025">25</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa9c705ecec80ebd584bb3d54b48f7ee1" name="aa9c705ecec80ebd584bb3d54b48f7ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c705ecec80ebd584bb3d54b48f7ee1">&#9670;&#160;</a></span>MaskedICmpType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">enum</a> <a class="el" href="#aa9c705ecec80ebd584bb3d54b48f7ee1">MaskedICmpType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Classify (icmp eq (A &amp; B), C) and (icmp ne (A &amp; B), C) as matching patterns that can be simplified. </p>
<p>One of A and B is considered the mask. The other is the value. This is described as the "AMask" or "BMask" part of the enum. If the enum contains only "Mask", then both A and B can be considered masks. If A is the mask, then it was proven that (A &amp; C) == C. This is trivial if C == A or C == 0. If both A and C are constants, this proof is also easy. For the following explanations, we assume that A is the mask.</p>
<p>"AllOnes" declares that the comparison is true only if (A &amp; B) == A or all bits of A are set in B. Example: (icmp eq (A &amp; 3), 3) -&gt; AMask_AllOnes</p>
<p>"AllZeros" declares that the comparison is true only if (A &amp; B) == 0 or all bits of A are cleared in B. Example: (icmp eq (A &amp; 3), 0) -&gt; Mask_AllZeroes</p>
<p>"Mixed" declares that (A &amp; B) == C and C might or might not contain any number of one bits and zero bits. Example: (icmp eq (A &amp; 3), 1) -&gt; AMask_Mixed</p>
<p>"Not" means that in above descriptions "==" should be replaced by "!=". Example: (icmp ne (A &amp; 3), 3) -&gt; AMask_NotAllOnes</p>
<p>If the mask A contains a single bit, then the following is equivalent: (icmp eq (A &amp; B), A) equals (icmp ne (A &amp; B), 0) (icmp ne (A &amp; B), A) equals (icmp eq (A &amp; B), 0) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a7cc1609a568ad3b240cf86126370e24f" name="aa9c705ecec80ebd584bb3d54b48f7ee1a7cc1609a568ad3b240cf86126370e24f"></a>AMask_AllOnes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a54ee032f1a4a27e3066fbb88346cd49a" name="aa9c705ecec80ebd584bb3d54b48f7ee1a54ee032f1a4a27e3066fbb88346cd49a"></a>AMask_NotAllOnes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a4357ae5a8ec7cec4162a1f25c69558ff" name="aa9c705ecec80ebd584bb3d54b48f7ee1a4357ae5a8ec7cec4162a1f25c69558ff"></a>BMask_AllOnes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a2b00a345b6b0214f7aa5cbe8203aeb3e" name="aa9c705ecec80ebd584bb3d54b48f7ee1a2b00a345b6b0214f7aa5cbe8203aeb3e"></a>BMask_NotAllOnes&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a37651a7acaf5871fb8a4d593749c06f4" name="aa9c705ecec80ebd584bb3d54b48f7ee1a37651a7acaf5871fb8a4d593749c06f4"></a>Mask_AllZeros&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1ac7606c30ddb7a593051b6e5ad209f30c" name="aa9c705ecec80ebd584bb3d54b48f7ee1ac7606c30ddb7a593051b6e5ad209f30c"></a>Mask_NotAllZeros&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1ada8a0932439ca5f15218c4d7cd43d895" name="aa9c705ecec80ebd584bb3d54b48f7ee1ada8a0932439ca5f15218c4d7cd43d895"></a>AMask_Mixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a1ee37b18b82ef426e90d86a093d45334" name="aa9c705ecec80ebd584bb3d54b48f7ee1a1ee37b18b82ef426e90d86a093d45334"></a>AMask_NotMixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a3f5a9337c05ff64ea433ed2d4e9d49d5" name="aa9c705ecec80ebd584bb3d54b48f7ee1a3f5a9337c05ff64ea433ed2d4e9d49d5"></a>BMask_Mixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa9c705ecec80ebd584bb3d54b48f7ee1a10e63e798489e9c5ad2dc2c5ed98ac10" name="aa9c705ecec80ebd584bb3d54b48f7ee1a10e63e798489e9c5ad2dc2c5ed98ac10"></a>BMask_NotMixed&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00141">141</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa7934618280f5dc61a34615b689744d1" name="aa7934618280f5dc61a34615b689744d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7934618280f5dc61a34615b689744d1">&#9670;&#160;</a></span>areInverseVectorBitmasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> areInverseVectorBitmasks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Constant.html">Constant</a> *</td>          <td class="paramname"><span class="paramname"><em>C1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Constant.html">Constant</a> *</td>          <td class="paramname"><span class="paramname"><em>C2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If all elements of two constant vectors are 0/-1 and inverses, return true. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02856">2856</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00461">llvm::PatternMatch::m_AllOnes()</a>, <a class="el" href="PatternMatch_8h_source.html#l00545">llvm::PatternMatch::m_Zero()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

</div>
</div>
<a id="a4fda26317fcc1b226ecc5a9a28bf68fc" name="a4fda26317fcc1b226ecc5a9a28bf68fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fda26317fcc1b226ecc5a9a28bf68fc">&#9670;&#160;</a></span>canFreelyInvert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> canFreelyInvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Op</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>IgnoredUser</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04022">4022</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombiner_8h_source.html#l00280">llvm::InstCombiner::canFreelyInvertAllUsersOf()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="InstCombiner_8h_source.html#l00236">llvm::InstCombiner::isFreeToInvert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04045">llvm::InstCombinerImpl::sinkNotIntoLogicalOp()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04091">llvm::InstCombinerImpl::sinkNotIntoOtherHandOfLogicalOp()</a>.</p>

</div>
</div>
<a id="a3f025ca3dbad2ca618ad4bf63fa51bb0" name="a3f025ca3dbad2ca618ad4bf63fa51bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f025ca3dbad2ca618ad4bf63fa51bb0">&#9670;&#160;</a></span>canNarrowShiftAmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> canNarrowShiftAmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Constant.html">Constant</a> *</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>BitWidth</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if a constant shift amount is always less than the specified bit-width. </p>
<p>If not, the shift could create poison in the narrower type. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01893">1893</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BitmaskEnum_8h_source.html#l00184">llvm::BitWidth</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="InstrTypes_8h_source.html#l00736">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="PatternMatch_8h_source.html#l00606">llvm::PatternMatch::m_SpecificInt_ICMP()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

</div>
</div>
<a id="a2280e030e66011e1715514cd6965be59" name="a2280e030e66011e1715514cd6965be59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2280e030e66011e1715514cd6965be59">&#9670;&#160;</a></span>canonicalizeAbs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * canonicalizeAbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Xor</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Canonicalize a shifty way to code absolute value to the more common pattern that uses negation and select. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03991">3991</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830eaec211f7c20af43e742bf2570c3cb84f9">llvm::Add</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Instructions_8h_source.html#l01760">llvm::SelectInst::Create()</a>, <a class="el" href="Value_8cpp_source.html#l00149">llvm::Value::hasNUses()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l01131">llvm::PatternMatch::m_AShr()</a>, <a class="el" href="PatternMatch_8h_source.html#l02279">llvm::PatternMatch::m_c_Add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>, and <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830ea76feb79109026728a20736a8c6504548">llvm::Xor</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04326">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
<a id="a7b8ca6f7206a11fd57d6e194b2523ffe" name="a7b8ca6f7206a11fd57d6e194b2523ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8ca6f7206a11fd57d6e194b2523ffe">&#9670;&#160;</a></span>canonicalizeLogicFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * canonicalizeLogicFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02117">2117</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="InstrTypes_8h_source.html#l00248">llvm::BinaryOperator::CreateWithCopiedFlags()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="llvm_2Support_2ErrorHandling_8h_source.html#l00143">llvm_unreachable</a>, <a class="el" href="PatternMatch_8h_source.html#l00987">llvm::PatternMatch::m_Add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02198">llvm::InstCombinerImpl::visitAnd()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03238">llvm::InstCombinerImpl::visitOr()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04326">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
<a id="a09c36c07a47775cef8f8e93d8090d919" name="a09c36c07a47775cef8f8e93d8090d919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c36c07a47775cef8f8e93d8090d919">&#9670;&#160;</a></span>conjugateICmpMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classunsigned.html">unsigned</a> conjugateICmpMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Mask</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an analysis of a masked ICmp into its equivalent if all boolean operations had the opposite sense. </p>
<p>Since each "NotXXX" flag (recording !=) is adjacent to the corresponding normal flag (recording ==), this just involves swapping those bits over. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00206">206</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00142">AMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00148">AMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00143">AMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00149">AMask_NotMixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00144">BMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00150">BMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00145">BMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00151">BMask_NotMixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00146">Mask_AllZeros</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00147">Mask_NotAllZeros</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00521">foldLogOpOfMaskedICmps()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00488">foldLogOpOfMaskedICmpsAsymmetric()</a>.</p>

</div>
</div>
<a id="a1d1267ddd1fbc10bd31ab88ecb2109bd" name="a1d1267ddd1fbc10bd31ab88ecb2109bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1267ddd1fbc10bd31ab88ecb2109bd">&#9670;&#160;</a></span>decomposeBitTestICmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> decomposeBitTestICmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>LHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>RHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CmpInst.html#a2be3583dac92a031fa1458d4d992c78b">CmpInst::Predicate</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Pred</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>X</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>Y</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>Z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00220">220</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="CmpInstAnalysis_8cpp_source.html#l00076">llvm::decomposeBitTestICmp()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

</div>
</div>
<a id="a940bbfdea38f2643d0b63c2cc5af4a82" name="a940bbfdea38f2643d0b63c2cc5af4a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940bbfdea38f2643d0b63c2cc5af4a82">&#9670;&#160;</a></span>extractIntPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * extractIntPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structIntPart.html">IntPart</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IRBuilderBase.html">IRBuilderBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Materialize an extraction of bits from an integer in IR. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01163">1163</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>.</p>

</div>
</div>
<a id="a45ec897890074179e7de73b934798976" name="a45ec897890074179e7de73b934798976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ec897890074179e7de73b934798976">&#9670;&#160;</a></span>foldAndOrOfICmpEqConstantAndICmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * foldAndOrOfICmpEqConstantAndICmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>LHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>RHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsAnd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsLogical</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IRBuilderBase.html">IRBuilderBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02995">2995</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="InstrTypes_8h_source.html#l00732">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00735">llvm::CmpInst::ICMP_UGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00734">llvm::CmpInst::ICMP_UGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00736">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="PatternMatch_8h_source.html#l00987">llvm::PatternMatch::m_Add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00284">llvm::PatternMatch::m_APIntAllowUndef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00870">llvm::PatternMatch::m_SpecificIntAllowUndef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="namespacellvm.html#a9eb4f5b98b70ee4fab9614ed58282c1fa6311ae17c1ee52b36e68aaf4ad066387">llvm::Other</a>.</p>

</div>
</div>
<a id="afce22397c3eff1d8c0dc8e3d8c464829" name="afce22397c3eff1d8c0dc8e3d8c464829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce22397c3eff1d8c0dc8e3d8c464829">&#9670;&#160;</a></span>foldAndOrOfICmpsWithConstEq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * foldAndOrOfICmpsWithConstEq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Cmp0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Cmp1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsAnd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsLogical</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1SimplifyQuery.html">SimplifyQuery</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce logic-of-compares with equality to a constant by substituting a common operand with the constant. </p>
<p>Callers are expected to call this with Cmp0/Cmp1 switched to handle logic op commutativity. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01222">1222</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="InstrTypes_8h_source.html#l00732">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00733">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="ValueTracking_8cpp_source.html#l06828">llvm::isGuaranteedNotToBeUndefOrPoison()</a>, <a class="el" href="PatternMatch_8h_source.html#l02265">llvm::PatternMatch::m_c_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00144">llvm::PatternMatch::m_Constant()</a>, <a class="el" href="PatternMatch_8h_source.html#l00798">llvm::PatternMatch::m_Deferred()</a>, <a class="el" href="PatternMatch_8h_source.html#l01402">llvm::PatternMatch::m_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="InstructionSimplify_8cpp_source.html#l04020">llvm::simplifyICmpInst()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

</div>
</div>
<a id="a385c1da88456d434ee18caa8f48018c2" name="a385c1da88456d434ee18caa8f48018c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385c1da88456d434ee18caa8f48018c2">&#9670;&#160;</a></span>foldAndToXor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldAndToXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01831">1831</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="Instructions_8cpp_source.html#l03100">llvm::BinaryOperator::CreateNot()</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l00084">llvm::PatternMatch::m_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l02293">llvm::PatternMatch::m_c_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02300">llvm::PatternMatch::m_c_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l00798">llvm::PatternMatch::m_Deferred()</a>, <a class="el" href="PatternMatch_8h_source.html#l02333">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l01107">llvm::PatternMatch::m_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02198">llvm::InstCombinerImpl::visitAnd()</a>.</p>

</div>
</div>
<a id="ab01a210491dcbefc8db253f4dbaa6497" name="ab01a210491dcbefc8db253f4dbaa6497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01a210491dcbefc8db253f4dbaa6497">&#9670;&#160;</a></span>foldComplexAndOrPatterns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldComplexAndOrPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try folding relatively complex patterns for both And and Or operations with all And and Or swapped. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01941">1941</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="Instructions_8cpp_source.html#l03044">llvm::BinaryOperator::Create()</a>, <a class="el" href="Instructions_8cpp_source.html#l03100">llvm::BinaryOperator::CreateNot()</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l00084">llvm::PatternMatch::m_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l02257">llvm::PatternMatch::m_c_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l02307">llvm::PatternMatch::m_c_Xor()</a>, <a class="el" href="PatternMatch_8h_source.html#l00224">llvm::PatternMatch::m_CombineAnd()</a>, <a class="el" href="PatternMatch_8h_source.html#l02333">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830ea3a2d5fe857d8f9541136a124c2edec6c">llvm::Or</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830ea76feb79109026728a20736a8c6504548">llvm::Xor</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02198">llvm::InstCombinerImpl::visitAnd()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03238">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="a6d4527846f6a8b98d7fe16428ff7a28e" name="a6d4527846f6a8b98d7fe16428ff7a28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4527846f6a8b98d7fe16428ff7a28e">&#9670;&#160;</a></span>foldIsPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * foldIsPowerOf2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Cmp0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Cmp1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>JoinedByAnd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce a pair of compares that check if a value has exactly 1 bit set. </p>
<p>Also used for logical and/or, must be poison safe. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00929">929</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::getPredicate()</a>, <a class="el" href="InstrTypes_8h_source.html#l00732">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00733">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="InstrTypes_8h_source.html#l00734">llvm::CmpInst::ICMP_UGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00736">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="PatternMatch_8h_source.html#l01402">llvm::PatternMatch::m_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00862">llvm::PatternMatch::m_SpecificInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00532">llvm::PatternMatch::m_ZeroInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

</div>
</div>
<a id="a3634e7e4bbadf2cb8229341858f520f3" name="a3634e7e4bbadf2cb8229341858f520f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3634e7e4bbadf2cb8229341858f520f3">&#9670;&#160;</a></span>foldIsPowerOf2OrZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * foldIsPowerOf2OrZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Cmp0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Cmp1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsAnd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold (icmp eq ctpop(X) 1) | (icmp eq X 0) into (icmp ult ctpop(X) 2) and fold (icmp ne ctpop(X) 1) &amp; (icmp ne X 0) into (icmp ugt ctpop(X) 1). </p>
<p>Also used for logical and/or, must be poison safe. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00909">909</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="InstrTypes_8h_source.html#l00732">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00733">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="PatternMatch_8h_source.html#l01402">llvm::PatternMatch::m_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00862">llvm::PatternMatch::m_SpecificInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00532">llvm::PatternMatch::m_ZeroInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

</div>
</div>
<a id="ad71f2a5fb47a5112628bfe2951eed48b" name="ad71f2a5fb47a5112628bfe2951eed48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71f2a5fb47a5112628bfe2951eed48b">&#9670;&#160;</a></span>foldLogicCastConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldLogicCastConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Logic</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1CastInst.html">CastInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Cast</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold {and,or,xor} (cast X), C. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01671">1671</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="InstrTypes_8h_source.html#l00391">llvm::BinaryOperator::getOpcode()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="Constants_8cpp_source.html#l02089">llvm::ConstantExpr::getSExt()</a>, <a class="el" href="InstrTypes_8h_source.html#l00673">llvm::CastInst::getSrcTy()</a>, <a class="el" href="Constants_8cpp_source.html#l02075">llvm::ConstantExpr::getTrunc()</a>, <a class="el" href="Value_8h_source.html#l00255">llvm::Value::getType()</a>, <a class="el" href="Constants_8cpp_source.html#l02103">llvm::ConstantExpr::getZExt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l01654">llvm::PatternMatch::m_SExt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01660">llvm::PatternMatch::m_ZExt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

</div>
</div>
<a id="a6c138f9e5e8e5c6a477b297d39d22094" name="a6c138f9e5e8e5c6a477b297d39d22094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c138f9e5e8e5c6a477b297d39d22094">&#9670;&#160;</a></span>foldLogOpOfMaskedICmps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * foldLogOpOfMaskedICmps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>LHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>RHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsAnd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsLogical</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to fold (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y). </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00521">521</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00142">AMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00143">AMask_NotAllOnes</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00144">BMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00150">BMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00145">BMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00151">BMask_NotMixed</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="RISCVRedundantCopyElimination_8cpp_source.html#l00079">CC</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00206">conjugateICmpMask()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00488">foldLogOpOfMaskedICmpsAsymmetric()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="InstrTypes_8h_source.html#l00825">llvm::CmpInst::getInversePredicate()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00236">getMaskedTypeForICmpPair()</a>, <a class="el" href="Constants_8cpp_source.html#l00356">llvm::Constant::getNullValue()</a>, <a class="el" href="InstrTypes_8h_source.html#l00732">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00733">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="Instructions_8h_source.html#l01275">llvm::ICmpInst::isEquality()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l06828">llvm::isGuaranteedNotToBeUndefOrPoison()</a>, <a class="el" href="X86PartialReduction_8cpp_source.html#l00075">LHS</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00146">Mask_AllZeros</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00147">Mask_NotAllZeros</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>.</p>

</div>
</div>
<a id="a30194649427f98c3ceaf7092c83911dc" name="a30194649427f98c3ceaf7092c83911dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30194649427f98c3ceaf7092c83911dc">&#9670;&#160;</a></span>foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>LHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>RHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsAnd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>A</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>D</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>E</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate</td>          <td class="paramname"><span class="paramname"><em>PredL</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate</td>          <td class="paramname"><span class="paramname"><em>PredR</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to fold (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y), where the left-hand side is of type Mask_NotAllZeros and the right hand side is of type BMask_Mixed. </p>
<p>For example, (icmp (A &amp; 12) != 0) &amp; (icmp (A &amp; 15) == 8) -&gt; (icmp (A &amp; 15) == 8). Also used for logical and/or, must be poison safe. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00366">366</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="InstrTypes_8h_source.html#l00732">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00733">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="X86PartialReduction_8cpp_source.html#l00076">RHS</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00488">foldLogOpOfMaskedICmpsAsymmetric()</a>.</p>

</div>
</div>
<a id="a6ea6a6eec165567da33302ad84811f84" name="a6ea6a6eec165567da33302ad84811f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea6a6eec165567da33302ad84811f84">&#9670;&#160;</a></span>foldLogOpOfMaskedICmpsAsymmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * foldLogOpOfMaskedICmpsAsymmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>LHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>RHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsAnd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>A</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>D</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>E</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate</td>          <td class="paramname"><span class="paramname"><em>PredL</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate</td>          <td class="paramname"><span class="paramname"><em>PredR</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>LHSMask</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>RHSMask</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to fold (icmp(A &amp; B) ==/!= 0) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y), where the left-hand side and the right hand side aren't of the common mask pattern type. </p>
<p>Also used for logical and/or, must be poison safe. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00488">488</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00150">BMask_Mixed</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00206">conjugateICmpMask()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00366">foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed()</a>, <a class="el" href="Instructions_8h_source.html#l01275">llvm::ICmpInst::isEquality()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00147">Mask_NotAllZeros</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00521">foldLogOpOfMaskedICmps()</a>.</p>

</div>
</div>
<a id="a5532e05d5caa4fb5e2b8512aa3095f1e" name="a5532e05d5caa4fb5e2b8512aa3095f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5532e05d5caa4fb5e2b8512aa3095f1e">&#9670;&#160;</a></span>foldNegativePower2AndShiftedMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * foldNegativePower2AndShiftedMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>A</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>D</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>E</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate</td>          <td class="paramname"><span class="paramname"><em>PredL</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate</td>          <td class="paramname"><span class="paramname"><em>PredR</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to fold (icmp(A &amp; B) == 0) &amp; (icmp(A &amp; D) != E) into (icmp A u&lt; D) iff B is a contiguous set of ones starting from the most significant bit (negative power of 2), D and E are equal, and D is a contiguous set of ones starting at the most significant zero bit in B. </p>
<p>Parameter B supports masking using undef/poison in either scalar or vector values. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00963">963</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="InstrTypes_8h_source.html#l00732">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00733">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="InstrTypes_8h_source.html#l00736">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="Instructions_8h_source.html#l01275">llvm::ICmpInst::isEquality()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00284">llvm::PatternMatch::m_APIntAllowUndef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00560">llvm::PatternMatch::m_NegatedPower2()</a>, <a class="el" href="PatternMatch_8h_source.html#l00452">llvm::PatternMatch::m_ShiftedMask()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01029">foldPowerOf2AndShiftedMask()</a>.</p>

</div>
</div>
<a id="a0e07326546257c169a5aff0d8b822a00" name="a0e07326546257c169a5aff0d8b822a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e07326546257c169a5aff0d8b822a00">&#9670;&#160;</a></span>foldNotXor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldNotXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03954">3954</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l01101">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02333">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l01107">llvm::PatternMatch::m_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01113">llvm::PatternMatch::m_Xor()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03940">sinkNotIntoXor()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

</div>
</div>
<a id="a26257c73e483eab4b0e15d53340de986" name="a26257c73e483eab4b0e15d53340de986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26257c73e483eab4b0e15d53340de986">&#9670;&#160;</a></span>foldOrToXor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldOrToXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01857">1857</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="Instructions_8cpp_source.html#l03100">llvm::BinaryOperator::CreateNot()</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l01101">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02293">llvm::PatternMatch::m_c_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02300">llvm::PatternMatch::m_c_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l02333">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01113">llvm::PatternMatch::m_Xor()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03238">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="a609a05f40709dea74bb5cd248c5816fd" name="a609a05f40709dea74bb5cd248c5816fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609a05f40709dea74bb5cd248c5816fd">&#9670;&#160;</a></span>foldPowerOf2AndShiftedMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * foldPowerOf2AndShiftedMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Cmp0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>Cmp1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>JoinedByAnd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to fold ((icmp X u&lt; P) &amp; (icmp(X &amp; M) != M)) or ((icmp X s&gt; -1) &amp; (icmp(X &amp; M) != M)) into (icmp X u&lt; M). </p>
<p>Where P is a power of 2, M &lt; P, and M is a contiguous shifted mask starting at the right most significant zero bit in P. SGT is supported as when P is the largest representable power of 2, an earlier optimization converts the expression into (icmp X s&gt; -1). Parameter P supports masking using undef/poison in either scalar or vector values. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01029">1029</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00145">BMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00151">BMask_NotMixed</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00963">foldNegativePower2AndShiftedMask()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00236">getMaskedTypeForICmpPair()</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::getPredicate()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00146">Mask_AllZeros</a>.</p>

</div>
</div>
<a id="a1f569ebf4402ad560d7c147f688ac05a" name="a1f569ebf4402ad560d7c147f688ac05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f569ebf4402ad560d7c147f688ac05a">&#9670;&#160;</a></span>foldSignedTruncationCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * foldSignedTruncationCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>ICmp0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>ICmp1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>CxtI</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General pattern: X &amp; Y. </p>
<p>Where Y is checking that all the high bits (covered by a mask 4294967168) are uniform, i.e. arg &amp; 4294967168 can be either 4294967168 or 0 Pattern can be one of: t = add i32 arg, 128 r = icmp ult i32 t, 256 Or t0 = shl i32 arg, 24 t1 = ashr i32 t0, 24 r = icmp eq i32 t1, arg Or t0 = trunc i32 arg to i8 t1 = sext i8 t0 to i32 r = icmp eq i32 t1, arg This pattern is a signed truncation check.</p>
<p>And X is checking that some bit in that same mask is zero. I.e. can be one of: r = icmp sgt i32 arg, -1 Or t = and i32 arg, 2147483648 r = icmp eq i32 t, 0</p>
<p>Since we are checking that all the bits in that mask are the same, and a particular bit is zero, what we are really checking is that all the masked bits are zero. So this should be transformed to: r = icmp ult i32 arg, 128 </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00812">812</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CmpInstAnalysis_8cpp_source.html#l00076">llvm::decomposeBitTestICmp()</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="Value_8cpp_source.html#l00309">llvm::Value::getName()</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00168">llvm::Instruction::getOpcode()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="InstrTypes_8h_source.html#l00801">llvm::CmpInst::getPredicate()</a>, <a class="el" href="InstrTypes_8h_source.html#l00732">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00736">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="PatternMatch_8h_source.html#l00987">llvm::PatternMatch::m_Add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01101">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l01402">llvm::PatternMatch::m_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00552">llvm::PatternMatch::m_Power2()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l01642">llvm::PatternMatch::m_Trunc()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00545">llvm::PatternMatch::m_Zero()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="APInt_8h_source.html#l02181">llvm::APIntOps::umin()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

</div>
</div>
<a id="a24dce8fa354f0f1d52209e805f0ae6a3" name="a24dce8fa354f0f1d52209e805f0ae6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dce8fa354f0f1d52209e805f0ae6a3">&#9670;&#160;</a></span>foldUnsignedUnderflowCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * foldUnsignedUnderflowCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>ZeroICmp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>UnsignedICmp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>IsAnd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="structllvm_1_1SimplifyQuery.html">SimplifyQuery</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commuted variants are assumed to be handled by calling this function again with the parameters swapped. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01062">1062</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="InstructionSimplify_8h_source.html#l00098">llvm::SimplifyQuery::AC</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="Discriminator_8h_source.html#l00058">llvm::sampleprof::Base</a>, <a class="el" href="InstructionSimplify_8h_source.html#l00099">llvm::SimplifyQuery::CxtI</a>, <a class="el" href="InstructionSimplify_8h_source.html#l00095">llvm::SimplifyQuery::DL</a>, <a class="el" href="InstructionSimplify_8h_source.html#l00097">llvm::SimplifyQuery::DT</a>, <a class="el" href="InstrTypes_8h_source.html#l00732">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00733">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="InstrTypes_8h_source.html#l00735">llvm::CmpInst::ICMP_UGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00734">llvm::CmpInst::ICMP_UGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00737">llvm::CmpInst::ICMP_ULE</a>, <a class="el" href="InstrTypes_8h_source.html#l00736">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="Instructions_8h_source.html#l01275">llvm::ICmpInst::isEquality()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l00290">llvm::isKnownNonZero()</a>, <a class="el" href="InstrTypes_8h_source.html#l00967">llvm::CmpInst::isUnsigned()</a>, <a class="el" href="PatternMatch_8h_source.html#l02279">llvm::PatternMatch::m_c_Add()</a>, <a class="el" href="PatternMatch_8h_source.html#l02265">llvm::PatternMatch::m_c_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l01402">llvm::PatternMatch::m_ICmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00999">llvm::PatternMatch::m_Sub()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00545">llvm::PatternMatch::m_Zero()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="DWP_8cpp_source.html#l00440">llvm::Offset</a>, <a class="el" href="namespacellvm.html#a9eb4f5b98b70ee4fab9614ed58282c1fa6311ae17c1ee52b36e68aaf4ad066387">llvm::Other</a>, and <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>.</p>

</div>
</div>
<a id="a3b3df3036740dfcdeb37c3ad977b039a" name="a3b3df3036740dfcdeb37c3ad977b039a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3df3036740dfcdeb37c3ad977b039a">&#9670;&#160;</a></span>foldXorToXor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * foldXorToXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A ^ B can be specified using other logic ops in a variety of patterns. </p>
<p>We can fold these early and efficiently by morphing an existing instruction. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03728">3728</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="Instructions_8cpp_source.html#l03100">llvm::BinaryOperator::CreateNot()</a>, <a class="el" href="Value_8h_source.html#l00434">llvm::Value::hasOneUse()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l01101">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02293">llvm::PatternMatch::m_c_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02300">llvm::PatternMatch::m_c_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l02307">llvm::PatternMatch::m_c_Xor()</a>, <a class="el" href="PatternMatch_8h_source.html#l00798">llvm::PatternMatch::m_Deferred()</a>, <a class="el" href="PatternMatch_8h_source.html#l02333">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l01107">llvm::PatternMatch::m_Or()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01113">llvm::PatternMatch::m_Xor()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04326">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
<a id="a6bf246a84f7e8596777a0231fa7d7bc9" name="a6bf246a84f7e8596777a0231fa7d7bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf246a84f7e8596777a0231fa7d7bc9">&#9670;&#160;</a></span>freelyInvert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * freelyInvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Op</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *</td>          <td class="paramname"><span class="paramname"><em>IgnoredUser</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04029">4029</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstCombiner_8h_source.html#l00059">llvm::InstCombiner::Builder</a>, <a class="el" href="IRBuilder_8h_source.html#l01707">llvm::IRBuilderBase::CreateNot()</a>, <a class="el" href="InstructionCombining_8cpp_source.html#l01153">llvm::InstCombinerImpl::freelyInvertAllUsersOf()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, and <a class="el" href="IRBuilder_8h_source.html#l00180">llvm::IRBuilderBase::SetInsertPoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04045">llvm::InstCombinerImpl::sinkNotIntoLogicalOp()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04091">llvm::InstCombinerImpl::sinkNotIntoOtherHandOfLogicalOp()</a>.</p>

</div>
</div>
<a id="ab72e7003829df7704d63a8d830742a35" name="ab72e7003829df7704d63a8d830742a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72e7003829df7704d63a8d830742a35">&#9670;&#160;</a></span>getFCmpValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * getFCmpValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>LHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>RHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the complement of getFCmpCode, which turns an opcode and two operands into either a FCmp instruction, or a true/false constant. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00041">41</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="CmpInstAnalysis_8cpp_source.html#l00064">llvm::getPredForFCmpCode()</a>.</p>

</div>
</div>
<a id="a39257c6c73db3440e6d05b9eec5999a0" name="a39257c6c73db3440e6d05b9eec5999a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39257c6c73db3440e6d05b9eec5999a0">&#9670;&#160;</a></span>getMaskedICmpType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classunsigned.html">unsigned</a> getMaskedICmpType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>A</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate</td>          <td class="paramname"><span class="paramname"><em>Pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the set of patterns (from MaskedICmpType) that (icmp SCC (A &amp; B), C) satisfies. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00156">156</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00142">AMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00148">AMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00143">AMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00149">AMask_NotMixed</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00144">BMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00150">BMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00145">BMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00151">BMask_NotMixed</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="InstrTypes_8h_source.html#l00732">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00146">Mask_AllZeros</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00147">Mask_NotAllZeros</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00236">getMaskedTypeForICmpPair()</a>.</p>

</div>
</div>
<a id="a9216b6f91863c6f4c51e03aa7147c019" name="a9216b6f91863c6f4c51e03aa7147c019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9216b6f91863c6f4c51e03aa7147c019">&#9670;&#160;</a></span>getMaskedTypeForICmpPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> std::optional&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt; getMaskedTypeForICmpPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>B</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>C</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>D</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>E</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>LHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>RHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>PredL</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>PredR</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E). </p>
<p>Return the pattern classes (from MaskedICmpType) for the left hand side and the right hand side as a pair. LHS and RHS are the left hand side and the right hand side ICmps and PredL and PredR are their predicates, respectively. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00236">236</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="CmpInstAnalysis_8cpp_source.html#l00076">llvm::decomposeBitTestICmp()</a>, <a class="el" href="BuiltinGCs_8cpp.html#ab5899ca200d34e3cc6bb09ebce5e5b3c">E</a>, <a class="el" href="Constants_8cpp_source.html#l00403">llvm::Constant::getAllOnesValue()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00156">getMaskedICmpType()</a>, <a class="el" href="Instructions_8h_source.html#l01275">llvm::ICmpInst::isEquality()</a>, <a class="el" href="PatternMatch_8h_source.html#l01101">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="MathExtras_8h.html#a9211f62d8e1e6de999eaa63ec0f6ae02">R2</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00521">foldLogOpOfMaskedICmps()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01029">foldPowerOf2AndShiftedMask()</a>.</p>

</div>
</div>
<a id="a89cfa00019cb17baa05532705ea198e0" name="a89cfa00019cb17baa05532705ea198e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cfa00019cb17baa05532705ea198e0">&#9670;&#160;</a></span>getNewICmpValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * getNewICmpValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>Code</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>Sign</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>LHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>RHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the complement of getICmpCode, which turns an opcode and two operands into either a constant true or false, or a brand new ICmp instruction. </p>
<p>The sign is passed in to determine which kind of predicate to use in the new icmp instruction. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00031">31</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="CmpInstAnalysis_8cpp_source.html#l00040">llvm::getPredForICmpCode()</a>.</p>

</div>
</div>
<a id="a11d0af3e9f9322e328e67694a9af7d02" name="a11d0af3e9f9322e328e67694a9af7d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d0af3e9f9322e328e67694a9af7d02">&#9670;&#160;</a></span>matchDeMorgansLaws()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * matchDeMorgansLaws </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match variations of De Morgan's Laws: (~A &amp; ~B) == (~(A | B)) (~A | ~B) == (~(A &amp; B)) </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01618">1618</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a3545a9491d4dcf823feb79f6eb37e3ee">A</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="Instructions_8cpp_source.html#l03044">llvm::BinaryOperator::Create()</a>, <a class="el" href="Instructions_8cpp_source.html#l03100">llvm::BinaryOperator::CreateNot()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="InstCombiner_8h_source.html#l00236">llvm::InstCombiner::isFreeToInvert()</a>, <a class="el" href="PatternMatch_8h_source.html#l02257">llvm::PatternMatch::m_c_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l02333">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02198">llvm::InstCombinerImpl::visitAnd()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03238">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="ac800cc10159d350923dc27446b9123f0" name="ac800cc10159d350923dc27446b9123f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac800cc10159d350923dc27446b9123f0">&#9670;&#160;</a></span>matchFunnelShift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * matchFunnelShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Or</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombinerImpl.html">InstCombinerImpl</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>IC</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match UB-safe variants of the funnel shift intrinsic. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02701">2701</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="InstCombiner_8h_source.html#l00464">llvm::InstCombiner::computeKnownBits()</a>, <a class="el" href="Instructions_8h_source.html#l01511">llvm::CallInst::Create()</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="Constants_8cpp_source.html#l02566">llvm::ConstantExpr::getAdd()</a>, <a class="el" href="Function_8cpp_source.html#l01421">llvm::Intrinsic::getDeclaration()</a>, <a class="el" href="InstrTypes_8h_source.html#l00736">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="MathExtras_8h_source.html#l00264">llvm::isPowerOf2_32()</a>, <a class="el" href="PatternMatch_8h_source.html#l01101">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l00284">llvm::PatternMatch::m_APIntAllowUndef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00084">llvm::PatternMatch::m_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00144">llvm::PatternMatch::m_Constant()</a>, <a class="el" href="PatternMatch_8h_source.html#l01319">llvm::PatternMatch::m_LogicalShift()</a>, <a class="el" href="PatternMatch_8h_source.html#l02315">llvm::PatternMatch::m_Neg()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00780">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00862">llvm::PatternMatch::m_SpecificInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00606">llvm::PatternMatch::m_SpecificInt_ICMP()</a>, <a class="el" href="PatternMatch_8h_source.html#l00870">llvm::PatternMatch::m_SpecificIntAllowUndef()</a>, <a class="el" href="PatternMatch_8h_source.html#l00999">llvm::PatternMatch::m_Sub()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01660">llvm::PatternMatch::m_ZExt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="Constants_8cpp_source.html#l00777">llvm::Constant::mergeUndefsWith()</a>, <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830ea3a2d5fe857d8f9541136a124c2edec6c">llvm::Or</a>, <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>, <a class="el" href="APInt_8h_source.html#l01083">llvm::APInt::ult()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

<p class="reference">Referenced by <a class="el" href="AggressiveInstCombine_8cpp_source.html#l00053">foldGuardedFunnelShift()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03238">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="a7662d7ee7f100c9455f4a2c7e4992929" name="a7662d7ee7f100c9455f4a2c7e4992929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7662d7ee7f100c9455f4a2c7e4992929">&#9670;&#160;</a></span>matchIntPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> std::optional&lt; <a class="el" href="structIntPart.html">IntPart</a> &gt; matchIntPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match an extraction of bits from an integer. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01145">1145</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="APInt_8h_source.html#l01485">llvm::APInt::getZExtValue()</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l01125">llvm::PatternMatch::m_LShr()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l01642">llvm::PatternMatch::m_Trunc()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="APInt_8h_source.html#l01122">llvm::APInt::ule()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

</div>
</div>
<a id="a5946d75decfd106d2b75af6d59009f34" name="a5946d75decfd106d2b75af6d59009f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5946d75decfd106d2b75af6d59009f34">&#9670;&#160;</a></span>matchIsFiniteTest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * matchIsFiniteTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1FCmpInst.html">FCmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>LHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1FCmpInst.html">FCmpInst</a> *</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>and (fcmp ord x, 0), (fcmp u* x, inf) -&gt; fcmp o* x, inf </p>
<p>Clang emits this pattern for doing an isfinite check in __builtin_isnormal. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01360">1360</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstrTypes_8h_source.html#l00836">llvm::CmpInst::getOrderedPredicate()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01347">matchIsNotNaN()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01352">matchUnorderedInfCompare()</a>.</p>

</div>
</div>
<a id="a151e95d3f063067aa27c74930296a25e" name="a151e95d3f063067aa27c74930296a25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151e95d3f063067aa27c74930296a25e">&#9670;&#160;</a></span>matchIsFPClassLikeFCmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> matchIsFPClassLikeFCmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Op</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>ClassVal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuint64__t.html">uint64_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ClassMask</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match an fcmp against a special value that performs a test possible by llvm.is.fpclass. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01471">1471</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueTracking_8cpp_source.html#l03939">llvm::fcmpToClassTest()</a>.</p>

</div>
</div>
<a id="a9e92e028c2dd81bf7d518dfc3960624a" name="a9e92e028c2dd81bf7d518dfc3960624a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e92e028c2dd81bf7d518dfc3960624a">&#9670;&#160;</a></span>matchIsNotNaN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> matchIsNotNaN </td>
          <td>(</td>
          <td class="paramtype">FCmpInst::Predicate</td>          <td class="paramname"><span class="paramname"><em>P</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>LHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches canonical form of isnan, fcmp ord x, 0. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01347">1347</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="InstrTypes_8h_source.html#l00720">llvm::CmpInst::FCMP_ORD</a>, <a class="el" href="PatternMatch_8h_source.html#l00672">llvm::PatternMatch::m_AnyZeroFP()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01360">matchIsFiniteTest()</a>.</p>

</div>
</div>
<a id="a9e6840885acb4ffa3e94e81a70b392fc" name="a9e6840885acb4ffa3e94e81a70b392fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6840885acb4ffa3e94e81a70b392fc">&#9670;&#160;</a></span>matchOrConcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * matchOrConcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Or</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to combine or(zext(x),shl(zext(y),bw/2) concat packing patterns. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02803">2803</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="Function_8cpp_source.html#l01421">llvm::Intrinsic::getDeclaration()</a>, <a class="el" href="namespacellvm.html#a9ac8e4e13ad96a39c3f8db9ed633ad2bac1a5298f939e87e8f962a5edfc206918">llvm::Hi</a>, <a class="el" href="namespacellvm.html#a9ac8e4e13ad96a39c3f8db9ed633ad2baff50b4aa1c9cc2197ef898436641c911">llvm::Lo</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l02192">llvm::PatternMatch::m_BitReverse()</a>, <a class="el" href="PatternMatch_8h_source.html#l02197">llvm::PatternMatch::m_BSwap()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l01119">llvm::PatternMatch::m_Shl()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l01660">llvm::PatternMatch::m_ZExt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="namespacellvm.html#aac36edd0f1ce976f0025c98e88d3830ea3a2d5fe857d8f9541136a124c2edec6c">llvm::Or</a>, and <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03238">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="a9977c80be67ea7e51bb37ee242d1cc4c" name="a9977c80be67ea7e51bb37ee242d1cc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9977c80be67ea7e51bb37ee242d1cc4c">&#9670;&#160;</a></span>matchUnorderedInfCompare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classbool.html">bool</a> matchUnorderedInfCompare </td>
          <td>(</td>
          <td class="paramtype">FCmpInst::Predicate</td>          <td class="paramname"><span class="paramname"><em>P</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>LHS</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches fcmp u__ x, +/-inf. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01352">1352</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8cpp_source.html#l04503">llvm::CmpInst::isUnordered()</a>, <a class="el" href="PatternMatch_8h_source.html#l00634">llvm::PatternMatch::m_Inf()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, and <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01360">matchIsFiniteTest()</a>.</p>

</div>
</div>
<a id="a8208d3cd3c60073f5c9ceefec06ab2e3" name="a8208d3cd3c60073f5c9ceefec06ab2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8208d3cd3c60073f5c9ceefec06ab2e3">&#9670;&#160;</a></span>reassociateFCmps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * reassociateFCmps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>BO</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This a limited reassociation for a special case (see above) where we are checking if two values are either both NAN (unordered) or not-NAN (ordered). </p>
<p>This could be handled more generally in '-reassociation', but it seems like an unlikely pattern for a large number of logic ops and fcmps. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01573">1573</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Instructions_8cpp_source.html#l03044">llvm::BinaryOperator::Create()</a>, <a class="el" href="InstrTypes_8h_source.html#l00720">llvm::CmpInst::FCMP_ORD</a>, <a class="el" href="InstrTypes_8h_source.html#l00721">llvm::CmpInst::FCMP_UNO</a>, <a class="el" href="InstrTypes_8h_source.html#l00391">llvm::BinaryOperator::getOpcode()</a>, <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>, <a class="el" href="PatternMatch_8h_source.html#l00672">llvm::PatternMatch::m_AnyZeroFP()</a>, <a class="el" href="PatternMatch_8h_source.html#l00084">llvm::PatternMatch::m_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l01408">llvm::PatternMatch::m_FCmp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02198">llvm::InstCombinerImpl::visitAnd()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03238">llvm::InstCombinerImpl::visitOr()</a>.</p>

</div>
</div>
<a id="ac80e92048884e85b87ddd733785e44d9" name="ac80e92048884e85b87ddd733785e44d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80e92048884e85b87ddd733785e44d9">&#9670;&#160;</a></span>reassociateForUses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * reassociateForUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>BO</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombinerImpl::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to reassociate a pair of binops so that values with one use only are part of the same instruction. </p>
<p>This may enable folds that are limited with multi-use restrictions and makes it more likely to match other patterns that are looking for a common operand. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02084">2084</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8cpp_source.html#l03044">llvm::BinaryOperator::Create()</a>, <a class="el" href="InstrTypes_8h_source.html#l00391">llvm::BinaryOperator::getOpcode()</a>, <a class="el" href="PatternMatch_8h_source.html#l00084">llvm::PatternMatch::m_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l02257">llvm::PatternMatch::m_c_BinOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02198">llvm::InstCombinerImpl::visitAnd()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03238">llvm::InstCombinerImpl::visitOr()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04326">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
<a id="ac480d1a3d980979539ddec168ecd72a4" name="ac480d1a3d980979539ddec168ecd72a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac480d1a3d980979539ddec168ecd72a4">&#9670;&#160;</a></span>SimplifyBSwap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * SimplifyBSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform BITWISE_OP(BSWAP(A),BSWAP(B)) or BITWISE_OP(BSWAP(A), Constant) to BSWAP(BITWISE_OP(A, B)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>Binary operator to transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to node that must replace the original binary operator, or null pointer if no transformation was made. </dd></dl>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00054">54</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="MD5_8cpp_source.html#l00055">F</a>, <a class="el" href="Constants_8cpp_source.html#l00888">llvm::ConstantInt::get()</a>, <a class="el" href="Function_8cpp_source.html#l01421">llvm::Intrinsic::getDeclaration()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l00278">llvm::PatternMatch::m_APInt()</a>, <a class="el" href="PatternMatch_8h_source.html#l02197">llvm::PatternMatch::m_BSwap()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02198">llvm::InstCombinerImpl::visitAnd()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03238">llvm::InstCombinerImpl::visitOr()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04326">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
<a id="abb32db101ebeefe4466f59c63fcc723a" name="abb32db101ebeefe4466f59c63fcc723a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb32db101ebeefe4466f59c63fcc723a">&#9670;&#160;</a></span>sinkNotIntoXor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * sinkNotIntoXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>X</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Y</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03940">3940</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="InstCombiner_8h_source.html#l00236">llvm::InstCombiner::isFreeToInvert()</a>, <a class="el" href="BitVector_8h_source.html#l00860">std::swap()</a>, <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>, and <a class="el" href="OcamlGCPrinter_8cpp.html#a93c84752b140ee7b31646fc34cfa0dc2">Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03954">foldNotXor()</a>.</p>

</div>
</div>
<a id="a67ccec2dd2fc482ea50af1764f1db598" name="a67ccec2dd2fc482ea50af1764f1db598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ccec2dd2fc482ea50af1764f1db598">&#9670;&#160;</a></span>stripSignOnlyFPOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Value.html">Value</a> * stripSignOnlyFPOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ignore all operations which only change the sign of a value, returning the underlying magnitude value. </p>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01339">1339</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l02241">llvm::PatternMatch::m_CopySign()</a>, <a class="el" href="PatternMatch_8h_source.html#l02202">llvm::PatternMatch::m_FAbs()</a>, <a class="el" href="PatternMatch_8h_source.html#l01041">llvm::PatternMatch::m_FNeg()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>.</p>

</div>
</div>
<a id="a1ff7fad11ba04c97f0a4b679c74cb394" name="a1ff7fad11ba04c97f0a4b679c74cb394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff7fad11ba04c97f0a4b679c74cb394">&#9670;&#160;</a></span>visitMaskedMerge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ilist__node__impl.html">static</a> <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * visitMaskedMerge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1BinaryOperator.html">BinaryOperator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BoundsChecking_8cpp.html#afd78647acffe6ba49be0ee476c9a1024">InstCombiner::BuilderTy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we have a masked merge, in the canonical form of: (assuming that A only has one use.) | A | |B| ((x ^ y) &amp; M) ^ y | D |. </p>
<ul>
<li>If M is inverted: | D | ((x ^ y) &amp; ~M) ^ y We can canonicalize by swapping the final xor operand to eliminate the 'not' of the mask. ((x ^ y) &amp; M) ^ x</li>
<li>If M is a constant, and D has one use, we transform to 'and' / 'or' ops because that shortens the dependency chain and improves analysis: (x &amp; M) | (y &amp; ~M) </li>
</ul>

<p class="definition">Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l03901">3901</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a11d755651840a5529d15260aacde92f3">B</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="BuiltinGCs_8cpp.html#a9cb3a7d37a9414f3dc2cdca773d6dee6">D</a>, <a class="el" href="Constants_8cpp_source.html#l00403">llvm::Constant::getAllOnesValue()</a>, <a class="el" href="Type_8h_source.html#l00349">llvm::Type::getScalarType()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="PatternMatch_8h_source.html#l02293">llvm::PatternMatch::m_c_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l02307">llvm::PatternMatch::m_c_Xor()</a>, <a class="el" href="PatternMatch_8h_source.html#l00224">llvm::PatternMatch::m_CombineAnd()</a>, <a class="el" href="PatternMatch_8h_source.html#l00144">llvm::PatternMatch::m_Constant()</a>, <a class="el" href="PatternMatch_8h_source.html#l00798">llvm::PatternMatch::m_Deferred()</a>, <a class="el" href="PatternMatch_8h_source.html#l02333">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l00067">llvm::PatternMatch::m_OneUse()</a>, <a class="el" href="PatternMatch_8h_source.html#l00076">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00049">llvm::PatternMatch::match()</a>, <a class="el" href="Constants_8cpp_source.html#l00753">llvm::Constant::replaceUndefsWith()</a>, and <a class="el" href="ErlangGCPrinter_8cpp.html#a7ad930f7345a8faa5e6132305e2a6f49">X</a>.</p>

<p class="reference">Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l04326">llvm::InstCombinerImpl::visitXor()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 21 2024 13:50:39 for LLVM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
